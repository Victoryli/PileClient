[state]	init	初始化									#																																																																															
	#log	"初始化="	gun
	#	mp	acb.gunLockNegation			1							#	枪信号是否取反																																																																														
	#	预定义加锁的状态,节省空间,提高后台效率																																																																																										
#	var	tmp	state	pile-work																																																																																							
#	初始化需要工程人员配置的设置																																																																																										
	call	init-setup																																																																																									
	mp	center.curGun		gun																																																																																							
	mp	center.curPileNo			1		#	当前桩号，from 1
	mp	center.curPile		mp	center.curPileNo			-	1	#	当前桩索引(from 0)=当前桩号-1																																																																															
	mp	center.isDoubleGun	0
	mp	center.isCardStart	0	#0表示无卡；1表示有卡	
	#	常量初始化-center.chgStatus																																																																																										
	const	st-standby		0		#	待机																																																																																				
	const	st-assist		1		#	辅助状态																																																																																				
	const	st-lock			2		#	刷卡锁桩																																																																																				
	const	st-passed		3		#	论证通过																																																																																				
	const	st-toserver		4		#	去服务器验证密码																																																																																				
	const	st-configed		5		#	配置完成																																																																																				
	const	st-handshake	6		#	握手																																																																																				
	const	st-insul		7		#	开始进行绝缘检测																																																																																				
	const	st-insulok		8		#	绝缘检测成功																																																																																				
	const	st-piles		9		#	辅桩确定																																																																																				
	const	st-start		10		#	启机中																																																																																				
	const	st-charge		11		#	充电中																																																																																				
	const	st-tostop		12		#	通知结账寻卡																																																																																				
	const	st-stop			13		#	停机中																																																																																				
	const	st-stopped		14		#	已停机																																																																																				
	const	st-checkout		15		#	结账中																																																																																				
	const	st-tocheckout	16		#	通知读卡器结账																																																																																				
	const	st-checkouted	17		#	已结账,等待各流程结束																																																																																				
#	常量初始化-常量代替定义宏																																																				
	const	GunA			0	#	A枪索引																																														
	const	GunB			1	#	B枪索引																																																																																													
#	常量初始化-停止充电原因																																																																																										
	const	sr-bms-err			15	#	充电中,BMS异常停机																																																																																				
	const	sr-bms-ok			16	#	充电中,BMS充满停机																																																																																				
	const	sr-bms-tmo			24	#	BMS通讯中断或超时																																																																																				
	const	sr-pile-lack		17	#	启动中,辅助桩功率不足																																																																																				
	const	sr-pile-off			23	#	辅助桩通讯中断																																																																																				
	const	sr-app-stop			27	#	app停止充电																																																																																				
	const	sr-card-stop		13	#	刷卡停机																																																																																				
	const	sr-tmo-retry		37	#	超时重试																																																																																				
	const	sr-insult-tmo		34	#	绝缘检测超时																																																																																				
																																																																																											
	const	chgr-mode-standby	0	#	停机																																																																																				
	const	chgr-mode-start		2	#	启机
	const	chgr-mode-stop		1	#	停机中
	const	chgr-mode-starting	3	#	启机中
	const	chgr-mode-charging	10	#	启机,充电中																																																																																				

	#	常量初始化-pile																																																																																										
#	const	pl-tmo		10000		#	超时时间																																																																																				
#	const	pl-send		2000		#	定时发送周期																																																																																				
#	常量初始化-bms																																																																																										
#	const	bms-tmo		5000		#	超时时间																																																																																				
#	const	bms-send		250		#	定时发送周期																																																																																				
#	const	bms-chgtmo		200		#	充电时,超时时间																																																																																				
#	const	bms-chgsend		50		#	充电时,定时发送周期																																																																																				
#	常量初始化-bms mpkg,多包																																																																																										
#	const	mpkg-tmo		1250		#	超时时间																																																																																				
#	const	mpkg-recv-RTS		1		#	多包接收的内容																																																																																				
#	const	mpkg-recv-CTS		2																																																																																							
#	const	mpkg-recv-DT		3		#	data																																																																																				
#	const	mpkg-recv-End		4																																																																																							
#	const	mpkg-recv-Abort			5																																																																																						
																																																																																											
#	初始化测点																																																																																										
	mpofs	center.addr			0	11						#	桩地址																																																																														
	mpofs	center.addr			1	12						#	桩地址																																																																														
	mpofs	center.addr			2	13						#	桩地址																																																																														
	mpofs	center.addr			3	14						#	桩地址																																																																														
																																																																																											
	mpofs	center.frontAddr	0	1						#	CC地址																																																																														
#	mpofs	b.center.frontAddr	1	6						#	前置地址																																																																														
	mpofs	center.frontAddr	2	7						#	前置地址																																																																														
	mpofs	center.frontAddr	3	8						#	前置地址																																																																														
	mpofs	a.center.backAddr	0	6						#	GUN 1 CJ地址																																																																														
	mpofs	b.center.backAddr	0	3						#	GUN 2 CJ地址																																																																														
	mpofs	center.backAddr		1	6						#																																																																														
	mpofs	center.backAddr		2	3						#	后置地址																																																																														
	mpofs	center.backAddr		3	4						#	后置地址																																																																														
																																																																																											
	mp		chgr.addr				1						#	模块地址																																																																														
	mpofs	chgr.addr			1	2						#	模块地址																																																																														
	mpofs	chgr.addr			2	3						#	模块地址																																																																														
	mpofs	chgr.addr			3	4						#	模块地址																																																																														
	mpofs	chgr.addr			4	5						#	模块地址																																																																														
	mpofs	chgr.addr			5	6						#	模块地址																																																																														
	mpofs	chgr.addr			6	7						#	模块地址																																																																														
	mpofs	chgr.addr			7	8						#	模块地址	
	######################单双	
	mp	a.chgr.PerGunNum		4							#	A枪占用模块数量																																								
	mp	b.chgr.PerGunNum		0							#	B枪占用模块数量																																								
	mpofs	a.chgr.GunAddr		0	1							#	A枪模块地址寄存器																																								
	mpofs	a.chgr.GunAddr		1	2							#	A枪模块地址寄存器																																							
	mpofs	a.chgr.GunAddr		2	3							#	A枪模块地址寄存器
	mpofs	a.chgr.GunAddr		3	4							#	A枪模块地址寄存器
	#mpofs	b.chgr.GunAddr		0	3							#	B枪模块地址寄存器																																								
	#mpofs	b.chgr.GunAddr		1	4							#	B枪模块地址寄存器																																																																																												
	mp	center.chgrPerPile		4							#	每个桩4个充电模块	
	######################
	mp	center.maxOutV			5000						#	单模块																																																																														
	mp	center.ratedOutV		5000						#	单模块																																																																														
	mp	center.minOutV			3000						#	单模块																																																																														
	mp	center.maxOutC			300							#	单模块																																																																														
	mp	center.ratedOutC		300							#	单模块																																																																														
	mp	center.minOutC			100							#	单模块																																																																														
	mp	center.chgStatus		0							#	充电状态初始值，0:单枪并机,1:单枪单机,2:双枪切换																																																																														
	mp	a.center.chgStatus		0							#	充电状态初始值，0:单枪并机,1:单枪单机,2:双枪切换
	mp	b.center.chgStatus		0							#	充电状态初始值，0:单枪并机,1:单枪单机,2:双枪切换
	mp	center.chargeType		0							#	充电方式:0.单枪并机,1:单枪单机,2:双枪切换																																																																														
	mp	center.slowCharge		1							#	是否慢充																																																																														
	mp	center.alarmStatus		0							#	报警状态																																																																														
	mp	acb.restoreErrorCnt		0						#	待机检测到错误恢复次数 0-电子锁 1-输出继电器 2-辅助电源																																																																																
	mp	center.ledTipCount		0																																																																																								
	mp	center.printfCnt	0																																																																																										
	mp	center.isAsistV24	0								# 默认12V																																																																																									
	mp	center.mpFanStartTemper	500						# 默认50摄氏度
	#设置分时电量电价和电价模式																																																																																										
	mpofs	center.price		0		100000				#	尖100000																																																																																	
	mpofs	center.price		1		100000				#	峰100000																																																																																	
	mpofs	center.price		2		100000				#	平100000																																																																																	
	mpofs	center.price		3		100000				#	谷100000																																																																																	
	mpofs	center.price		4		1					#	2:接入电表																																																																														
																																																																																											
	#初始化显示灯的状态																																																																																										
	mp	io.LEDOFF_1				0							#	设置开出1,充电,黄灯																																																																																				
	mp	io.LEDOFF_2				0							#	设置开出2,电源,绿灯																																																																																				
	mp	io.LEDOFF_3				0							#	设置开出3,故障,红灯																																																																																				
	mp	io.LEDOFF_4				0							#	设置开出4,充电,黄灯																																																																																
	mp		acb.ledTipCount		0							#	LED灯闪烁计数																																																																																				
																																																																																											
	statemp		chgr.state			idle	0																																																																																				
	statemp		center.state		idle	0																																																																																				
	statemp		bms.mpkg-state		idle	0																																																																																				
	statemp		acb.state			idle	0																																																																																				
	statemp		chgr.state			idle	0																																																																																				

	mp	center.bms_version			0							#	bms版本																																																																														
	mp	bms.enable	1											#	充电机允许充电 暂时未进行逻辑判断
																																																																																											
	statemp		acb.state-check			wait-init			500			#	启动初始化线程的定时器																																																																														
																																																																																											
	mp	center.gunLinkCarOK			0												#	设置连接状态为0	未连枪																																																																														
	mp	center.infflg	0																																																																																									
#	state	standby		1000								#	主控状态初始化																																																																														
#	state	config		1000		#test						#	主控状态初始化																																																																														
#	state	testAcb		0	#test							#	检查状态初始化																																																																														
#	state	idle	0		#test							#	检查状态初始化																																																																														
#	statemp		center.staChk	check	0							#	检查状态初始化																																																																														
#	statemp		center.staChk		testAcbSend		0					#	检查状态初始化																																																																														
#	statemp		center.staChk		testChgrSend		0					#	检查状态初始化																																																																														
#	statemp		bms.mpkg-state			mpkg-standby		0				#	多包状态初始化																																																																														
#	statemp		bms.mpkg-stTmo			mpkg-timeout		0				#	多包超时状态初始化																																																																														
#	statemp		pile.pile-state			pile-standby		0				#	多桩状态初始化																																																																														
#	statemp		pile.pile-tmo-pcs			pile-pcs-check			10000			#	多桩状态初始化--pcs检查																																																																														
#	statemp		pile.pile-tmo-pcs-send				pile-pcs-send		2000			#	多桩状态初始化--pcs发送																																																																														
#	mp	pile.pile-tmo-pcs-send				state	pile-pcs-send					#	设置pcs发送当前状态																																																																														
#	state	idle		0			#	1000				#	检查状态初始化																																																																														
#	statemp		center.staChk		testPile		0					#	立即运行一次timer																																																																														
#	statemp		center.staChk		testAcbSend		50					#	立即运行一次timer																																																																														
#	statemp		pile.pile-state			testAcb		0				#	多桩状态初始化																																																																														
#	state	testAcb		0		#接收FCF																																																																																					
																																																																																											
	lock	center.version			#添加版本信息																																																																																					
	add	mp	center.version		1	#版本个数增加一个																																																																																					
	mpofs	center.version		mp	center.version		strc	"script version:611-QML V1.0 2017-02-03 2815"																																																																																			
	unlock	center.version																																																																																									
																																																																																											
	mpdt	center.cardPassword	0	16	0																																																																																				
	mpdt	card.usrpwd		0	1	0x31																																																																																					
	mpdt	card.usrpwd		1	1	0x45																																																																																					
	mpdt	card.usrpwd		2	1	0x95																																																																																					
																																																																																											
	var	b	concat	%X	mpdt	card.usrpwd		0	1	\																																																																																	
					mpdt	card.usrpwd		1	1	\																																																																																	
					mpdt	card.usrpwd		2	1																																																																																		
																																																																																											
	var	c	strc	var	b																																																																																						
	mpdt	center.cardPassword			5	-6	vardt	ptr	c	0	6																																																																																
[state]	wait-init	等待初始化									#																																																																															
																																																																																											
	if	mp	acb.ledTipCount			>=	6																																																																																				
		call	begin-init	
		#mp	acb.ledTipCount	0	
		return																																																																																									
	endif																																																																																										
																																																																																											
	if	(	mp	acb.ledTipCount		%	2	)	=	0																																																																																	
			mp	io.LEDON_1	0
			mp	io.LEDON_2	0	
			mp	io.LEDON_3	0
			mp	io.LEDON_4	0	
	else																																																																																										
			mp	io.LEDOFF_1	0
			mp	io.LEDOFF_2	0	
			mp	io.LEDOFF_3	0
			mp	io.LEDOFF_4	0	
	endif																																																																																										
																																																																																											
	add	mp	acb.ledTipCount			1																																																																																					
																																																																																											
[state]	begin-init	开始初始化										#																																																																															
	log	"开始初始化="	gun
	if	gun	=	0
		call		db-init																																																																																								
	endif
	
	var	chgrNum	0														#充电模块数量																																																																																								
	var	i	mp	center.chgrPerPile			*	mp	center.curPile		#此处可以改为枪对应模块数量 默认一个枪配两个模块																																																																																	
	var	num	0																																																																																								
	do	while	var	num	<	mp	center.chgrPerPile																																																																																				
		if	(	mpofs	chgr.addr		var	i	+	var	num	)	!=	0																																																																													
			add	var	chgrNum	1																																																																																					
		endif																																																																																									
		add	var	num	1																																																																																						
	loop	
#	log	"chgrNum="	var	chgrNum	"center.chgrPerPile="	mp	center.chgrPerPile
	#if	var	chgrNum	!=	mp	center.chgrPerPile																																																																																					
	#	var	num	0																																																																																							
	#	var	newAddr	var	chgrNum	*	mp	center.curPile																																																																																			
	#	mp	center.chargeType			1																																																																																					
	#	do	while	var	num	<	mp	center.chgrPerPile																																																																																			
	#																																																																																										
	#		if	mpofs	chgr.addr	var	i	!=	0																																																																																	
	#			mpofs	chgr.addr	var	newAddr	mpofs	chgr.addr	var	i																																																																														
	#			add	var	newAddr	1																																																																																				
	#		endif																																																																																								
	#		add	var	num	1																																																																																					
	#		add	var	i	1																																																																																					
	#	loop																																																																																									
	#	mp	center.chgrPerPile	var	chgrNum																																																																																				
	#endif																																																																																										

	mpc	chgr.getIdx		mini								#	重置idx用到的缓冲区																																																																														
	mpc	acb.getIdx		mini								#	重置idx用到的缓冲区																																																																														
																																																																																											
	statemp		acb.state-check			idle			0	#	复位定时器																																																																														
	
	#	设置开出2,电源,绿灯																																																																																											
	mp	io.LEDON_3	0
	call		acb-init									#	调用acb初始化流程																																																																														
	call		chgr-init									#	调用charger的初始化流程																																																																														
	call		bms-init																																																																																								
	call		bgm-init																																																																																								
[state]	bms-init	bms流程初始化									#																																																																															
#	log	"bms流程初始化="	gun

#	常量初始化-bms																																																																																										
	const	bms-tmo				5000		#	超时时间																																																																																				
	const	bms-bro-tmo			60000		#	超时时间																																																																																				
	const	bms-send			250			#	定时发送周期																																																																																				
	const	bms-chgtmo			1000		#	充电时,超时时间																																																																																				
	const	bms-chgsend			50			#	充电时,定时发送周期																																																																																				
	const	bms-stopsend		20			#	结束充电时,定时发送周期																																																																																				
																																																																																												
	const	bms-11-tmo			5000		#	超时时间																																																																																				
	const	bms-11-bro-tmo		60000		#	超时时间																																																																																				
	const	bms-11-send			250			#	定时发送周期																																																																																				
	const	bms-11-chgtmo		1000		#	充电时,超时时间																																																																																				
	const	bms-11-chgsend		50			#	充电时,定时发送周期																																																																																				
	const	bms-11-stopsend		20			#	结束充电时,定时发送周期																																																																																				
#	常量初始化-bms mpkg,多包																																																																																										
	const	mpkg-tmo			1250		#	超时时间																																																																																				
	const	mpkg-recv-RTS		1			#	多包接收的内容																																																																																				
	const	mpkg-recv-CTS		2																																																																																							
	const	mpkg-recv-DT		3			#	data																																																																																				
	const	mpkg-recv-End		4																																																																																							
	const	mpkg-recv-Abort		5																																																																																						
																																																																																											
#	设置过滤	acb.frontIn为要控fd上的任一测点名		can_id	mask	…	要求can_id & mask==can_id																																																																																				
	filter	bms.mpkg-status							\	fd上任一测点名																																																																																	
		0x5600	0xFF00						#	目的地址		mask																																																																															
#	初始化测点																																																																																										
	mp	bms.BST	0																																																																																								
#	初始化状态																																																																																										
	state		bms-standby		1000							#	主控状态初始化																																																																														
	statemp		bms.mpkg-state	mpkg-standby	0				#	多包状态初始化																																																																														
	statemp		bms.mpkg-stTmo	mpkg-timeout	0				#	多包超时状态初始化																																																																														
																																																																																										
[state]	acb-init	acb初始化流程																																																																																								
#tag	command																																																																																										
																																																																																											
#	采集板测点初始化																																																																																										
#	采集板开入、开出端子掩码																																																																																										
#	log	"acb初始化="	gun
																																																																																											
	mpofs	a.acb.linkOK			0	0x03	#	基值：acb.frontCmpr		#	mask，A枪连接确认状态，11：连接成功，00：未连接，10：连接中																																																																														
	mpofs	b.acb.linkOK			0	0x0C	#	基值：acb.frontCmpr		#	mask，B枪连接确认状态，11：连接成功，00：未连接，10：连接中																																																																														
	mp	acb.batVoltDirect			0x40	#	基值：acb.frontCmpr		#	mask，电池电压反接为1,正接为0																																																																														
	mp	acb.batteryV				0x10	#	基值：acb.frontCmpr		#	mask，是否检测到电池电压，1：有，0：无																																																																														
	mp	acb.accPowerV				0x20	#	基值：acb.frontCmpr		#	mask，BMS是否有供电（辅助电源电压是否需要投入），1：有，0：无																																																																														
																																																																														
	mpofs	a.acb.outSwitch		0	0x10	#	基值：acb.frontIn		#	mask，直流输出开关1状态，1：闭合，0：断开，连枪																																																																														
	mpofs	b.acb.outSwitch		0	0x20	#	基值：acb.frontIn		#	mask，直流输出开关2状态，1：闭合，0：断开，连枪																																																																														
	mpofs	acb.commSwitch		0	0x04	#	基值：acb.frontIn		#	mask，桩间联络开关，1：闭合，0：断开																																																																														
	mpofs	acb.outSwitch-O		0	0x01	#	基值：acb.frontOut			#	mask，直流输出开关1控制，1：闭合，0：断开，连枪		由于AB枪共用一套CC601 故开出必须使用同一个acb下的frontOut																																																																												
	mpofs	acb.outSwitch-O		1	0x02	#	基值：acb.frontOut			#	mask，直流输出开关2控制，1：闭合，0：断开，连枪																																																																															
	mpofs	acb.commSwitch-O	0	0x04	#	基值：acb.frontOut		#	mask，母联控制，1：闭合，0：断开																																																																														
	mpofs	acb.accPowerOn-O	0	0x08	#	基值：acb.frontOut		#	mask，辅助电压继电器1合																																																																														
	mpofs	acb.accPowerOn-O	1	0x10	#	基值：acb.frontOut		#	mask，辅助电压继电器2合			
	lock		a.acb.frontOut																																																																																														
	and	mpofs	a.acb.frontOut	0	0x01																																																																																
	mp	a.acb.CCO		mp	center.curPile																																																																																												
	unlock		a.acb.frontOut		
	mpofs	acb.gunLock			0	0x01	#	基值：acb.backIn		#	mask，充电枪电磁锁1动作，1：上锁，0：未上锁																																																																														
	mp	acb.accCheck				0x04	#	基值：acb.frontIn		#	mask，辅助电源电压检测切换动作，1：已切换，0：未切换																																																																														
	mp	acb.emergency				0x01	#	基值：acb.frontIn		#	mask，急停信号，1：急停动作，0：未动作																																																																														
	mp	acb.arrester				0x02	#	基值：acb.frontIn		#	mask，避雷器动作，1：有报警，0：正常																																																																														
	mp	acb.leakLoop				0x01	#	基值：acb.backOut		#	mask，泄放回路控制																																																																														
	mp	acb.FanOut				0x08	#	基值：acb.backOut		#	mask，风扇控制																																																																														
	mp	acb.AsistVSwitch			0x04	#	基值：acb.backOut		#	mask，辅助电源控制																																																																														
	mpofs	acb.gunLock-O		0	0x02	#	基值：acb.backOut		#	mask，充电枪电磁锁控制	00000010																																																																													
	mp	acb.insultCheck				0x10	#	基值：acb.backOut		#	mask，绝缘检测控制(第5个bit) 控制CJ601接地臂接入																																																																														
	mp	acb.kwhCount			0			#	统计当前充电电量																																																																																			
	mp	acb.moneyCount			0			#	统计当前充电金额																																																																																			
	mp	acb.checkCount			3			#	检查后端采集板上传地址的计数																																																																																			
	mp	center.mpGunTemperUpper	650		#	枪温度上限																																																																																									
	mpofs	acb.accPowerV		0	0x20	#	基值：acb.frontCmpr		#	mask，BMS是否有供电（辅助电源电压是否需要投入），1：有，0：无																																																																														
	mpofs	acb.accPowerV		1	0x01	#	基值：acb.frontCmpr-b	#	mask，b枪BMS是否有供电（辅助电源电压是否需要投入），1：有，0：无																																																																														
	mpofs	acb.batteryV-neg	0	0x40	#	基值：acb.frontCmpr		#	mask，电池电压是否反向																																																																														
	mpofs	acb.batteryV-neg	1	0x02	#	基值：acb.frontCmpr-b	#	mask，电池电压是否反向																																																																														
																																																																																									
	mp	acb.accCheck				0x04	#	基值：acb.frontIn		#	mask，辅助电源电压检测切换动作，1：已切换，0：未切换																																																																														
																																																																																										
	mp	acb.accCheck-O				0x40	#	基值：acb.frontOut		#	mask，辅助电源电压检测切换控制																																																																														
	mpofs	acb.linkGunState	0	0x01	#																																																																																				
	mpofs	acb.linkGunState	1	0x04	#																																																																																				
#	mpofs	acb.gunLock			1	0x02	#	基值：acb.backIn		#	mask，充电枪电磁锁2动作，1：上锁，0：未上锁																																																																														
#	mpofs	acb.gunBack			0	0x10	#	基值：acb.frontIn		#	mask，充电枪头归位信号1（枪是否插回桩）1：归位，0：未归位																																																																														
#	mpofs	acb.gunBack			1	0x20	#	基值：acb.frontIn		#	mask，充电枪头归位信号2（枪是否插回桩）1：归位，0：未归位																																																																														
#	mpofs	acb.gunLock-O		1	0x02	#	基值：acb.frontOut		#	mask，充电枪电磁锁2控制																																																																														
#	mpofs	acb.batUOn-O		0	0x10	#	基值：acb.frontOut		#	mask，电池电压1投入																																																																														
#	mpofs	acb.batUOn-O		1	0x20	#	基值：acb.frontOut		#	mask，电池电压2投入																																																																														
#	mpofs	acb.commSwitch		1	0x04	#	基值：acb.backIn		#	mask，桩间联络开关，1：闭合，0：断开																																																																														
#	mp	acb.inSwitch				0x10	#	基值：acb.backIn		#	mask，交流输入开关状态，1：闭合，0：断开																																																																														
#	mp	acb.inSwitchTrip			0x20	#	基值：acb.backIn		#	mask，交流输入开关脱扣状态，1：闭合，0：断开																																																																														
#	mpofs	acb.commSwitch-O	1	0x04	#	基值：acb.backOut		#	mask，桩间联络开关2控制，1：闭合，1：断开																																																																														
																																																																																										
#	常量初始化-acb																																																																																										
	const	acb-double-gun			2		#	充电模式为2表示双枪																																																																																			
	const	acb-min-money			500		#	卡内最小余额																																																																																			
	const	acb-insulation-fail		2		#	2.启动中,绝缘检测失败																																																																																			
	const	acb-fill-OK				16		#	BMS充满时的停止原因																																																																																			
	const	acb-bms-error			15		#	BMS异常停机																																																																																			
	const	acb-bms-timeout			24		#	24.BMS通信中断或超时																																																																																			
	const	acb-U-top				105		#	电压上限:额定电压的105%																																																																																			
	const	acb-I-top				105		#	电流上限:额定电流的105%																																																																																																																																																																						
	const	acb-timeout				20		#	次,1秒/次,acb通讯检查时的超时时间																																																																																			
	const	acb-card-stop			13		#	刷卡停机																																																																																			
	const	acb-app-stop			27		#	app停机																																																																																			
																																																																																											
#	设置过滤	acb.frontIn为要控fd上的任一测点名		can_id	mask	…	要求can_id & mask==can_id																																																																																				
#	filter	acb.state							\	fd上任一测点名																																																																																	
#		(	mpofs	center.addr		mp	center.curPile		)	<<	8	\	当前桩地址																																																																														
#			0xFF00				\						mask																																																																														
#		0xFF00	0xFF00						#	广播地址		mask																																																																															
																																																																																											
	#	初始化状态节点																																																																																									
	statemp		acb.state-check			acbc-check-alarm			-2000			#	定时报警检查流程																																																																														
	call	acbc-standby-init										#	初始化standby状态																																																																														
																																																																																											
	mpc	io.WdtEnable			1			#设置看门口使能模式:1-使能,0-不使能																																																																																			
	mpc	io.WdtSetTimeOut		60			#设置看门狗超时时间,必须先使能,再设超时时间,否则超时时间无效																																																																																			
	mpc	io.WdtFeed				1			#喂狗																																																																																			
[state]	bgm-init	后台网络通讯初始化流程																																																																																								
	#log	"后台网络通讯初始化流程="	gun
	if	gun	=	1
		return
	endif
	const	upload-period-long			200		#定时上送周期-长周期:0.4秒一次				300*0.2	=	60	1分钟																																																																													
	const	upload-period-short			100		#定时上送周期-短周期:0.1秒一次				300*0.1	=	30	30秒																																																																													
	const	upload-period-wait			300		#定时上传的等待周期																																																																																				
	const	upload-yx-count				15		#遥信定时上传，遥测一分钟一次，遥信15分钟一次																																																																																				

	const	link-check-timeout			3		#定时检测链路的超时次数																																																																																				
	const	link-reset-timeout			12		#中断时,定时复位socket的次数																																																																																				
	const	link-wait-timeout			6		#防止网络测试帧发送太频繁的等待次数																																																																																				
																																																																																											
	#tcp连接常量																																																																																										
	const	FDTSK_NEWCN		0	#new connection																																																																																						
	const	FDTSK_TIMER		-1	#timer																																																																																						
	const	FDTSK_DISCN		-2	#disconnected																																																																																						
	const	FDTSK_PARM		-3	#set fd parm																																																																																						
																																																																																											
	#bgm status																																																																																										
	const	BGM_INIT		0																																																																																							
	const	BGM_AUTH_ING		1	#bgm鉴权																																																																																						
	const	BGM_WAIT_START		2	#bgm启动																																																																																						
	const	BGM_WAIT_STOP		3	#bgm停机																																																																																						
	const	BGM_CARD_ING		4	#bgm刷卡																																																																																						
																																																																																											
#	mpofs	center.pileNo			0	0x00000001		#桩号,BCD,[0x00000001,0x37401000]表示:3740100000000001																																																																																			
#	mpofs	center.pileNo			1	0x37401000																																																																																					
#	mp	center.station				0x01				#站号,BCD,两个字节																																																																																			
	mp	center.pileType			2																																																																																						
	mp	bgm.isConnected			0				#初始化网络连接标志为0																																																																																			
	mp	bgm.linkCount			0																																																																																						
	mp	bgm.sendFailStatus	0																																																																																																					
	mp	bgm.linkCarState	0
	mp	bgm.sendChgStatus	0																																																																																																					
	mp	center.servicePrice	mp	bgm.servicePrice
	#设置tcpcli的fd参数,重新设置IP和端口后重新连接																																																																																										
	var	len	const	FDTSK_PARM																																																																																							
	var	server-ip		mp	bgm.IP			#ip1~4	
	log	"IP="	var	server-ip
	var	server-port		mp	bgm.Port		#port																																																																																				
	bufwr	bgm.state		addr	len																																																																																						

	statemp		a.bgm.state		bgm-ptc-start			mini			#启动后默认状态为bgm-ptc-start																																																																																		
	statemp		a.bgm.tmoSend	bgm-ptc-start-send	1000			#每1s发送		为了调试可以设的小一点																																																																															
	statemp		a.bgm.tmo		idle			0																																																																																			
	statemp		a.bgm.tmoCheck	bgm-tcp-check		5000			#每5s检查一次,还要乘以bgm.linkWaitCount的倍数

	statemp		b.bgm.state		bgm-ptc-start	mini		#启动后默认状态为bgm-ptc-start																																																																																		
	statemp		b.bgm.tmoSend	idle			0		#每2s发送		为了调试可以设的小一点																																																																															
	statemp		b.bgm.tmo		idle			0																																																																																			
	statemp		b.bgm.tmoCheck	idle			0		#每5s检查一次,还要乘以bgm.linkWaitCount的倍数																																																																																	

[state]	init-setup	初始化--需要工程人员修改的设置				#																								
#tag	command						#																								
#	初始化测点																														
	#log	"初始化--需要工程人员修改的设置="	gun
	mp	center.pileNum			1		#	桩数																							
	mp	center.maxPileNum		0		#	最大并桩数																							
																															
#	if	gun	=	0																											
#		mpofs	center.pileNo			0	0x00000001		#桩号,BCD,[0x00000001,0x37401000]表示:3740100000000001																						
#		mpofs	center.pileNo			1	0x00000000																								
#	else																														
#		mpofs	center.pileNo			0	0x00000002		#桩号,BCD,[0x00000001,0x37401000]表示:3740100000000001																						
#		mpofs	center.pileNo			1	0x00000000																								
#	endif																														
																															
	if	gun	=	0																											
		var	a	0h3740100000000001							#	0h3740100000000001																			
		mpofs	center.pileNo		1	vardt	ptr	a	3	-4	#桩号,BCD,[0x00000001,0x37401000]表示:3740100000000001						0x00005783														
		mpofs	center.pileNo		0	vardt	ptr	a	7	-4	#						0x42010100														
	else																														
		var	a	0h3740100000000001							#	0h3740100000000001																			
		mpofs	center.pileNo		1	vardt	ptr	a	3	-4	#桩号,BCD,[0x00000001,0x37401000]表示:3740100000000001						0x00005783														
		mpofs	center.pileNo		0	vardt	ptr	a	7	-4	#						0x42010100														
	endif																														
																															
	mp	center.station			0x01			#站号,BCD,两个字节																							
																															
	mp	center.isBgm			1																										
																																																																																																														
#tag	command																																																																																																																																																																						
#	1.bgm收到app鉴权,会将状态置为st_lock状态																																																																																																											
#	2.ui判断,a.可充电,置为st_passed，锁抢后,收到app的启动帧. b.不可充电,置状态为st_standby状态,bgm会返回鉴权失败.																																																																																																											
#	3.bgm收到app的启动帧,置bgm.start为1																																																																																																											
#	4.ui检查到bgm.start为1,则将状态置为st_config, 如果取消充电,则置状态为st_standby状态																																																																																																											
#	6.ui检查到st_check调到结账界面,结账完成置为st_checked状态.																																																																																																											
[state]	db-init		数据库控制初始化																																																																																									
#tag	command									#																																																																																		
	state	idle	0																																																																																									
	log	"数据库初始化="	gun																																																																																											
	#DB常量																																																																																											
	const	SQLITE_INTEGER		1																																																																																								
	const	SQLITE_FLOAT		2																																																																																								
	const	SQLITE_TEXT		3																																																																																								
	const	SQLITE_BLOB		4																																																																																								
	const	SQLITE_BIGINT		101																																																																																								
	mp	db.open	"rdb.dat"																																																																																									

	#取费率条数
	var	sql	0	#只是为分配空间，prep会用到																																																																																							
	var	len	0																																																																																								

	var	sql	concat	"select * from ChargeData"				#where sys_name = 'iRateNum'																																																																																										
	log	"sql="	str	sql																																																																																																						
																																																																																																										
	var	a	mpc	db.prep		addr	sql		
	if	var	a	=	0																																																																																																						
		log	"查询失败!"																																																																																																								
	else																																																																																																										
		log	"查询成功!"																																																																																																								
	endif																																																																																																										

	var	r	ptr	a	+	1	#结果集的行数,包括字段名称一行,所以+1																		
	var	c	varofs	ptr	a	1	#结果集的列数																		
	log	"db.prep row="		var	r	-	1	",col="	var	c															
	var	i	0		#行计数																				
	var	h	0		#总计数	
	var	j	0		#费率字符串处理
	var	l	0
	var	service	0
	var	ratio	1
	var	pc	varofs	ptr	a	2	#char**,指向结果集																		
	do	while	var	i	<	var	r		#每行,循环输出字段																
		var	k	0	#列计数																				
		do	while	var	k	<	var	c	#每列																
			var	p	varofs	ptr	pc	var	h	#p:char*,结果集第h个元素,指向某一个字段名或值															
			var	t	varofs	ptr	pc	var	k	#字段类型															
		#	log	var	p	","	var	t																	
			if	var	h	<	var	c	|	#第一行，列类型															
				var	t	=	const	SQLITE_INTEGER																	
				log	"data["	var	i	","	var	k	"]="	\													
					var	p		#列类型，整数，int p																	
				elseif	var	t	=	const	SQLITE_TEXT		|									
					var	t	=	const	SQLITE_FLOAT											
					log	"data-t["		var	i	","	var	k	"]="	\							
						chr	p
					if	(	var	i	=	5	)	&&	(	var	k	=	1	)	#费率
						if	vardt	chr	p	1	1	=	0						
							mpofs	center.rateNum	0	(	(	(	vardt	chr	p	0	1	)	-	0x30	)	)
						else
							mpofs	center.rateNum	0	(	(	(	(	vardt	chr	p	0	1	)	-	0x30	)	*	10	)	+	(	(	vardt	chr	p	1	1	)	-	0x30	)	)
						endif
						if	(	mpofs	center.rateNum	0	)	>	10	||	(	mpofs	center.rateNum	0	)	<	0#最大费率条目
							mpofs	center.rateNum	0	10
						endif
						#log	"费率条目数="	%d	(	mpofs	center.rateNum	0	)
					elseif	(	var	i	=	4	)	&&	(	var	k	=	1	)	#服务费
						do	while	var	j	<	10	
							if	(	(	vardt	chr	p	var	j	1	)	!=	0	)
								mul	var	ratio	10	
							else	
								break	
							endif	
							add	var	j	1
						loop
						div	var	ratio	10	
						sub	var	j	1
						#log	"test="	var	ratio	"j="	var	j	
						do	while	var	j	>=	0
							var	service	(	(	(	(	vardt	chr	p	var	l	1	)	-	0x30	)	*	var	ratio	)	+	var	service	)
							div	var	ratio	10
							sub	var	j	1
							add	var	l	1
						loop
						mp	center.servicePrice	var	service
						log	"服务费率="	mp	center.servicePrice
					endif
				elseif	var	t	=	const	SQLITE_BIGINT										
					log	"data-l["		var	i	","	var	k	"]=0x"	\							
						%08x	varofs	ptr	p	1	ptr	p										
				endif	#else SQLITE_NULL														
				add	var	k	1	#列加1															
				add	var	h	1	#当前索引加1													
	
		loop																																					
		add	var	i	1		#行加1																																
	loop
	
	call	db-get-current-priceModel				#获取当前计费模型
	
[state]	db-get-current-priceModel					#获取当前计费模型						#	
	var	sql	0	#只是为分配空间，prep会用到																																																																																							
	var	len	0																																																																																								
	var	a	mpc	db.query		"select * from time_rate where 1=2"																																																																																					
	if	var	a	=	0	#查询失败，说明无此表
		log	"ERROR No time_rate!!!"
	else																																																																																										
		var	sql	"select *  from time_rate"																																																																																							
		var	a	mpc	db.prep		addr	sql																																																																																				
		#a保存一个内存地址,指向某区域,此区域:int[]{row,col,data},char** data,data为返回结果集,按类型返回不同的结构																																																																																										
		var	r	ptr	a	+	1	#结果集的行数,包括字段类型一行,所以+1																																																																																				
		var	c	varofs	ptr	a	1	#结果集的列数																																																																																				
		log	"db.prep row="		var	r	-	1	",col="	var	c																																																																																	
																																																																																												
		var	i	0		#行计数																																																																																						
		var	h	0		#总计数																																																																																						
		var	pc	varofs	ptr	a	2	#char**,指向结果集																																																																																				
	
		#取出数据表 分别与定义的脚本定义的时间及费率匹配
		#mp	center.rateNum	var	r			#费率数量
		do	while	var	i	<	var	r		#每行,循环输出字段																														
			var	k	0	#列计数																																		
			do	while	var	k	<	var	c	#每列																														
				var	p	varofs	ptr	pc	var	h	#p:char*,结果集第h个元素,指向某一个字段名或值																													
				var	t	varofs	ptr	pc	var	k	#字段类型																													
			#	log	var	p	","	var	t																															
				if	var	h	<	var	c	|	#第一行，列类型																													
					var	t	=	const	SQLITE_INTEGER	
					log	"data["	var	i	","	var	k	"]="	\																											
						var	p		#列类型，整数，int p	
					if	var	i	>	0	
						if	var	k	=	1		#起始时间
							mpofs	center.rateTimeStart	(	var	i	-	1	)	var	p	
						elseif	var	k	=	2	#结束时间
							mpofs	center.rateTimeEnd	(	var	i	-	1	)	var	p	
						elseif	var	k	=	3	#费率
							mpofs	center.rate	(	var	i	-	1	)	var	p	
						endif
					endif
				endif																																				
				add	var	k	1	#列加1																																
				add	var	h	1	#当前索引加1																																
			loop																																					
			add	var	i	1		#行加1																																
		loop
	endif
[state]	bgm-tcp-check	检查网络相关操作，5秒																																																																																																								
	#log	"检查网络相关操作，5秒="	mp	bgm.isConnected
	if	mp	bgm.isConnected		=	1	#网络正常时启动																																																																																																					
		#检查网络连接状态		 																																																																																																								
		if	mp	bgm.linkCount		>=	const	link-check-timeout	#超时检查,如果长时间未收到链路检测的返回数据,就重连一次网络，6次																																																																																																	
			mp	bgm.isConnected			0																																																																																																					
			mp	bgm.linkCount			0																																																																																																					
																																																																																																												
			statemp		bgm.state		bgm-ptc-start		mini	#协议启动																																																																																																	
			statemp		bgm.tmoSend		bgm-ptc-start-send	-1000	#返回协议启动发送	#app鉴权的流程																																																																																													
																																																																																																												
			var	len	const	FDTSK_NEWCN																																																																																																						
			bufwr	bgm.state		addr	len																																																																																																					
																																																																																																												
		else																																																																																																										
			sub	mp	bgm.linkWaitCount			1																																																																																																				
																																																																																																												
			if	mp	bgm.linkWaitCount			<=	0																																																																																																			
				mp	bgm.linkWaitCount			const	link-wait-timeout	#2次检查失败，增加bgm.linkCount计数																																																																																																
					call	bgm-Frame-Heart									#网络正常时,定时检测链路																																																																																																		
				add	mp	bgm.linkCount			1							#增加通道检查计数																																																																																																		
			endif																																																																																																									
		endif																																																																																																										
																																																																																																												
		#waitCheckout:0,没有需要发送数据,或者数据已发送完成; 1-数据需要再次发送,发送函数将waitCheckout置为2,然后每次减1,直到1																																																																																																										
		#重复上传结账记录																																																																																																										
		if	(	mp	bgm.waitCheckout			>	0	)																																																																																																		
			&	(	mp	center.chgStatus			=	const	st-standby		)	#在待机状态																																																																																														
																																																																																																												
			if	mp	bgm.waitCheckout			=	1					#防止传的太频繁																																																																																														
				#log	"-------------- resend checkcout data !!!!! ------------------------------"																																																																																																							
				call	bgm-sendCheckout																																																																																																							
			elseif	mp	bgm.waitCheckout			>	1																																																																																																			
				sub	mp	bgm.waitCheckout			1																																																																																																			
			endif																																																																																																									
																																																																																																												
			sub	mp	bgm.waitCheckout			1		#防止反复上传																																																																																																		
		endif																																																																																																										
																																																																																																												
	endif																																																																																																											
																																																																																																												
	if	mp	bgm.isConnected		=	0	#如果长时间连接不成功,重新创建socket连接																																																																																																					
																																																																																																												
		add	mp	bgm.tryCount		1																																																																																																						
																																																																																																												
		if	mp	bgm.tryCount		>=	const	link-reset-timeout			#1分钟如果还未连上网络就强制重连一次																																																																																																	
																																																																																																												
			mp	bgm.linkCount			0																																																																																																					
																																																																																																												
			statemp		bgm.state		bgm-ptc-start		mini		#协议启动																																																																																																	
			statemp		bgm.tmoSend		bgm-ptc-start-send			-1000	#返回协议启动发送				#app鉴权的流程																																																																																													
																																																																																																												
			var	len	const	FDTSK_NEWCN																																																																																																						
			bufwr	bgm.state		addr	len																																																																																																					
																																																																																																												
			mp	bgm.tryCount			0																																																																																																					
																																																																																																												
		endif																																																																																																										
																																																																																																												
	else																																																																																																											
		mp	bgm.tryCount		0																																																																																																							
	endif																																																																																																											

#以下为测试部分
#	if	mp	center.chgStatus	=	const	st-standby
#		add	mp	center.infflg	1
#	endif
#	
#	if	mp	center.infflg	>	1
#		call	bms-init
#		mp	center.infflg	0
#		mp	center.chgStatus	const	st-configed
#	endif

	#if	mp	center.chgStatus	=	const	st-charge
	#	if	mpofs	acb.chgrTimeCount	0	>=	1	
	#		mp	center.chgStatus			const	st-stop
	#		#log	"1111111111111"
	#	endif
	#endif
	
[state]	bgm-ptc-start-send	协议启动发送																																																																																																								
	if	gun	=	1
		return
	endif
	
	#log	"协议启动发送="	gun
	#组帧
	#┌───────────┬────────┐
	#│帧起始域   │  0x55AA│	
	#├───────────┼────────┤	
	#│帧长度域   │  2字节 │	
	#├───────────┼────────┤	
	#│长度域取反 │  2字节 │	
	#├───────────┼────────┤	
	#│序列号域   │  1字节 │	
	#├───────────┼────────┤◆◆◆◆◆◆◆◆◆◆	
	#│数据对象   │  1字节 │					  │
	#├───────────┼────────┤					  │
	#│帧类型编码 │  1字节 │	脚本只组应用层	  │
	#├───────────┼────────┤					  │
	#│数据域     │  N字节 │					  │
	#├───────────┼────────┤◆◆◆◆◆◆◆◆◆◆	
	#│帧校验域   │  2字节 │	
	#├───────────┼────────┤	
	#│帧结束域   │  1字节 │	
	#└───────────┴────────┘	
	#登录认证
	#提前分配发送缓存																																																																																																											
	var	len	61	#发送数据长度																																																																																																								
	varsz	dt	61	#发送数据	
	
	vardt	dt	0	1	0x00						# 数据对象																																																																																																												
	vardt	dt	1	1	0x01						# 帧类型																																																																																																							
	# 桩编码
	vardt	dt	2	1	(	(	(	mpdt	a.center.pileNo	3	1	)	&	0xF0	)	>>	4	)	+	0x30
	vardt	dt	3	1	(	(	(	mpdt	a.center.pileNo	3	1	)	&	0x0F	)			)	+	0x30
	vardt	dt	4	1	(	(	(	mpdt	a.center.pileNo	2	1	)	&	0xF0	)	>>	4	)	+	0x30
	vardt	dt	5	1	(	(	(	mpdt	a.center.pileNo	2	1	)	&	0x0F	)			)	+	0x30
	vardt	dt	6	1	(	(	(	mpdt	a.center.pileNo	1	1	)	&	0xF0	)	>>	4	)	+	0x30
	vardt	dt	7	1	(	(	(	mpdt	a.center.pileNo	1	1	)	&	0x0F	)			)	+	0x30
	vardt	dt	8	1	(	(	(	mpdt	a.center.pileNo	0	1	)	&	0xF0	)	>>	4	)	+	0x30
	vardt	dt	9	1	(	(	(	mpdt	a.center.pileNo	0	1	)	&	0x0F	)			)	+	0x30

	vardt	dt	10	8	0							# 桩编码 补0																																																																																																			
	vardt	dt	18	16	0							# 序列号																																																																																																			
	vardt	dt	34	1	0							# 桩类型																																																																																																			
	vardt	dt	35	1	1							# 枪数量																																																																																																			
	vardt	dt	36	1	0x0E						# 协议版本																																																																																																			
	vardt	dt	37	1	0x0A						# 程序版本																																																																																																			
	vardt	dt	38	1	0x0B						# 程序版本																																																																																																			
	vardt	dt	39	1	0x0C						# 程序版本																																																																																																			
	vardt	dt	40	1	0x0D						# 程序版本																																																																																																			
	vardt	dt	41	12	0							# 程序版本																																																																																																			
	vardt	dt	53	4	0							# 程序版本																																																																																																			
	vardt	dt	57	4	0							# 程序版本																																																																																																				
	bufwr	bgm.state	addr	len				#bgm.state为fd上任一测点,写buf,val(int[n]):buflen,data0(前四字节),data1(次四字节),…
[state]	bgm-ptc-start	解析登录请求报文																																																																																																								
#	log	"解析登录请求报文="	mp		bgm.isConnected
	if	mp	bgm.isConnected		!=	0																																																																																																						
		mp	bgm.isConnected			0																																																																																																						
	endif																																																																																																											
																																																																																																												
	var	i	0	#请求登录报文

	#00 02 01  30 30 30 30 30 36 30 31 00 00 00 00 00 00 00 00 02 ED 23 21 13 07 06 12
	if	buflen	==	27		#本包长度够																																																																																																	
		if	bufdt	var	i	+	1	1	=	0x02																																																																																																				
			if	(	bufdt	var	i	+	2	1	=	0				)		#登录成功	
				call	bgm-data-start
				#statemp		bgm.state		bgm-data-start		0			#传输启动																																																																																																
				statemp		bgm.tmoSend		idle		0					#发送流程置idle																																																																																																
				
				var	set-y	(	bufdt	var	i	+	26	1	)	+	2000	#	年																																																																																														
				var	set-m		bufdt	var	i	+	25	1					#	月																																																																																														
				var	set-d	(	bufdt	var	i	+	24	1	)	&	0x1F	#	日																																																																																														
				var	set-H		bufdt	var	i	+	23	1					#	时																																																																																														
				var	set-M		bufdt	var	i	+	22	1					#	分																																																																																														
				var	set-S	(	bufdt	var	i	+	21	1	)				#	秒																																																																																								
				#log	"服务器时间="	var	set-y	"-"	var	set-m	"-"	var	set-d	" "	var	set-H	":"	var	set-M	":"	var	set-S																																																																																																						
				if	(	mp	center.chgStatus	=	const	st-standby			)																																																																																																
																																																																																																										
					shell	"date -s '"		var	set-y	"-"	var	set-m	"-"	var	set-d	" "	\																																																																																														
						var	set-H	":"	var	set-M	":"	var	set-S	"'"																																																																																															
					shell	"hwclock -w"																																																																																																									
				else																																																																																																											
					#log	" can not change time in standby status !!!"																																																																																																									
				endif																																																																																																											

			endif																																																																																																								
		endif																																																																																																									
	endif																																																																																																										
[state]	bgm-data-start	传输启动																																																																																																								
	#log	"传输启动="	mp		bgm.isConnected
																																																																																																												
	if	buflen	=	const	FDTSK_NEWCN		#重新连接																																																																																																					
		statemp		bgm.state		bgm-ptc-start			mini	#返回协议启动																																																																																																		
		statemp		bgm.tmoSend		bgm-ptc-start-send			-1000	#返回协议启动发送																																																																																																		
		return																																																																																																										
	endif																																																																																																											
																																																																																																												
	if	(	buflen	=	const	FDTSK_DISCN		)		#连接中断																																																																																																		
		statemp		bgm.state		bgm-ptc-start		mini		#协议启动																																																																																																		
		statemp		bgm.tmoSend		bgm-ptc-start-send			-1000	#返回协议启动发送				#app鉴权的流程																																																																																														
		return												#1.bgm设置成锁桩状态																																																																																														
	endif													#2.ui检测后变成密码验证状态																																																																																														
																																																																																																												
	#var	i	0	#循环计数																																																																																																								
	#var	k	0	#数据包长度,即第二个字节																																																																																																								
	#var	len	0	#发送数据长度																																																																																																								
	#varsz	dt	2	#发送数据																																																																																																								
																																																																																																												
	if	(	mp		bgm.isConnected			=	0	)																																																																																												
		mp		bgm.isConnected				1				#握手成功,置连接成功标志位																																																																																											
		mp		bgm.needFindHisFlag				1																																																																																															
		statemp		bgm.state		bgm-data-recv		-1000				#数据接收																																																																																											
		statemp		bgm.tmoSend		bgm-upload		const	upload-period-long			#定时上传时间为0.1分钟*50																																																																																											
																																																																																																							
	#	call		bgm-ask-billing-model								#请求下发计费模型																																																																																											
	endif																																																																																																						
[state]	bgm-data-recv	数据接收																																																																																																								
	#log	"数据接收="	buflen
	#log	"桩状态="	mp	center.chgStatus																																																																																																											
	if	buflen	=	const	FDTSK_NEWCN		#重新连接																																																																																																					
		log		"新连接"																																																																																																								
		statemp		bgm.state		bgm-ptc-start			mini	#返回协议启动																																																																																																		
		statemp		bgm.tmoSend		bgm-ptc-start-send			-1000	#返回协议启动发送																																																																																																		
		return																																																																																																										
	endif																																																																																																											
																																																																																																												
	if	(	buflen	=	const	FDTSK_DISCN		)		#连接中断																																																																																																		
		|	(	mp	bgm.isConnected			=	0	)	#检查到中断																																																																																																	
		log		"连接中断"																																																																																																								
		statemp		bgm.state		bgm-ptc-start		mini		#协议启动																																																																																																		
		statemp		bgm.tmoSend		bgm-ptc-start-send			-1000	#返回协议启动发送				#app鉴权的流程																																																																																														
		return												#1.bgm设置成锁桩状态																																																																																														
	endif													#2.ui检测后变成密码验证状态																																																																																														
																																																																																																												
	if	(	buflen	=	const	FDTSK_TIMER		)		#定时器																																																																																																		
		call	bgm-tmr-inConnection					# 1秒1次																																																																																																							
	endif																																																																																																											
																																																																																																												
	if	(	buflen	<=	0	)								#没有收到数据就不必处理																																																																																														
		return																																																																																																										
	endif																																																																																																											
																																																																																																												
																																																																																																												
	var	FrameHead	bufdt	1	1	#帧头																																																																																																	
		
	var	i	0
	var	k	0
	if	var	FrameHead	=	0x04					#响应心跳																																																																																															
		call	bgm-Unpack-heart																																																																																																						
	elseif	var	FrameHead	=	0x06				#计费模型																																																																																																
		call	bgm-Unpack-price																																																																																																					
	elseif	var	FrameHead	=	0x12				#充电枪实时数据读取																																																																																																
		call	bgm-Pack-realGunData																																																																																																					
	elseif	var	FrameHead	=	0x14				#充电桩故障实时数据读取																																																																																																
		call	bgm-Pack-AlarmData																																																																																																					
	elseif	var	FrameHead	=	0x16				#整流模块实时数据读取																																																																																																
		call	bgm-Pack-ModAlarmData																																																																																																					
	elseif	var	FrameHead	=	0x44				#平台启机																																																																																																
		call	bgm-app-start																																																																																																					
	elseif	var	FrameHead	=	0x46				#平台停机																																																																																																
		call	bgm-app-stop																																																																																																					
	elseif	var	FrameHead	=	0x48				#账单确认																																																																																																
		call	bgm-Unpack-checkAck																																																																																																					
	elseif	var	FrameHead	=	0x74				#计费模型设置																																																																																																
		call	bgm-Unpack-price																																																																																																					
	elseif	var	FrameHead	=	0x76				#对时设置																																																																																																
		func	bgm-sync-time			var	i	
	elseif	var	FrameHead	=	0x78				#远程命令																																																																																																
		call	bgm-Unpack-RemoteCmd																																																																																																					
	endif
[state]	bgm-Unpack-RemoteCmd	远程命令	
																																																																																																							
	if	buflen	<	1
		return
	endif
	
	var	cmdType	bufdt	2	1	#命令类型
	var	cmdVar	bufdt	3	1	#命令类型
	#先回复
	var	len	4	#发送数据长度																																																																																																								
	varsz	dt	4	#发送数据																																																																																																								
	
	vardt	dt	0	1	0x01						#枪号																																																																																																					
	vardt	dt	1	1	0x77						#类型标识																																																																																																	
	
	vardt	dt	2	1	var	cmdType					#命令类型
	vardt	dt	3	1	0x01						#执行结果	
	
	bufwr	bgm.state		addr	len	#bgm.state为fd上任一测点,写buf,val(int[n]):buflen,data0(前四字节),data1(次四字节),…																																																																																																						
	#后执行
	if	var	cmdType	=	0x00		#平台急停
		if	mp	center.chgStatus	=	const	st-charge
			mp	center.chgStatus	const	st-stop	
		endif
		if	(	var	cmdVar		)	!=	0								#	远程禁止充电																																																																														
			or	mpofs	center.alarmStatus	0	0x10000000														#	状态为1，报警																																																																													
		else																																																																																																	
			and	mpofs	center.alarmStatus	0	(	not	0x10000000	)											#	状态为0，取消报警																																																																													
		endif																																																																																																	
	elseif	var	cmdType	=	0x01	#重启命令
		sleep	500
		shell	"reboot"
	elseif	var	cmdType	=	0x02
		shell	"/usr/local/bin/autossh -M 9990 -NfR 28888:localhost:22 root@39.105.14.24"
	endif
[state]	bgm-tmr-inConnection	连接时的定时操作																																																																																																								
	#log	"连接时的定时操作="	gun
																																																																																																												
	#call	bgm-wait-app-auth			#等待app鉴权																																																																																																							
	call	bgm-wait-app-start			#等待app启动																																																																																																							
	call	bgm-wait-app-stop			#等待app停止																																																																																																							
																																																																																																												
	if	(	mp	center.chgStatus	=	const	st-standby	)				#待机状态																																																																																															
		&	(	mp	bgm.waitStatus			!=	const	BGM_INIT		)	#未回待机状态																																																																																															
																																																																																																												
		mp	bgm.waitStatus			const	BGM_INIT			#回到初始状态																																																																																																		
	endif																																																																																																											
																																																																																																												
	var	workStatus		0	#空闲																																																																																																							
	if	(	mp	center.chgStatus			!=	const	st-standby		)																																																																																																	
		var	workStatus		1		#工作中																																																																																																					
	endif																																																																																																											
																																																																																																												
	if	var	workStatus		!=	mp	bgm.workStatus																																																																																																					
																																																																																																												
		if	var	workStatus		=	0																																																																																																					
			statemp		bgm.tmoSend		bgm-upload		const	upload-period-long			#定时上传时间为0.1分钟*50																																																																																															
		else																																																																																																										
			statemp		bgm.tmoSend		bgm-upload		const	upload-period-short			#定时上传时间为15s,充电时上送间隔为300ms*50																																																																																															
		endif																																																																																																										
																																																																																																												
		mp	bgm.workStatus			var	workStatus																																																																																																					
	endif																																																																																																											
[state]	bgm-wait-app-start	等待app启动																																																																																																								
	#log	"等待app启动="	gun
	#if	(	mp	center.chgStatus			=	const	st-standby		)	#充电机状态为待机																																																																																															
	#	&	(	mp	center.alarmStatus			=	0	)						#无告警																																																																																															
	#	&	(	mp	bgm.isConnected			=	1	)							#网络握手成功																																																																																															
	#																																																																																																											
	#	mp	center.startMode	1												#app启动充电																																																																																																		
	#	#mp	center.chgStatus	const	st-lock									#设充电状态为锁桩																																																																																																			
	#	mp	bgm.waitStatus		const	BGM_AUTH_ING							#等待app鉴权																																																																																																			
	#endif
    #
	#
	#if	(	mp	bgm.waitStatus			=	const	BGM_WAIT_START		)	#等待启动																																																																																																
	#																																																																																																											
	#	if	mp	center.chgStatus		=	const	st-standby		#如果充电状态为待机			发鉴权失败帧																																																																																															
	#																																																																																																											
	#		mp	bgm.waitStatus			const	BGM_INIT		#回到初始状态																																																																																																		
	#																																																																																																											
	#	endif																																																																																																										
	#endif																																																																																																											
																																																																																																												
																																																																																																												
[state]	bgm-cancel-app-start	取消app启动																																																																																																								
#	log	"取消app启动="	gun
	mp	center.chgStatus			const	st-standby																																																																																																						
	mp	bgm.waitStatus			const	BGM_INIT		#回到初始状态																																																																																																				
[state]	bgm-app-start	app启动																																																																																																								
#	log	"app启动="	gun
																																																																																																												
	var	gun-link-ok		0																																																																																																								
	call		acbc-isGunToCarLinkAndLockOK							#检查枪是否连接到车并上锁																																																																																																		
	if	(	var	rtn	=	1	)																																																																																																					
		var	gun-link-ok		1																																																																																																							
	endif																																																																																																											
#	log	"连接状态="	var	gun-link-ok
	
	
	var	isAsistV24	(	(	bufdt	44	1	)	&	0x10	)	>>	4
	if	var	isAsistV24	=	1	
		mp	center.isAsistV24	1
	else
		mp	center.isAsistV24	0
	endif

	var	len	25	#发送数据长度																																																																																																								
	varsz	dt	25	#发送数据																																																																																																								
	
	vardt	dt	0	1	0x01						#枪号																																																																																																					
	vardt	dt	1	1	0x43						#类型标识																																																																																																	
	
	var	appStartStatus	0
	if	(	var	gun-link-ok		=	1	)					#枪连接正常																																																																																															
		&&	(	mp	center.chgStatus			=	const	st-standby		)	#处于空闲状态
		&&	(	mp	center.alarmStatus	=	0	)
		log	"APP启动充电---"																																																																																																										
		mp	bgm.start				1				#标识app开始启动充电																																																																																																		
		mp	bgm.isAppCharge			0xFF			#标志：app启动充电																																																																																																		
		mp	center.startMode		1				#app启动充电																																																																																																		
		mp	center.chgStatus		const	st-configed																																																																																																				
		mp	bgm.waitStatus			const	BGM_WAIT_STOP		#app启动状态
		var	appStartStatus	1
	elseif	(	var	gun-link-ok	!=	1	)
		var	appStartStatus	2
	elseif	(	mp	center.chgStatus	!=	const	st-standby	)
		var	appStartStatus	3
	elseif	(	mp	center.alarmStatus	!=	0	)
		var	appStartStatus	4
	endif																																																																																																											

	vardt	dt	2	1	var	appStartStatus	
	
	vardt	dt	3	22	bufdt	2	22	#流水号																																																																																																	
	#记录流水号
	mpdt	bgm.serinum	0	22	bufdt	2	22	
	#记录卡号
	mpdt	bgm.cardnum	0	16	bufdt	24	16
	#记录余额
	mpdt	bgm.balance	0	4	bufdt	40	4	
	bufwr	bgm.state		addr	len	#bgm.state为fd上任一测点,写buf,val(int[n]):buflen,data0(前四字节),data1(次四字节),…																																																																																																						
																																																																																																												
[state]	bgm-wait-app-stop	等待app停机																																																																																																								
	#log	"等待app停机="	gun
																																																																																																												
	#if	(	mp	bgm.waitStatus			=	const	BGM_WAIT_STOP		)	#等待停机																																																																																																
	#	if	mp	center.chgStatus			=	const	st-standby		#如果充电状态为待机																																																																																																	
	#		mp	bgm.waitStatus			const	BGM_INIT																																																																																																				
	#	endif																																																																																																										
	#endif																																																																																																											
																																																																																																												
[state]	bgm-app-stop	app停机																																																																																																								
	log	"app停机="	gun
																																																																																																												
	if	mp	bgm.waitStatus		=	const	BGM_WAIT_STOP																																																																																																					
		&&	mp	center.chgStatus			<	const	st-stop																																																																																																			
		mp	center.chgStatus			const	st-stop		#设充电状态为停机中																																																																																																			
		mpofs	center.stopReason		0		0			#27.充电中,收到APP停止充电命令																																																																																														
		mp	bgm.waitStatus			const	BGM_INIT																																																																																																					
	endif																																																																																																											
	

	var	len	25	#发送数据长度																																																																																																								
	varsz	dt	25	#发送数据																																																																																																								
	
	vardt	dt	0	1	0x00																																																																																																										
	vardt	dt	1	1	0x45						#类型标识																																																																																																	
	vardt	dt	2	1	0x01						#类型标识																																																																																																	
	vardt	dt	3	22	(	mpdt	bgm.serinum	0	22	)
	
	bufwr	bgm.state		addr	len				#bgm.state为fd上任一测点,写buf,val(int[n]):buflen,data0(前四字节),data1(次四字节),…																																																																																																						

[state]	bgm-sync-time	对时操作																																																																																																								
	log	"对时操作="	gun
																																																																																																												
	var	i	var	rtn																																																																																																								
																																																																																																												
	var	len	10	#发送数据长度																																																																																																								
	varsz	dt	10	#发送数据																																																																																																								
																																																																																																												
	vardt	dt	0	1	0x00																																																																																																										
	vardt	dt	1	1	0x75						#类型标识																																																																																																	
	vardt	dt	2	1	bufdt	2	1	#毫秒低位																																																																																																	
	vardt	dt	3	1	bufdt	3	1	#毫秒高位																																																																																																	
	vardt	dt	4	1	bufdt	4	1	#分																																																																																																	
	vardt	dt	5	1	bufdt	5	1	#时																																																																																																	
	vardt	dt	6	1	bufdt	6	1	#星期与日																																																																																																	
	vardt	dt	7	1	bufdt	7	1	#月																																																																																																	
	vardt	dt	8	1	bufdt	8	1	#年																																																																																																	
	vardt	dt	9	1	bufdt	9	1	#年																																																																																																	
	bufwr	bgm.state		addr	len	#bgm.state为fd上任一测点,写buf,val(int[n]):buflen,data0(前四字节),data1(次四字节),…																																																																																																						
																																																																																																												
	var	set-y	(	bufdt	8	1	)	+	2000		#	年																																																																																														
	var	set-m		bufdt	7	1						#	月																																																																																														
	var	set-d	(	bufdt	6	1	)	&	0x1F		#	日																																																																																														
	var	set-H		bufdt	5	1						#	时																																																																																														
	var	set-M		bufdt	4	1						#	分																																																																																														
	var	set-S	(	bufdt	3	1	)					#	秒			.K=																																																																																											
																																																																																																												
	if	(	mp	center.chgStatus	=	const	st-standby			)																																																																																																
		shell	"date -s '"		var	set-y	"-"	var	set-m	"-"	var	set-d	" "	\																																																																																														
					var	set-H	":"	var	set-M	":"	var	set-S	"'"																																																																																															
		shell	"hwclock -w"																																																																																																									
	else																																																																																																											
		#log	" can not change time in standby status !!!"																																																																																																									
	endif																																																																																																											
																																																																																																												
[state]	bgm-upload	定时上传																																																																																																								
	#log	"定时上传="	gun
	var	status		mp	bgm.status																																																																																																							
	mp	bgm.status		0																																																																																																								
																																																																																																												
	var	send-alarm		0											#判断yc是否需要发送报警号																																																																																																
	if	mp	center.alarmStatus	!=	mp	bgm.sendFailStatus																																																																																																				
		var	send-alarm		1																																																																																																							
		mp	bgm.sendFailStatus	mp	center.alarmStatus																																																																																																					
	endif																																																																																																											
		
	#充电状态及枪状态变化需要立即上送
	var	send-yx		0	
	if	(	mp	center.chgStatus	=	const	st-standby	)	
		||	(	mp	center.chgStatus	=	const	st-charge	)
		||	(	mp	center.chgStatus	=	const	st-insul	)
		if	(	mp	center.chgStatus	!=	mp	bgm.sendChgStatus	)	
			||	(	var	send-alarm	=	1	)
			var	send-yx		1
			mp	bgm.sendChgStatus	mp	center.chgStatus																																																																																																					
		endif																																																																																																											
	endif
	
	#枪状态
	var	isLink	mp	acb.linkCarState	&	0x01	
	
	if	(	var	isLink	=	1	)																																																																																																					
		var	gun-link-ok		2	
	else
		var	gun-link-ok	1
	endif
	
	if	mp	bgm.linkCarState	!=	var	gun-link-ok
		mp	bgm.linkCarState	var	gun-link-ok
		var	send-yx		1
	endif
	
	
	if	var	send-yx		!=	0				#定时上传周期:30秒或1分钟																																																																																																		
		#||	mp	bgm.upCount		>	const	upload-period-long							#是否需要立即上传yc报警号																																																																																																		
		mp	bgm.upCount			0																																																																																																						
		call	bgm-Pack-realGunData																																																																																																												
	else																																																																																																											
		add	mp	bgm.upCount			1																																																																																																					
	endif																																																																																																											
																																																																																																												
																																																																																																												
	#if	mp	bgm.upCount-Alarm	>	const	upload-period-long
	#	||	(	var	send-alarm	!=	0	)	
	if	var	send-alarm	!=	0	
	#	mp	bgm.upCount-Alarm	0
		call	bgm-Pack-AlarmData							#告警数据上传																																																																																																	
	#else																																																																																																											
	#	add	mp	bgm.upCount-Alarm		1																																																																																																					
	endif																																																																																																											
																																																																																																												
[state]	bgm-Frame-Heart	发送心跳																																																																																																								
	log	"发送心跳="	mp	center.chgStatus	"gun="	gun
#TEST
	#var	j	0
	#do	while	var	j	<	4
	#	log	"Rate=1="			mpofs	center.rateTimeStart	var	j	
	#	log	"Rate=2="			mpofs	center.rateTimeEnd	var	j	
	#	log	"Rate=3="			mpofs	center.rate	var	j	
	#	add	var	j	1
	#loop
																																																																																																												
	#提前分配发送缓存																																																																																																											
	var	len	4	#发送数据长度																																																																																																								
	varsz	dt	4	#发送数据																																																																																																								
																																																																																																												
	#确认激活总召																																																																																																											
	vardt	dt	0	1	0x00		#确认激活总召																																																																																																					
	vardt	dt	1	1	0x03		#发送序号																																																																																																
	vardt	dt	2	1	0x00		#故障状态	JOBER																																																																																																
	vardt	dt	3	1	(	0x1B	+	50	)	#环境温度	JOBER																																																																																															
																																																																																																												
	bufwr	bgm.state		addr	len	#bgm.state为fd上任一测点,写buf,val(int[n]):buflen,data0(前四字节),data1(次四字节),…																																																																																																						
																																																																																																												
[state]	bgm-Unpack-heart		响应心跳																																																																																																								
#	log	"响应心跳="	gun
																																																																																																												
	mp	bgm.linkCount			0				#复位计数	
	
	if	mp	center.chgStatus		=	const	st-standby																																																																																																					
		statemp		bgm.tmoSend		bgm-upload		const	upload-period-long																																																																																																			
	else																																																																																																											
		statemp		bgm.tmoSend		bgm-upload		const	upload-period-short																																																																																																			
	endif																																																																																																											
																																																																																																												
[state]	bgm-Unpack-price	解析费率																																																																																																								
	log	"解析费率="	gun
	
	if	buflen	<	2
		return
	endif
	#00 06 00 3C 00 3C 00 3C 00 3C 00 01 38 80 00 01 38 80 00 01 38 80 00 01 38 80 02 01 68 01 04 38 02
	#00	01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
#	log	"长度="	buflen	
	#计算费率
	var	periodNum	bufdt	26	1	#时段总数
	mp	center.rateNum	var	periodNum	
	log	"个数="	mp	center.rateNum
	#解析服务费 服务费只有一个 
	mp	bgm.servicePrice	bufdt	3	-2
	log	"服务费="	mp	bgm.servicePrice
	mp	center.servicePrice	mp	bgm.servicePrice
	
	#暂存尖峰平谷
	var	sharp			bufdt	13	-4	
	var	peak			bufdt	17	-4
	var	flat			bufdt	21	-4
	var	valley			bufdt	25	-4
	
	#解析时间段
	#do	while	var	num	<	mp	center.chgrPerPile																																																																																				
	#	if	(	mpofs	chgr.addr		var	i	+	var	num	)	!=	0																																																																													
	#		add	var	chgrNum	1																																																																																					
	#	endif																																																																																									
	#	add	var	num	1																																																																																						
	#loop	
	var	i	0
	do	while	var	i	<	var	periodNum
			var	offset	(	27	+	(	var	i	*	3	)	)	+	1
			var	period	(	bufdt	var	offset	-2	)
			if	var	i	=	0
				mpofs	center.rateTimeStart	0	0
				mpofs	center.rateTimeEnd		0	(	var	period	*	60	)
			else
				mpofs	center.rateTimeStart	var	i	(	mpofs	center.rateTimeEnd	(	var	i	-	1	)	)
				mpofs	center.rateTimeEnd		var	i	(	(	mpofs	center.rateTimeStart	var	i	)	+	(	var	period	*	60	)	)	
			endif
			
			var	rateType		bufdt	(	var	offset	+	1	)	1
			#log	"费率类型="	var	offset
			#log	"费率222类型="	var	rateType
			if	var	rateType	=	1	
				mpofs	center.rate	var	i	var	sharp
			elseif	var	rateType	=	2	
				mpofs	center.rate	var	i	var	peak
			elseif	var	rateType	=	3
				mpofs	center.rate	var	i	var	flat
			elseif	var	rateType	=	4
				mpofs	center.rate	var	i	var	valley
			endif
		add	var	i	1
	loop		
	
#	log	"时段总数"	var	periodNum
	#var	j	0
	#do	while	var	j	<	var	periodNum
	#	log	"Rate=1="			mpofs	center.rateTimeStart	var	j	
	#	log	"Rate=2="			mpofs	center.rateTimeEnd	var	j	
	#	log	"Rate=3="			mpofs	center.rate	var	j	
	#	add	var	j	1
	#loop
	call	bgm-billing-model-insert
	if	mp	center.chgStatus		=	const	st-standby																																																																																																					
		statemp		bgm.tmoSend		bgm-upload		const	upload-period-long																																																																																																			
	else																																																																																																											
		statemp		bgm.tmoSend		bgm-upload		const	upload-period-short																																																																																																			
	endif																																																																																																											
[state]	bgm-Unpack-checkAck	解析账单确认
	log	"解析账单确认"																																																																																																								
	mp		bgm.waitCheckout			0										#本次充电记录上传完成																																																																																															
	mp		bgm.saveCheckoutFlag			4									#数据库保存标志,上传充电记录成功	
	if	mp		center.chgStatus	=		const	st-checkout
		mp		center.chgStatus			const	st-checkouted					#	将状态切换为"已结账"状态,	
	endif
																																																																																																											
	#func	db-update-hisdataFlag			(	0x02000000		|	0x01	)		#是否发送完成																																																																																											
[state]	bgm-Pack-realGunData	枪实时数据上传																																																																																																								
#	log	"枪实时数据上传="	gun
	
	#├───────────┼────────┤◆◆◆◆◆◆◆◆◆◆	
	#│数据对象   │  1字节 │					  │
	#├───────────┼────────┤					  │
	#│帧类型编码 │  1字节 │	脚本只组应用层	  │
	#├───────────┼────────┤					  │
	#│数据域     │  N字节 │					  │
	#├───────────┼────────┤◆◆◆◆◆◆◆◆◆◆	

	
	var	add-index		0																																																																																																								
	if	mp	center.curGun		=	0																																																																																																						
		var	add-index		0																																																																																																							
	else																																																																																																											
		var	add-index		5																																																																																																							
	endif																																																																																																											

	var	i	0																																																																																																									
	do	while	var	i	<	5																																																																																																						
																																																																																																												
		mpofs	bgm.beginKwh	var	i	mpofs	center.beginKwh			(	var	i	+	var	add-index	)																																																																																										
		mpofs	bgm.endKwh		var	i	mpofs	center.endKwh			(	var	i	+	var	add-index		)																																																																																										
		mpofs	bgm.price		var	i	mpofs	center.price			var	i																																																																																																
		mpofs	bgm.kwhCount		var	i	mpofs	acb.kwhCount			var	i																																																																																																
		mpofs	bgm.moneyCount		var	i	mpofs	acb.moneyCount			var	i																																																																																																
		add	var	i	1																																																																																																							
	loop
	
	var	len	52	#发送数据长度																																																																																																								
	varsz	dt	52	#发送数据																																																																																																								
																																																																																																												
	vardt	dt	0	1	0x01																																																																																																										
	vardt	dt	1	1	0x11								#类型标识1：不带时标的单点信息				单点遥信	
	vardt	dt	5	-4	(	mpofs	acb.curKwh	0	)		#总电量																																																																																																	
	vardt	dt	9	-4	0x00								#总运行时间																																																																																																	
	vardt	dt	13	-4	mp	acb.timeCount					#总充电时间	
	var	pileStatus	0x0
	#充电状态
	if	mp	center.chgStatus	=	const	st-standby
		var	pileStatus	0x00						
	elseif	(	mp	center.chgStatus	>=	const	st-configed	)	&&	(	mp	center.chgStatus	<	const	st-charge	)
		var	pileStatus	0x01
	elseif	(	mp	center.chgStatus	=	const	st-charge	)
		var	pileStatus	0x02
	endif
	
	if	mp	center.alarmStatus	!=	0
		var	pileStatus	0x03
	endif
	
	vardt	dt	14	1	var	pileStatus					#充电状态
	
	#枪状态
	var	isLink	mp	acb.linkCarState	&	0x01	
	
	if	(	var	isLink	=	1	)																																																																																																					
		var	gun-link-ok		2	
	else
		var	gun-link-ok	1
	endif	
	vardt	dt	15	1	var	gun-link-ok					#充电枪状态
	
	vardt	dt	17	-2	0x00							#车位及地锁状态
	vardt	dt	19	-2	mp	bms.reqV					#BMS电压需求
	vardt	dt	21	-2	mp	bms.reqC					#BMS电流需求
	vardt	dt	22	1	mp	bms.chargeMode				#BMS充电模式

	vardt	dt	24	-2	mp	acb.chargeV														#充电电压
	vardt	dt	26	-2	mp	acb.chargeC														#充电电流
	vardt	dt	30	-4	(	mpofs	bgm.kwhCount		0	)								#已充电量																																																																																																	
	vardt	dt	32	-2	(	mpofs	acb.chgrTimeCount	0	)								#已充时间
	vardt	dt	34	-2	(	mp	bms.rmnTime	)												#剩余时间
	vardt	dt	35	1	mp	bms.soc															#当前SOC
	vardt	dt	38	-3	mp	bms.MonoVnum													#最高单体动力蓄电池电压及所在编号
	vardt	dt	41	-3	0x00																#最低单体动力蓄电池电压及所在编号 27930无此内容
	vardt	dt	42	2	0x00
#	log	"总金额="	%X	mpofs	center.chargeMoney	0
	vardt	dt	47	-4	(	mpofs	acb.moneyCount	0	)								#总金额
	vardt	dt	51	-4	mp	center.serviceCost												#总服务费
	
	bufwr	bgm.state		addr	len	#bgm.state为fd上任一测点,写buf,val(int[n]):buflen,data0(前四字节),data1(次四字节),…																																																																																																						
[state]	bgm-Pack-AlarmData	告警数据上传																																																																																																								
	log	"告警数据上传="	gun
	
	#├───────────┼────────┤◆◆◆◆◆◆◆◆◆◆	
	#│数据对象   │  1字节 │					  │
	#├───────────┼────────┤					  │
	#│帧类型编码 │  1字节 │	脚本只组应用层	  │
	#├───────────┼────────┤					  │
	#│数据域     │  N字节 │					  │
	#├───────────┼────────┤◆◆◆◆◆◆◆◆◆◆	

		
	var	len	22	#发送数据长度																																																																																																								
	varsz	dt	22	#发送数据																																																																																																								
																																																																																																												
	vardt	dt	0	1	0x00						#																																																																																																									
	vardt	dt	1	1	0x13						#类型标识1：不带时标的单点信息				单点遥信

	if	mp	center.alarmStatus	!=	0				#告警总
		vardt	dt	2	1	0x01
	else
		vardt	dt	2	1	0x00
	endif
	
	#急停
	if	(	(	mpofs	center.alarmStatus	0	)	&	0x01	)
		vardt	dt	3	1	0x01
	else
		vardt	dt	3	1	0x00
	endif
	#防雷器
	if	(	(	mpofs	center.alarmStatus	0	)	&	0x02	)
		vardt	dt	4	1	0x01
	else
		vardt	dt	4	1	0x00
	endif
	#CC601通信错误
	if	(	(	mpofs	center.alarmStatus	0	)	&	0x20	)
		vardt	dt	5	1	0x01
	else
		vardt	dt	5	1	0x00
	endif
	#CJ601-1通信错误
	if	(	(	mpofs	center.alarmStatus	0	)	&	0x40	)
		vardt	dt	6	1	0x01
	else
		vardt	dt	6	1	0x00
	endif
	#CJ601-2通信错误
	if	(	(	mpofs	center.alarmStatus	0	)	&	0x80	)
		vardt	dt	7	1	0x01
	else
		vardt	dt	7	1	0x00
	endif
	#输出继电器错误
	if	(	(	mpofs	center.alarmStatus	0	)	&	0x100	)
		vardt	dt	8	1	0x01
	else
		vardt	dt	8	1	0x00
	endif
	#辅助电源异常
	if	(	(	mpofs	center.alarmStatus	0	)	&	0x200	)
		vardt	dt	9	1	0x01
	else
		vardt	dt	9	1	0x00
	endif
	#待机中泄放继电器合
	if	(	(	mpofs	center.alarmStatus	0	)	&	0x400	)
		vardt	dt	10	1	0x01
	else
		vardt	dt	10	1	0x00
	endif
	#待机中模块异常启机
	if	(	(	mpofs	center.alarmStatus	0	)	&	0x800	)
		vardt	dt	11	1	0x01
	else
		vardt	dt	11	1	0x00
	endif
	#11 12 位保留
	vardt	dt	12	2	0x00
	#直流熔断器故障
	vardt	dt	14	1	0x00
	#高压接触器故障
	vardt	dt	15	1	0x00
	#充电机输出控制异常
	vardt	dt	16	1	0x00
	#充电机输出过压
	vardt	dt	17	1	0x00
	#充电机输出过流
	vardt	dt	18	1	0x00
	#充电机输出短路
	vardt	dt	19	1	0x00
	#门打开
	vardt	dt	20	1	0x00
	
	#远程急停 (禁止充电) 点亮告警灯
	if	(	(	mpofs	center.alarmStatus	0	)	&	0x10000000	)
		vardt	dt	21	1	0x01
	else
		vardt	dt	21	1	0x00
	endif

	bufwr	bgm.state		addr	len	#bgm.state为fd上任一测点,写buf,val(int[n]):buflen,data0(前四字节),data1(次四字节),…																																																																																																						
[state]	bgm-Pack-ModAlarmData	模块告警上传																																																																																																								
	log	"模块告警上传="	gun
	
	#├───────────┼────────┤◆◆◆◆◆◆◆◆◆◆	
	#│数据对象   │  1字节 │					  │
	#├───────────┼────────┤					  │
	#│帧类型编码 │  1字节 │	脚本只组应用层	  │
	#├───────────┼────────┤					  │
	#│数据域     │  N字节 │					  │
	#├───────────┼────────┤◆◆◆◆◆◆◆◆◆◆	

	var	j	0	
	var	i	0
	var	len	(	10	+	6	*	mp	center.chgrPerPile	)		#发送数据长度																																																																																																								
	varsz	dt	80	#发送数据																																																																																																								
																																																																																																												
	vardt	dt	0	1	0x00						#																																																																																																									
	vardt	dt	1	1	0x15						#类型标识
	
	vardt	dt	2	1	0x19	+	50				#充电机温度 测试25℃
	vardt	dt	4	-2	0x08A2						#Ua 221V
	vardt	dt	6	-2	0x08A3						#Ua 222V
	vardt	dt	8	-2	0x08A4						#Ua 223V
	vardt	dt	9	1	mp	center.chgrPerPile		#模块个数

	#do	while	var	j	<	mp	center.chgrPerPile
	#	log	"输出电压："	mpofs	chgr.outV	var	j						#电压450V	11	17	23	29
	#	log	"输出电流"		mpofs	chgr.outC	var	j						#电流60A	13	19	25	31
	#	log	"告警状态1="	%X	mpdt	chgr.status0	var	j	1					#电流60A	13	19	25	31
	#	log	"告警状态2="	%X	mpdt	chgr.status1	var	j	1					#电流60A	13	19	25	31
	#	add	var	j	1
	#loop																																																																																																										
	
	#val	i	0	
	
	do	while	var	i	<	mp	center.chgrPerPile
		vardt	dt	(	11	+	(	var	i	*	6	)	)	-2	(	mpofs	chgr.outV	var	i	)	*	10							#电压450V	11	17	23	29
		vardt	dt	(	13	+	(	var	i	*	6	)	)	-2	(	mpofs	chgr.outC	var	i	)	*	10							#电流60A	13	19	25	31
		vardt	dt	(	14	+	(	var	i	*	6	)	)	1	(	(	mpdt	chgr.status0	var	i	1	)	&	0xFE	)		#模块状态	15	21	27	33
		vardt	dt	(	15	+	(	var	i	*	6	)	)	1	(	(	mpdt	chgr.status1	var	i	1	)	&	0xFB	)		#模块状态	16	22	28	34
		add	var	i	1
	loop																																																																																																											

	bufwr	bgm.state		addr	len	#bgm.state为fd上任一测点,写buf,val(int[n]):buflen,data0(前四字节),data1(次四字节),…																																																																																																						


[state]	bgm-get-fault-index	获得故障编号,用rtn返回,0没有故障																																																																																																								
	log	"获得故障编号,用rtn返回,0没有故障="	gun
																																																																																																												
	var	rtn	0																																																																																																									
	var	i	0																																																																																																									
	var	vl	mp	center.alarmStatus																																																																																																								
	var	base	0x01																																																																																																									
																																																																																																												
	do	while	var	i	<	32																																																																																																						
																																																																																																												
		if	(	var	vl	&	var	base	)	!=	0																																																																																																	
																																																																																																												
			add	var	i	101																																																																																																						
			var	rtn	(	var	i	|	0x100	)				#报警从101开始																																																																																														
			break																																																																																																									
		endif																																																																																																										
																																																																																																												
		shift	var	base	-1																																																																																																							
		add	var	i	1																																																																																																							
	loop																																																																																																											

[state]	bgm-time	取当前交易时间																																																																																																								
	log	"取当前交易时间="	gun
																																																																																																												
	varsz	t	2	#time,time2a都需要分配2个int的空间																																																																																																								
	var	t	0	#表示取当前时间																																																																																																								
	#得相对于1970个的时间																																																																																																											
	time	addr	t	#得时间,从1970年起的秒与微秒																																																																																																								
	#log	"second:"		var	t	",microsecond:"		varofs	t	1																																																																																																		
	#得CP56Time2a格式的时间(自扩展了一个字节)																																																																																																											
	time2a	addr	t	#得时间,CP56Time2a格式,扩展了一个字节,存年的高2位																																																																																																								
	#log	"CP56Time2a[0~1](millisecond):"				vardt	t	0	2																																																																																																			
	#log	"CP56Time2a[4](week,day):"				vardt	t	4	1	>>	5	","	\																																																																																															
	#	vardt	t	4	1	&	0x1F																																																																																																					
	var	i	0																																																																																																									
	do	while	var	i	<	8																																																																																																						
		#log	"CP56Time2a["		var	i	"]="	vardt	t	var	i	1																																																																																																
		add	var	i	1																																																																																																							
	loop																																																																																																											
	#将得到的CP56Time2a的时间转成BCD的格式,用于交易流水的后半部分																																																																																																											
	#	center.tradeNo		2	#交易流水的后半部分BCD(前半部分为pileNo）,[0x00200253,0x20150912],表示2015091200200253（yyyymmdd00hhmiss）																																																																																																							
	var	s	(	vardt	t	0	2	)	/	1000	#秒																																																																																																	
	mpdt	center.tradeNo		0	1																																																																																																							
			var	s	/	10	<<	4	|																																																																																																			
			var	s	%	10																																																																																																						
	var	s		vardt	t	2	1				#分																																																																																																	
	mpdt	center.tradeNo		1	1																																																																																																							
			var	s	/	10	<<	4	|																																																																																																			
			var	s	%	10																																																																																																						
	var	s		vardt	t	3	1				#时																																																																																																	
	mpdt	center.tradeNo		2	1																																																																																																							
			var	s	/	10	<<	4	|																																																																																																			
			var	s	%	10																																																																																																						
	mpdt	center.tradeNo		3	1	0				#00																																																																																																		
	var	s		vardt	t	4	1	&	0x1F		#日																																																																																																	
	mpdt	center.tradeNo		4	1																																																																																																							
			var	s	/	10	<<	4	|																																																																																																			
			var	s	%	10																																																																																																						
	var	s		vardt	t	5	1				#月																																																																																																	
	mpdt	center.tradeNo		5	1																																																																																																							
			var	s	/	10	<<	4	|																																																																																																			
			var	s	%	10																																																																																																						
	var	s		vardt	t	6	1				#年低2位																																																																																																	
	mpdt	center.tradeNo		6	1																																																																																																							
			var	s	/	10	<<	4	|																																																																																																			
			var	s	%	10																																																																																																						
	var	s		vardt	t	7	1				#年高2位																																																																																																	
	mpdt	center.tradeNo		7	1																																																																																																							
			var	s	/	10	<<	4	|																																																																																																			
			var	s	%	10																																																																																																						
	#log	%08x	"tradeNo BCD(0x):"			mp	center.tradeNo		","	mpofs	center.tradeNo		1																																																																																															
																																																																																																												
																																																																																																												
[state]	bgm-replaceCheckout	转存结账数据																																																																																																								
#	log	"转存结账数据="	gun
																																																																																																												
	mpofs	bgm.cardId		0	mpofs	center.cardId			0																																																																																																			
	mpofs	bgm.cardId		1	mpofs	center.cardId			1																																																																																																			
	mpofs	bgm.cardPhyId		0	mpofs	center.cardPhyId			0																																																																																																			
	mpofs	bgm.cardPhyId		1	mpofs	center.cardPhyId			1																																																																																																			
																																																																																																												
	mpofs	bgm.tradeNo		0	mpofs	center.tradeNo		0																																																																																																				
	mpofs	bgm.tradeNo		1	mpofs	center.tradeNo		1																																																																																																				
	mp	bgm.startTime			mpofs	center.startTime			mp	center.curGun																																																																																																		
	mp	bgm.endTime			mpofs	center.endTime			mp	center.curGun																																																																																																		
																																																																																																												
	var	add-index		0																																																																																																								
	if	mp	center.curGun		=	0																																																																																																						
		var	add-index		0																																																																																																							
	else																																																																																																											
		var	add-index		5																																																																																																							
	endif																																																																																																											
																																																																																																												
	var	i	0																																																																																																									
	do	while	var	i	<	5																																																																																																						
																																																																																																												
		mpofs	bgm.beginKwh		var	i	mpofs	center.beginKwh			(	var	i	+	var	add-index		)																																																																																										
		mpofs	bgm.endKwh		var	i	mpofs	center.endKwh			(	var	i	+	var	add-index		)																																																																																										
		mpofs	bgm.price		var	i	mpofs	center.price			var	i																																																																																																
		mpofs	bgm.kwhCount		var	i	mpofs	acb.kwhCount			var	i																																																																																																
		mpofs	bgm.moneyCount		var	i	mpofs	acb.moneyCount			var	i																																																																																																
		add	var	i	1																																																																																																							
	loop																																																																																																											
																																																																																																												
	mp	bgm.stopReason			0																																																																																																							
	mp	bgm.appCharge			mp	bgm.isAppCharge				#历史用bgm.appCharge,当前用bgm.isAppCharge																																																																																																		
	mp	bgm.cardPay			mp	bgm.isCardPay																																																																																																						
																																																																																																												
[state]	bgm-getBgmStopReason	获取停止原因																																																																																																								
#	log	"获取停止原因="	gun
																																																																																																												
	var	new-stopReason		mpofs	center.stopReason		0																																																																																																		
																																																																																																												
	if	var	new-stopReason			=	const	sr-app-stop			#app停止充电																																																																																																	
		var	new-stopReason			0xFF																																																																																																						
	elseif	var	new-stopReason			=	const	sr-bms-ok			#bms充满停机																																																																																																	
		var	new-stopReason			0xFE																																																																																																						
	endif																																																																																																											
																																																																																																												
	var	rtn	var	new-stopReason																																																																																																								
																																																																																																												
[state]	bgm-sendCheckout	发送结账数据																																																																																																								
#	log	"发送结账数据="	gun
	if	mp	bgm.isConnected		=	0																																																																																																						
		#log	"BMGLOG: tcp disconnect, can not send checkout data ------------------------------------------"																																																																																																									
		return																																																																																																										
	endif																																																																																																											
																																																																																																												
	mp	bgm.start			0				#起动状态改为0，初始值																																																																																																			
																																																																																																												
	call	bgm-replaceCheckout							#转存结账数据																																																																																																			
	mp	bgm.waitCheckout			2				#需要等待返回确认																																																																																																			
																																																																																																												
	if	mp	center.startMode			=	1			#app启动充电																																																																																																		
		mp	bgm.isAppCharge			0xFF				#标志：app启动充电																																																																																																		
		#log	"chargeMode: App"																																																																																																									
	else																																																																																																											
		mp	bgm.isAppCharge			0x00																																																																																																						
		#log	"chargeMode: Card"																																																																																																									
	endif																																																																																																											
																																																																																																												
	#后台验证,默认都为已结账																																																																																																											
	var	payOKFlag		0																																																																																																								
#	if	mp	center.startMode			=	2		#刷卡交易																																																																																																			
#		&	mp	bgm.isCardPay		=	0		#未结账																																																																																																			
#		var	payOKFlag		1																																																																																																							
#	endif																																																																																																											
	#log	"payOKFlag:"		var	payOKFlag		" - "	mp	center.startMode			" - "	mp	bgm.isCardPay																																																																																														
	
																																																																																																												
	#上传充电记录																																																																																																											
	var	len	72	#发送数据长度																																																																																																								
	varsz	dt	72	#发送数据																																																																																																								
	#上传充电记录																																																																																																											
	vardt	dt	0	1	0x01																																																																																																										
	vardt	dt	1	1	0x47												#类型标识																																																																																																	

	vardt	dt	2	22	mpdt	bgm.serinum	0	22							#流水号																																																																																															
	vardt	dt	24	16	mpdt	bgm.cardnum	0	16							#卡号																																																																																											
	vardt	dt	41	-2	(	mpofs	acb.kwhCount	0	)	/	10			#总电量																																																																																																	
	vardt	dt	45	-4	mpofs	acb.moneyCount	0							#总电费																																																																																																	
	vardt	dt	49	-4	mp	center.serviceCost								#总服务费																																																																																																	
	
	varsz	t	2																																																																																																									
	var	t	mpofs	center.startTime			mp	center.curGun																																																																																																				
	varofs	t	1	0																																																																																																								
	time2a	addr	t	

	#时间格式 毫秒2秒1分1时1日1月1年1
	vardt	dt	50	2	(	rand	0	999	)																	#系统毫秒未处理 可以为0 此处取随机值 无实际意义
	vardt	dt	52	1	(	vardt	t	0	2	)	/	1000													#秒																																																																																															
	vardt	dt	53	1	(	vardt	t	2	1	)																#分																																																																																															
	vardt	dt	54	1	(	vardt	t	3	1	)																#时																																																																																															
	vardt	dt	55	1	(	vardt	t	4	1	)	&	0x1F													#日																																																																																														
	vardt	dt	56	1	(	vardt	t	5	1	)																#月																																																																																															
	vardt	dt	57	1	(	(	vardt	t	7	1	)	*	100	+	(	vardt	t	6	1	)	-	2000	)	#年																																																																																															
																																																																																																												
	#log	"trace data begin time:"				%08X	var	t	"-"	varofs	t	1																																																																																																
	#func	bgm-getCP56		addr	t																																																																																																							
																																																																																																												
	var	t	mpofs	center.endTime			mp	center.curGun																																																																																																				
	varofs	t	1	0																																																																																																								
	time2a	addr	t																																																																																																									
	vardt	dt	58	2	(	rand	0	999	)																	#系统毫秒未处理 可以为0 此处取随机值 无实际意义
	vardt	dt	60	1	(	vardt	t	0	2	)	/	1000													#秒																																																																																															
	vardt	dt	61	1	(	vardt	t	2	1	)																#分																																																																																															
	vardt	dt	62	1	(	vardt	t	3	1	)																#时																																																																																															
	vardt	dt	63	1	(	vardt	t	4	1	)	&	0x1F													#日																																																																																														
	vardt	dt	64	1	(	vardt	t	5	1	)																#月																																																																																															
	vardt	dt	65	1	(	(	vardt	t	7	1	)	*	100	+	(	vardt	t	6	1	)	-	2000	)	#年																																																																																															

	vardt	dt	66	1	mp	bms.soc						#结束SOC 需记录
	vardt	dt	67	1	mp	center.stopReason		#结束原因
	vardt	dt	68	4	mpdt	bgm.balance	0	4	#余额

	bufwr	bgm.state		addr	len		#bgm.state为fd上任一测点,写buf,val(int[n]):buflen,data0(前四字节),data1(次四字节),…																																																																																																					
																																																																																																												
	#log	"BMGLOG: send checkout data to server >>>>>>---------------"																																																																																																										
	mp		bgm.saveCheckoutFlag			2	#数据库保存标志,结账																																																																																																					
																																																																																																												
																																																																																																												
[state]	bgm-changeCarId	转换车架号的字符,将非数字的车架号转换为数字																																																																																																								
	#log	"转换车架号的字符,将非数字的车架号转换为数字="	gun
																																																																																																												
	var	i	0																																																																																																									
	do	while	var	i	<	17																																																																																																						
																																																																																																												
		var	old-value		mpdt	bms.carId		var	i	1																																																																																																		
																																																																																																												
		var	is-ok	0																																																																																																								
		if	var	old-value		>=	0x30																																																																																																					
			&	var	old-value		<=	0x39																																																																																																				
			var	is-ok	1																																																																																																							
		endif																																																																																																										
																																																																																																												
		if	var	old-value		>=	0x41																																																																																																					
			&	var	old-value		<=	0x5A																																																																																																				
			var	is-ok	1																																																																																																							
		endif																																																																																																										
																																																																																																												
		if	var	old-value		>=	0x61																																																																																																					
			&	var	old-value		<=	0x7A																																																																																																				
			var	is-ok	1																																																																																																							
		endif																																																																																																										
																																																																																																												
		if	var	is-ok	=	0																																																																																																						
			mpdt	bms.carId		var	i	1		0x30		#非可读字符都转换为ascii码的"0"																																																																																																
		endif																																																																																																										
																																																																																																												
		add	var	i	1																																																																																																							
	loop																																																																																																											
																																																																																																												
																																																																																																												
[state]	bgm-print-carId	打印车架号																																																																																																								
	#log	"打印车架号="	gun
																																																																																																												
	#log	%^	"bms get carId:"																																																																																																									
	var	tmp	0																																																																																																									
	do	while	var	tmp	<	17																																																																																																						
		#log	%^	%02X	mpdt	bms.carId		var	tmp	1																																																																																																		
		add	var	tmp	1																																																																																																							
	loop																																																																																																											
	#log	%^	%\n																																																																																																									
																																																																																																												
[state]	bgm-ask-billing-model	请求下发计费模型																																																																																																							
#	log	"请求下发计费模型="	gun
	#├───────────┼────────┤◆◆◆◆◆◆◆◆◆◆	
	#│数据对象   │  1字节 │	00：直流桩		  │
	#├───────────┼────────┤					  │
	#│帧类型编码 │  1字节 │	05：请求计费模型  │
	#├───────────┼────────┤					  │
	#│数据域     │  1字节 │	01：请求		  │
	#├───────────┼────────┤◆◆◆◆◆◆◆◆◆◆	

	var	len	3																																																																																																											
	varsz	dt	3																																																																																																									
	vardt	dt	0	1	0x00																																																																																																							
	vardt	dt	1	1	0x05																																																																																																	
	vardt	dt	2	1	0x01																																																																																																
	bufwr	bgm.state		addr	len	#bgm.state为fd上任一测点,写buf,val(int[n]):buflen,data0(前四字节),data1(次四字节),…																																																																																																						
																																																																																																												
[state]{lock}	bgm-billing-model-insert	存储计费模型数据																																																																																																							
	log	"存储计费模型数据="	gun
	
	
	var	i	var	rtn																																																																																																								
	var	sql-find		0																																																																																																								
	var	len		0	
	#清空原纪录 len应该根据费率数量循环
	do	while	var	len	<	10
		var	sql-find		concat	"select  id from time_rate where id = "	\																																																																																													
						%d	var	len																																																																																															
		#log	str	sql-find																																																																																																									
		var	a	mpc	db.prep	addr	sql-find																																																																																																						
		#a保存一个内存地址,指向某区域,此区域:int[]{row,col,data},char** data,data为返回结果集,按类型返回不同的结构																																																																																																											
		var	r	ptr	a	+	1	#结果集的行数,包括字段类型一行,所以+1																																																																																																					
		var	c	varofs	ptr	a	1	#结果集的列数																																																																																																					
		var	pc	varofs	ptr	a	2	#char**,指向结果集																																																																																																					
		#log	"db.prep priceModel row="				var	r	-	1	",col="	var	c	
	
	
		if	var	r	>	1			#取数据库数据塞测点																																																																																																				
			#log	"price model has saved!!!!"																																																																																																									
																																																																																																													
			var	ex	concat	"delete from time_rate where id = "	%d	var	len																																																																																								
			var	a	mpc	db.exec	var	ex																																																																																																					
			#log	"sql="	str	ex																																																																																																							
																																																																																																													
			if	var	a	=	0																																																																																																						
				log	"delete priceModel success!"																																																																																																								
			else																																																																																																										
				log	"delete priceModel error!"																																																																																																								
			endif																																																																																																										
		endif
		add	var	len	1
	loop

	#插入数据库																																																																																																											
	var	sql-insrt		0	#只是为分配空间，prep会用到																																																																																																							
	var	insrt-len		0	
	var	len	0
	do	while	var	len	<	mp	center.rateNum
		var	sql-insrt	concat	"insert into time_rate( id,iTimeStart,iTimeEnd,iRate,iType,iIndex) values("		\
		var	len	\	
		","		\
		(	mpofs	center.rateTimeStart	var	len	)	\	#主键 序号
		","		\
		mpofs	center.rateTimeEnd	var	len	\
		","		\
		mpofs	center.rate	var	len	\
		","		\
		var	len	\	#尖峰平谷类型 暂时未使用
		","		\
		var	len	\	#索引号 暂时未使用
		")"	
		#log	"sql="	str	sql-insrt																																																																																																								
		var	a	mpc	db.prep		addr	sql-insrt																																																																																																					
		
		add	var	len	1
	loop
	
	#存储费率条数
	log	"存储费率"
	var	ex	0																																																																																								
	var	ex	concat	"update ChargeData set sys_value= "	\																																																																												
			mp	center.rateNum	\																																																																													
			" where sys_name='iRateNum'"																																																																																							
	var	a	mpc	db.exec	var	ex																																																																																						
																																																																																												
	log	"sql="	str	ex																																																																																								
	if	var	a	=	0																																																																																							
		log	"update ChargeData iRateNum success!"																																																																																									
	else																																																																																											
		log	"update ChargeData iRateNum error!"																																																																																									
	endif

	#存储服务费
	log	"存储服务费"
	var	ex	0																																																																																								
	var	ex	concat	"update ChargeData set sys_value= "	\																																																																												
			mp	center.servicePrice	\																																																																													
			" where sys_name='iServiceCharge'"																																																																																							
	var	a	mpc	db.exec	var	ex																																																																																						

	log	"sql="	str	ex																																																																																								
	if	var	a	=	0																																																																																							
		log	"update ChargeData iServiceCharge success!"																																																																																									
	else																																																																																											
		log	"update ChargeData iServiceCharge error!"																																																																																									
	endif
	
[state]	bgm-getCP56	打印时间																																																																																																							
	#log	"打印时间="	gun
	var	i	var	rtn																																																																																																								
	varsz	t	2																																																																																																									
	varofs	t	0	ptr	i					#t[0] = *i																																																																																																						
	varofs	t	1	varofs	ptr	i	1		#t[1] = *(i + 1)
	log	"CP56Time---:"		vardt	t	6	2
	#var	year-h		vardt	t	7	1				#年高2位																																																																																																	
	var	year-l		(	(	vardt	t	7	1	)	*	100	+	(	vardt	t	6	1	)	-	2000	)	#年低2位																																																																																																	
	var	month		vardt	t	5	1				#月																																																																																																	
	var	day			vardt	t	4	1	&	0x1F	#日																																																																																																	
	var	hour		vardt	t	3	1				#时																																																																																																	
	var	min			vardt	t	2	1				#分																																																																																																	
	var	sec		(	vardt	t	0	2	)	/	1000	#秒		
	log	"CP56Time:"		%02d			var	year-l		"-"	var	month	"-"	var	day	\																																																																																										
					" "		var	hour	":"	var	min	":"	var	sec		
[state]	chgr-init	初始化									#																																												
#tag	command																																																							
#	常量初始化-chgr																																																							
#	const	chgr-mode-standby			0	#	停机																																																	
#	const	chgr-mode-start			2	#	启机中																																																	
#	const	chgr-mode-charging			10	#	启机,充电中																																																	
#	const	chgr-mode-stop			1	#	停机中	
	const	unpack-null	0x1			#开\关机复位
	const	unpack-fail	0x0			#开\关机失败																																																
	const	unpack-success	0xFF	#开\关机成功	
	
	const	moudle-close	0x1			#模块关机
	const	moudle-work		0x0			#模块运行		
#	初始化测点																																																							
	#log	"chgr初始化="	gun
	#mp	chgr.commCount			0							#	模块通讯计数	
	######################
	mp	chgr.Num	(	mp	a.chgr.PerGunNum	+	mp	b.chgr.PerGunNum	)	#充电模块总数		
	######################
	#mp	center.ruiflag	0	#joy	test
	#ZB修改
	#filter	chgr.state							\	CAN3需重新定义过滤器																																														
	#	(	mpofs	center.addr		mp	center.curPile		)	<<	8	\	当前桩地址																																											
	#		0xFF00				\						mask																																											
	#	0xFF00	0xFF00						#	广播地址		mask		
	if	gun	=	0	
	#filter	chgr.state							\	CAN3需重新定义过滤器																																														
	#	0xC000	\	当前桩地址																																											
	#		0xFF00				\						mask																																											
	#	0xFF00	0xFF00						#	广播地址		mask
	filter	chgr.state	0xC000	0xFF00	0xFF00	0xFF00	#	共两条过滤规则，分别以过滤地址+mask形式表示
	endif																																																							
#	state	chgr		0		#充电机模块状态																																																		
#	statemp		chgr.state			chgr-setgroup			0																																															
#	statemp		chgr.state			chgr-startupsend			1000																																															
#	statemp		chgr.state			chgr-charging			0																																															
#	statemp		chgr.state			chgr-comrecv			0																																															
#	statemp		chgr.state			chgr-shutdown			0																																															
	statemp		chgr.state			chgr-standby			0			#	接收																																											
#	statemp		chgr.state-chk			chgr-tmo			60000																																															
#	statemp		chgr.state-tmo2			chgr-tmo2			0																																															
	statemp		chgr.state-chk			chgr-statechk			2000			#	检查																																											
	statemp		chgr.state-tmo1			idle			0																																																																																																							
	#初始化模块运行状态
	var	x	0
	do	while	var	x	<	mp	chgr.Num
		mpofs	chgr.chgr	var	x	const	moudle-close
		add	var	x	1
	loop
	mp		chgr.checkModID			0	#模块ID号																																															
	mp		chgr.errorState			0	#模块故障状态(暂时不用)
#	mp	a.chgr.reqV	300000
#	mp	chgr.reqC	1000
#	mp	b.chgr.reqV	400000
#	mpofs	pile.status		0	-11		#	各桩状态,0:闲,1~4桩地址表示工作中,-桩地址表示占用未工作																																																
#	mpofs	pile.status		1	0																																																			
#	mpofs	pile.status		2	0																																																			
#	mpofs	pile.status		3	0																																																			
#	mpofs	pile.assist		0	0		#	辅助桩，0：未用，1：发中止，11：发申请，12：发工作，20：已用																																																
#	mpofs	pile.assist		1	0																																																			
#	mpofs	pile.assist		2	0																																																			
#	mpofs	pile.assist		3	0																																																			
																																																								
																																																								
[state]	chgr-comrecv			解帧：通用接收部分,检查通讯状态和报警状态,返回1表示有报警								#																																																																																				
#tag	command											#																																																																																				
	#log		"canlen="	canlen	";"		"canid="	%x	canid	";"	"candt="	"%x"	candt	0	4	";"	"candt2="	candt	4	4	
	#log		"data="	%x	candt	0	4	
	#log		"data="	%x	candt	0	1
	#log	"通用接收="	gun
	if	canlen	<=	0								#	无数据,不检查通讯状态																																																																																			
		return																																																																																														
	endif	

	var	idx		(	canid	&	0x7F		)					#模块地址	
	
	if	var	idx	<	1	|	var	idx	>	mp	chgr.Num	
		return
	endif
	var	addrs			var	idx	-	1																																																																																								
	var	Id		(	canid	&	0x7fffffff	)		#信号ID																																																																														
	#log	"Id1="	%x	var	Id	
	var	Id	var	Id	>>	7	
	#log	"Id2="	%x	var	Id
	#log	"正对地电压: "							mp	acb.insuVp		", 输出总电压:"		mp	acb.chargeV	
	mpofs	a.chgr.commCount	var	addrs	0	
	mpofs	b.chgr.commCount	var	addrs	0	
	#log	"复位模块号="	var	addrs	";值="	mpofs	chgr.commCount	var	addrs
	if	var	Id	=	(	0x1207c080	>>	7	)							#读取信息																																																																																			
		var	cmd	(	(	candt	0	1	)	&	0xff	)			#CMD
		if	var	cmd	=	0		#模块回复输出
			var	CurSetState	(	candt	1	1	&	0x0f	)
			mpofs	chgr.CurSetState	var	addrs	var	CurSetState		#电流设定状态			
			var	VolSetState	(	candt	1	1	&	0xf0	)	>>	4
			mpofs	chgr.VolSetState	var	addrs	var	VolSetState	#电压设定状态
		elseif	var	cmd	=	1	#模块回复信息当前信息及状态
			var	outC	(	candt	3	-2	)	/	10
			mpofs	chgr.outC	var	addrs	var	outC		#读取电流
			#log	"candt42="	%x	candt	4	2
			#log	"candt41="	%x	candt	4	1
			#log	"candt51="	%x	candt	5	1
			
			var	outV	(	candt	5	-2	)	/	10
			mpofs	chgr.outV	var	addrs	var	outV		#读取电压
			var	status0	(	candt	7	1	&	0xFF	)	
			mpdt	chgr.status0	var	addrs	1	var	status0		#读取状态0
			#log	"读取状态0="	%X	var	status0
			var	status1	(	candt	6	1	&	0xFF	)	
			mpdt	chgr.status1	var	addrs	1	var	status1		#读取状态1
			#log	"读取状态1="	%X	var	status1
			#解：获取模块运行状态(开机还是关机)
			if	(	(	mpdt	chgr.status0	var	addrs	1	)	&	0x1	)	=	0
				mpofs	chgr.chgr	var	addrs	const	moudle-work
				#log	"模块地址="	var	addrs	";"	"模块在运行中..."
			else
				mpofs	chgr.chgr	var	addrs	const	moudle-close
				#log	"模块地址="	var	addrs	";"	"模块在待机中..."
			endif
			#log	"模块地址="	var	addrs	";"	"模块运行状态="	mpofs	chgr.chgr	var	addrs				
			#log	"addrs="	%x	var	addrs	";"	"outC="	%x	var	outC
		elseif	var	cmd	=	2	#模块回复开关机
			#log	"模块回复开机地址="	var	addrs	"状态值="	candt	1	1	"addrs="	var	addrs	
			if	candt	1	1	=	0xFF
				mpofs	chgr.OnOff	var	addrs	const	unpack-success
			endif
		endif																																																																													
																																																																																																
	elseif	var	Id	=	(	0x12010080	>>	7	)							#模块限压设定																																																																																				
	elseif	var	Id	=	(	0x12010880	>>	7	)							#模块限流设定																																																																																				
	endif	


[state]	chgr-standby			充电模块待机								#																																																																																				
#tag	command											#																																																																																				
	#log	"&&&&&&&&chgr-standby&&&&&&&&&"																																																																																															
	var	chgrstartOk		0																																																																																												
	var	i	0																																																																																												
	call	chgr-comrecv																																																																																														
	call	chgr-checkchgrState	


	do	while	var	i	<	mp	chgr.PerGunNum																																																																																									
		#log	"chgr-standby------------chgr.chgr"						mpofs	chgr.chgr		var	i																																																																																			
		if	mpofs	chgr.chgr	(	(	mpofs	chgr.GunAddr		var	i	)	-	1	)	=	const	moudle-work		#																																																																												
			#log	"gun="	gun	"运行中的模块地址="	mpofs	chgr.GunAddr		var	i	"接下来发送停止命令"																																																																																												
			var	chgrstartOk		1						#	模块开机状态																																																																																			
			#log	"chgr-standby---------have modl error open modID:"									var	i	+	1																																																																																
		endif																																																																																														
		add	var	i	1																																																																																											
	loop																																																																																															
	
	
	if	mp	center.chgStatus			=	const	st-standby				#	待机时，检测到有模块开机,则立即关机，起保护作用																																																																																			
		&	var	chgrstartOk		=	1																																																																																									
																																																																																																
		call	chgr-shutdownsend									#	发送关机																																																																																			
																																																																																																
	endif
	if	mp	chgr.status		=	const	chgr-mode-stop					#	待机流程若外部置主动停机																																																																																			
		#log	"启机过程,有人要停机"					mp	chgr.status																																																																																							
		statemp		chgr.state			chgr-shutdown			0	#	停机																																																																																				
		statemp		chgr.state-tmo			chgr-stoptimeout			13000	#	超时																																																																																				
		statemp		chgr.state-tmo1			chgr-shutdownsend			-1000	#	定时发送停机																																																																																																																																																																																		
	endif		
	#log	"需求电压="	%d	mp	chgr.reqV	
	#log	"center.ruiflag="	mp	center.ruiflag	
	#if	mp	center.ruiflag	=	0
	#mp	a.chgr.status	const	chgr-mode-start
	#	mp	center.ruiflag	1
	#endif
	#log	"启动标志="	%d	mp	chgr.status	","	%d	gun	
	if	mp	chgr.status		=	const	chgr-mode-start					#	由待机状态变为启机中状态	该标志位由acb赋值																																																																																		
		&	var	rtn	=	0						#	无告警																																																																																			
		
		log	"chgr进入启机"																																																																																													
																																																																																																
		statemp		chgr.state			chgr-startup			0		#	进入启机中																																																																																			
		statemp		chgr.state-tmo1			chgr-startupsend			-1000		#	开机指令																																																																																			
		statemp		chgr.state-tmo			idle			0																																																																																						
																																																																																																
	#elseif	mp	chgr.status		=	const	chgr-mode-stop					#	如果收到停机中	(joy封掉，没必要，因为当前已经在待机中)																																																																																		
																																																																																																
	#	mp	chgr.status			const	chgr-mode-standby					#	置模块状态为停机																																																																																			
																																																																																																
	endif																																																																																															
																																																																																																
[state]	chgr-startup			充电机启机中解帧								#																																																																																				
#tag	command											#																																																																																				
																																																																																																
	call	chgr-comrecv																																																																																														
	call	chgr-checkchgrState																																																																																														
	#log	"startup*****rtn="	var	rtn																																																																																															
	if	var	rtn	=	1																																																																																											
		log	"启机超时"
		call	chgr-timeout																																																																																													
		return																																																																																														
	endif																																																																																															
																																																																																																
	if	mp	chgr.status		=	const	chgr-mode-stop					#	流程主动停机																																																																																			
		#log	"启机过程,有人要停机"					mp	chgr.status																																																																																							
		statemp		chgr.state			chgr-shutdown			0	#	停机																																																																																				
		statemp		chgr.state-tmo			chgr-stoptimeout			13000	#	超时																																																																																				
		statemp		chgr.state-tmo1			chgr-shutdownsend			-1000	#	定时发送停机																																																																																				
		return																																																																																														
	endif																																																																																															
																																																																																																
	var	i	0																																																																																													
	var	j	0
		
	#do	while	var	i	<	mp	chgr.PerGunNum				#检查模块运行状态																																																																																				
	#	var	state	(	(	mpdt	chgr.status0	(	(	mpofs	chgr.GunAddr	var	i	)	-	1	)	1	)	&	0x01	)																																																																																																
	#	log	"启机过程state="	%x	var	state
	#	if	var	state	!=	0	#																																																																													
	#		var	j	1																																																																																											
	#	endif																																																																																														
	#	add	var	i	1																																																																																											
	#loop
	log	"启机等待判定"	gun	"chgr.PerGunNum="	mp	chgr.PerGunNum	
	do	while	var	i	<	mp	chgr.PerGunNum				#检查返回报文				
		if	mpofs	chgr.OnOff	(	(	mpofs	chgr.GunAddr	var	i	)	-	1	)	!=	const	unpack-success	#																																																																													
			var	j	1
			log	"异常模块号="	(	(	mpofs	chgr.GunAddr	var	i	)	-	1	)			
		endif																																																																																														
		add	var	i	1																																																																																											
	loop
	
	if	var	j	=	0			#该枪下模块均在充电中，则置位启机中标志																																																																																										
		log	"启机成功"																																																																																														
		mp	chgr.status			const	chgr-mode-charging			#	启机成功,置启机标志 10																																																																																					
		log	"chgr.status="	%d	mp	chgr.status	"当前枪号="	gun																																																																																
		
		do	while	var	i	<	mp	chgr.PerGunNum				#检查模块运行状态																																																																																																																																																																																			
			mpofs	chgr.OnOff	(	(	mpofs	chgr.GunAddr	var	i	)	-	1	)	const	unpack-null																																																																																																																																																																												
				add	var	i	1	
		loop		
		statemp		chgr.state			chgr-charging			0	#	进入充电中状态,																																																																																				
		statemp		chgr.state-tmo1			idle			0	#	超时																																																																																				
		statemp		chgr.state-tmo			chgr-chargingsend			-1000	#	充电中定时发送启机																																																																																				
																																																																																																
	endif																																																																																															
																																																																																																
[state]	chgr-startupsend			启机发送指令								#																																																																																				
#tag	command											#																																																																																				
																																																																																																
#	log	"启机"																																																																																														
																																																																																																
	log	"CHGR:chgr.reqC=  "					%d	mp	chgr.reqC																																																																																							
	#log	"CHGR: chgr.Num=  "					%d	mp	chgr.Num																																																																																							
	#log	"CHGR: center.maxOutC:"					mp	center.maxOutC																																																																																								
	log	"CHGR:chgr.reqV=  "					%d	mp	chgr.reqV																																																																																							
	#开机指令
	#log	"mp chgr.status="	mp	chgr.status	
	if	mp	chgr.status	=	const	chgr-mode-start				#启机或者充电中		
		
		mp	chgr.status	const	chgr-mode-starting			#置位启机中
		var	i	0
		#log	"模块总数="	%d	mp	chgr.PerGunNum
		do	while	var	i	<	mp	chgr.PerGunNum	#设定电压、电流						
			var	UID	0
			var	UID	(	(	0x9307C080	)	|	(	mpofs	chgr.GunAddr	var	i	)	)	#设定电压、电流																																																																								
			var	UID	var	UID	|	0x80000000
			var	len	8
			varsz	dt	8
			vardt	dt	0	8	0	
			vardt	dt	3	-2	(	mp	chgr.reqC	/	(	mp	chgr.PerGunNum	)	)	#设定电流
			vardt	dt	7	-4	mp	chgr.reqV	#设定电压
#			log	"发送启机，需求电压="					%d	mp	chgr.reqV		
			canwr	chgr.state			addr	UID		
			add	var	i	1
		loop
		var	i	0
		do	while	var	i	<	mp	chgr.PerGunNum	#设定电压、电流		
			var	UID	0	
			var	UID	(	0x9307C080	|	(	mpofs	chgr.GunAddr	var	i	)	)				#关机 																																																																						
			var	UID	var	UID	|	0x80000000
			var	len	8	
			#varsz	dt	8
			vardt	dt	0	8	0			
			vardt	dt	0	1	2	
			vardt	dt	7	1	0x55	#开机指令	
			canwr	chgr.state			addr	UID		
			add	var	i	1	#
		loop
	endif																																																																																																	
[state]	chgr-charging			充电中：充电机已启机（解帧	与监测）							#																																																																																				
#tag	command											#																																																																																				
																																																																																																
	call	chgr-comrecv																																																																																														
	#call	chgr-checkchgrState																																																																																														
	var	i	0																																																																																													
	var	run-ok	0	#为1，则异常																																																																																												
	#命令停止
	
	#log	"充电中chgr.status"	%d	mp	chgr.status	"当前枪号="	%d	gun
	#mp	chgr.status	const	chgr-mode-stop
	#log	"测试：主动停机chgr.status="	%d	mp	chgr.status
	if	mp	chgr.status		=	const	chgr-mode-stop
#		log	"cmd stop###########"
		statemp		chgr.state			chgr-shutdown			0	#	停机																																																																																				
		statemp		chgr.state-tmo1			chgr-shutdownsend			-1000	#	定时发送停机																																																																																				
		statemp		chgr.state-tmo			chgr-stoptimeout			13000	#	超时																																																																																						
	endif
	#异常停止
	#var	i	0																																																																																													
	#do	while	var	i	<	mp	chgr.PerGunNum
	#	var	status0	mpdt	chgr.status0	(	(	mpofs	chgr.GunAddr	var	i	)	-	1	)	1
	#	var	status1	mpdt	chgr.status1	(	(	mpofs	chgr.GunAddr	var	i	)	-	1	)	1
	#	if	var	status0	!=	0	|	var	status1	!=	0
	#		var	run-ok	1
	#	endif
	#	add	var	i	1
	#loop
	
	if	var	run-ok	=	1						#模块关机	
		log	"异常停止######"
		mp	chgr.status	const	chgr-mode-standby	#置位待机命令接口
		mp	center.chgStatus				const	st-stop																																																																																							
		mpofs	center.stopReason			0		22						#	停机原因:充电中,检测到模块为非启动状态																																																																																																																																																																															
		statemp		chgr.state			chgr-shutdown			0	#	停机																																																																																				
		statemp		chgr.state-tmo1			chgr-shutdownsend			-1000	#	定时发送停机																																																																																				
		statemp		chgr.state-tmo			chgr-stoptimeout			13000	#	超时																																																																																				
	endif																																																																																															
																																																																																																
[state]	chgr-chargingsend			充电中发送指令								#																																																																																				
#tag	command											#																																																																																				
	#log	"充电中chargingsend***********chgr.status="	mp	chgr.status	"当前枪="	gun	
	#log	"acb.chargeC="	%X	mp	acb.chargeC																																																																																																		
	#下发需求电压、电流指令	

	add	mp	center.printfCnt	1																																																																																										
	if	mp	center.printfCnt	>	20
		mp	center.printfCnt	0	
		log	"下发电压="	mp	chgr.reqV	";"	"电流="	mp	chgr.reqC	";"	"实际电流="	mp	acb.chargeC	";"	"电压="	mp	acb.chargeV	"模块数量="		mp	chgr.PerGunNum	";"	
		log	"BMS电压="	mp	bms.reqV	";"	"电流="	mp	bms.reqC	";"
	#	log	"母联位置"	%X	(	mpofs	acb.frontIn	0	)	&	mpofs	acb.commSwitch	0	
	endif	
	if	mp	chgr.status	=	const	chgr-mode-charging				#充电中		
		#log	"PerGunNum="	mp	chgr.PerGunNum
		var	i	0
		do	while	var	i	<	mp	chgr.PerGunNum	#设定电压、电流						
			var	UID	0
			var	UID	(	(	0x9307C080	)	|	(	mpofs	chgr.GunAddr	var	i	)	)	#设定电压、电流																																																																								
			var	UID	var	UID	|	0x80000000
			var	len	8
			varsz	dt	8
			vardt	dt	0	8	0	
#			log	"充电中下发电压="	mp	chgr.reqV	";"	"电流="	mp	chgr.reqC	
			vardt	dt	3	-2	(	mp	chgr.reqC	/	(	mp	chgr.PerGunNum	)	)	#设定电流
			vardt	dt	7	-4	mp	chgr.reqV	#设定电压			
			canwr	chgr.state			addr	UID		
			add	var	i	1
		loop		
	endif	
	
[state]	chgr-shutdown			充电机停机中解帧								#																																																																																				
#tag	command											#																																																																																				
																																																																																																
	call	chgr-comrecv																																																																																														
																																																																																														
	var	i	0																																																																																													
	var	j	0
	#var	state	0
	
	#do	while	var	i	<	mp	chgr.PerGunNum				#检查模块运行状态																																																																																				
	#	var	state	(	(	mpofs	chgr.status0	(	(	mpofs	chgr.GunAddr	var	i	)	-	1	)	)	&	0x01	)																																																																																																
	#	
	#	#log	"模块状态="	mpofs	chgr.status0	(	(	mpofs	a.chgr.GunAddr	var	i	)	-	1	)	
	#	#log	"模块状态state="	var	state
	#	if	var	state	=	0		#																																																																													
	#		var	j	1																																																																																											
	#	endif																																																																																														
	#	add	var	i	1																																																																																											
	#loop																																																																																															
	do	while	var	i	<	mp	chgr.PerGunNum				#检查模块停止状态																																																																																																																																																																																			
		if	mpofs	chgr.OnOff	(	(	mpofs	chgr.GunAddr	var	i	)	-	1	)	!=	const	unpack-success	#																																																																													
			var	j	1
			log	"停止失败模块号="	(	mpofs	chgr.GunAddr	var	i	)
		endif																																																																																														
		add	var	i	1																																																																																											
	loop																																																																																															
	
	#log	"充电机停机中解帧"	%X	var	ack
	log	"停机中j="	var	j																																																																																															
	if	var	j	=	0			#该枪下模块均已停止充电，则置位待机标志																																																																																										
		log	"充电模块停止成功,模块电压="	mpofs	chgr.outV	0																																																																																								
		mp	chgr.status			const	chgr-mode-standby			#	停机成功,置待机标志 0	

		do	while	var	i	<	mp	chgr.PerGunNum				#检查模块运行状态																																																																																																																																																																																			
			mpofs	chgr.OnOff	(	(	mpofs	chgr.GunAddr	var	i	)	-	1	)	const	unpack-null	#																																																																																																																																																																																																																																																																						
		add	var	i	1																																																																																											
		loop				
		statemp		chgr.state			chgr-standby			0																																																																																						
		statemp		chgr.state-tmo			idle			0																																																																																						
		statemp		chgr.state-tmo1			idle			0																																																																																						
																																																																																																
	endif																																																																																																	
[state]	chgr-shutdownsend			组停机发送指令								#																																																																																				
#tag	command											#																																																																																				
	#关机
	#log	"停机gun="	gun	
	var	i	0
	do	while	var	i	<	mp	chgr.PerGunNum	#设定电压、电流		
			
		var	UID	(	0x9307C080	|	(	mpofs	chgr.GunAddr	var	i	)	)				#关机 																																																																						
		var	UID	var	UID	|	0x80000000	
		var	len	8
		varsz	dt	8
		vardt	dt	0	8	0			
		vardt	dt	0	1	2	
		vardt	dt	7	1	0xAA	#关机指令	
		canwr	chgr.state			addr	UID		
		add	var	i	1
	loop
[state]	chgr-stateask			通讯检查发送								#																																																																																				
#tag	command											#																																																																																				
	var	i	0	
	#log	"chgr.Num="	mp	chgr.Num
	do	while	var	i	<	mp	chgr.Num	
		#log	"通讯检查发送="	%x	var	i
		var	UID	(	0x9307C080	|	(	var	i	+	1	)	)				#轮询查看 																																																																						
		var	UID	var	UID	|	0x80000000	
		var	len	8
		varsz	dt	8
		vardt	dt	0	8	0			
		vardt	dt	0	1	1	
		canwr	chgr.state			addr	UID																																																																																														
		#log	"通讯检查发送="	%x	var	UID																																																																																														
		add	var	i	1																																																																																											
	loop																																																																																																
[state]	chgr-statechk			通讯检查								#	2s一次																																																																																			
#tag	command											#																																																																																				
	call	chgr-stateask	
	
	if	mp	chgr.littleC		=	2																																																																																										
		add	mp	chgr.openModCnt		1																																																																																										
	endif																																																																																															
	#log	"char.Num="		%d	mp	chgr.Num																																																																																										
	#log	"center.chgrPerPile="			%d	mp	center.chgrPerPile																																																																																									
	#log	"center.pileNum="			%d	mp	center.pileNum																																																																																									
	var	i	0		
	do	while	var	i	<	mp	chgr.Num																																																																																													
		add	mpofs	chgr.commCount	var	i	1 
		#log	"i="	var	i
		if	mpofs	chgr.commCount			var	i	>=	5																																																																																						
			mpofs	chgr.commCount			var	i	5																																																																																													
			mpofs	chgr.commDown		var	i	1
			#log	"通讯中断模块号="	var	i	
			or	mp	center.alarmComm					(	0x01	<<	(	(	mpofs	chgr.addr	var	i	)	+	7	)	)	#	相应位置1有报警																																																																							
																																																																																																
			#log	"chgr-statechk---------mold timeout----modl ID:"								%d	var	i	+	1																																																																																
																																																																																																
			if	mp	center.chgStatus			<	const	st-charge																																																																																						
				&	mp	center.chgStatus		!=	const	st-standby																																																																																						
				mp		center.fatal		8					#启机中模块离线																																																																																			
			endif																																																																																													
																																																																																																
		else																																																																																														
			mpofs	chgr.commDown		var	i	0																																																																																								
			and	mp	center.alarmComm				not	(	0x01	<<	(	(	mpofs	chgr.addr	var	i	)	+	7	)	)	#	相应位置0无报警																																																																							
		endif																																																																																														
		add	var	i	1																																																																																											
	loop																																																																																															
																																																																																																
[state]	chgr-timeout											#																																																																																				
	log	"超时"																																																																																															
	statemp		chgr.state			chgr-shutdown			0	#	充电机停机中解帧																																																																																						
	statemp		chgr.state-tmo1			chgr-shutdownsend			-1000	#	chgr.state-tmo1			为发送tmr																																																																																		
	statemp		chgr.state-tmo			chgr-stoptimeout			13000	#	超时																																																																																					
																																																																																																
[state]	chgr-sendstatechk			组帧：轮询发送查询状态指令								#																																																																																				
																																																																																																
	#call	chgr-statechk	
	#log	"轮询组帧center.ruiflag="	mp	center.ruiflag	
	#直流输出电压查询																																																																																															
																																																																																						
	var	modID			(	mp	chgr.checkModID			+	1	)																																																																																				
	var	UID	0																																																																																													
	var	UID	(	0x9307C080			|	(	var	modID				)	)																																																																																
	#log	"CHGR---------chgr.checkModID:"					mp	chgr.checkModID			" , "		mp	chgr.Num	" , "	var	modID	" , "	%x	(	var	modID			<<	16	)																																																																						

	var	len	8				#数据包长度																																																																																										
	varsz	dt	8																																																																																													
	vardt	dt	0	8	0																																																																																											
	var	dt	0x01																																																																																													
																																																																																																
	canwr	chgr.state			addr	UID																																																																																										
																																																																																																
																																																																																									
	#call	chgr-comrecv																																																																																															
#	var	UID	(	0x868082FE		|	(	var	modID			<<	16	)	)																																																																																	
																																																																																																
#	var	len	8																																																																																													
#	vardt	dt	0	8	0																																																																																											
#	var	dt	0x7601																																																																																													
																																																																																																
#	canwr	chgr.state			addr	UID																																																																																										
	#log		"chgr.Num="		mp	chgr.Num																																																																																														
	if	mp	chgr.checkModID			<	(	mp	chgr.Num		-	1	)																																																																																			
																																																																																																
		add	mp	chgr.checkModID			1																																																																																									
																																																																																																
	else																																																																																															
		mp	chgr.checkModID			0																																																																																										
	endif																																																																																															
																																																																																																
																																																																																																
[state]	chgr-checkchgrState			检查模块状态								#																																																																																				
																																																																																																
	var	i	0																																																																																													
	var	rtn	0																																																																																													
	do	while	var	i	<	mp	chgr.Num																																																																																									
																																																																																																
		if	mpofs	chgr.errorState			var	i	!=	0																																																																																						
																																																																																																
			var	rtn	1																																																																																											
			log	"CHGR-------chgr Error ID:"				%d	var	i	+	1	",ErrorData"		%d	mpofs	chgr.errorState		var	i																																																																												
		endif																																																																																														
																																																																																																
		add	var	i	1																																																																																											
	loop																																																																																															
																																																																																																
[state]	chgr-stoptimeout			停机超时								#																																																																																				
	log	"停机超时"																																																																																															
	statemp		chgr.state			chgr-standby			0	#																																																																																						
	statemp		chgr.state-tmo1			idle			0																																																																																							
	statemp		chgr.state-tmo			idle			0	#	超时tmr置0																																																																																					
#tag	command																																																							
																																																											
																																																											
#tag	command																																																																																																				
[state]	bms-main-tmo	充电超时		5s								#																			
#tag	command												#																			
	#log	"time out"											#																			
	log	"充电超时center.state="	mp	center.state
																																
	#发送CEM																															
	if	mp	center.state		=	state	bms-handshake																									
		mp	bms.CEM		0xFCC0F0FD		#BRM超时																									
		mp	bms.CEMReason		0xFCC0F0FD																											
	elseif	mp	center.state		=	state	bms-parm																									
		mp	bms.CEM		0xFCC0F1FC		#BCP超时																									
		mp	bms.CEMReason		0xFCC0F1FC																											
	elseif	mp	center.state		=	state	bms-req-assist																									
		|	mp	center.state		=	state	bms-to-ready																								
		mp	bms.CEM		0xFCC0F4FC		#BRO AA超时																									
		mp	bms.CEMReason		0xFCC0F4FC																											
	elseif	mp	center.state		=	state	bms-wait-BCS																									
		mp	bms.CEM		0xFCC1F0FC		#BCS超时																									
		mp	bms.CEMReason		0xFCC1F0FC																											
	elseif	mp	center.state		=	state	bms-charging																									
		if	mp	bms.CEMReason		=	0xFCC1F0FC																									
			mp	bms.CEM		0xFCC1F0FC		#BCL超时																								
			mp	bms.CEMReason		0xFCC1F0FC																										
		else																														
			mp	bms.CEM		0xFCC4F0FC		#BCL超时																								
			mp	bms.CEMReason		0xFCC4F0FC																										
		endif																														
																																
																																
	elseif	mp	center.state		=	state	bms-stopping																									
		mp	bms.CEM		0xFCD0F0FC		#BST超时																									
		mp	bms.CEMReason		0xFCD0F0FC																											
	elseif	mp	center.state		=	state	bms-statistics																									
		mp	bms.CEM		0xFDC0F0FC		#BSD超时																									
		mp	bms.CEMReason		0xFDC0F0FC																											
	endif																															
	call	bms-err																														
[state]	bms-err	bms出错（超时或收到BEM）处理																											
	log	"bms出错（超时或收到BEM）处理"
	statemp		center.staTmo1			idle	0						#	停止超时timer																		
	statemp		center.staTmo2			idle	0						#	停止发送timer																		
	statemp		center.staChk			idle	0						#	检查状态初始化																		
	if	1			#	mp	bms.reConctTime			>=	3		#重连次数大于3次，正常返回待机																			
																																
		if	mp	bms.BEM	!=	0		#收到BEM																								
			mpofs	center.stopReason		0	const	sr-bms-err		#BMS端出现错误																			
		else																														
			mpofs	center.stopReason		0		const	sr-bms-tmo		#BMS超时错误																			
		endif																														
		if	mp	center.chgStatus			<	const	st-stop					#	状态小于停机中																	
			mp	center.chgStatus			const	st-stop						#	设充电状态为停机中																	
			statemp	acb.state		mini	-1000							#	通知acb流程停机处理，为了试验																	
		endif																														
		if	mp	chgr.status		!=	const	chgr-mode-standby						#	非已停机状态																	
			mp	chgr.status		const	chgr-mode-stop							#	指令停机																	
			call	mp	chgr.state									#	调用充电机流程,通知其停机																	
		endif																														
		state	bms-err-stop		-1000									#	等待停机																	
																																
	else		#重连																													
		add	mp	bms.reConctTime			1							#重连次数加1																		
		mpofs	center.stopReason		0	const	sr-tmo-retry				#BMS端出现超时重连错误																		
		if	mp	center.chgStatus			<	const	st-stop					#	状态小于停机中																	
			mp	center.chgStatus			const	st-stop						#	设充电状态为停机中																	
			statemp	acb.state		mini	-1000							#	通知acb流程停机处理，为了试验																	
		endif																														
		if	mp	chgr.status		!=	const	chgr-mode-standby						#	非已停机状态																	
			mp	chgr.status		const	chgr-mode-stop							#	指令停机																	
			call	mp	chgr.state									#	调用充电机流程,通知其停机																	
		endif																														
		statemp	center.staTmo2		bms-tmo-stop-send			const	bms-send					#	发送错误帧																	
		state	bms-tmo-stop		-1000									#	等待停机																	
																																
																																
	endif																															
																																
[state]	bms-err-stop	bms出错（超时或收到BEM）停机等待																											
	log	"bms出错（超时或收到BEM）停机等待,原因："	mp	chgr.status	
	
	if	mp	chgr.status		=	const	chgr-mode-standby						#	充电模块已停机																		
	#	mp	center.setTime			1							#	设置充电结束时间																		
		call	bms-forCheckout										#	结账准备																		
	endif												#																			
[state]	bms-tmo-stop	超时重连停机等待																											
	log	"超时重连停机等待"
	if	mp	chgr.status		=	const	chgr-mode-standby						#	充电模块已停机																		
		mp	center.chgStatus			const	st-stopped							#	设充电状态为停机中																	
		state	bms-wait-retry		-1000								#	等待绝缘检测完成																		
	endif																															
[state]	bms-tmo-stop-send	错误帧CEM发送																											
	log	"错误帧CEM发送"
																																
	mp	bms.CEM		mp	bms.CEMReason		#发送超时错误帧																									
																																
[state]	bms-wait-retry	等待绝缘检测成功																											
	log	"等待绝缘检测成功"
	if	mp	center.chgStatus		=	const	st-insulok						#	等待绝缘检测完成状态																		
		#log	"bms-wait-retry insulok"																													
		statemp	center.staTmo2		idle		0						#复位定时发送																			
		call	bms-chm-tmo										#跳到CRM发送																			
	endif												#																			
																																
																																
[state]	bms-standby	待机										#																			
#tag	command												#																			
#	log	"BMS待机="	gun
	if	mp	center.chgStatus			=	const	st-handshake					#	充电状态为握手																		
		mp	bms.BEM		0	#	初始化BEM																									
		mp	bms.BST		0	#	初始化BST																									
		mp	bms.BRM		0	#	初始化BRM为0																									
		mp	bms.BHM		0	#	初始化																									
		mpc	bms.CHM		0	#	发送																									
		mp	acb.startStatus		1																											
		mp	bms.reConctTime		0	#	初始化重连次数为0																									
		statemp	center.staTmo1			bms-main-tmo			const	bms-tmo			#																			
		statemp	center.staTmo2			bms-chm-send			const	bms-send			#	设置超时timer，5s																		
		statemp	center.staTmo3			bms-both-send			3000				#	停止timer																		
		state	bms-chm-crm		0																											
	endif																															
																																
[state]	bms-both-send	#																			
#	log	"bms-both-send"
	statemp	center.staTmo1			bms-main-tmo			const	bms-tmo			#																				
	statemp	center.staTmo2			bms-chm-crm-send			const	bms-send			#	设置超时timer，5s																			
	statemp	center.staTmo3			idle			0				#	停止timer																			
[state]{lock}	bms-chm-crm	握手，等待收到BHM或CRM后触发										#																			
	log	"bms-chm-crm握手"	
	if	(	canid	&	0xFF0000	)	=	0x270000					#	收到BRM																		
		mp	bms.maxReqV		candt	0	2																									
	endif
	log	"BmsReqV"	mp	bms.maxReqV
	if	mp	bms.BHM	=	1								#	未收到BRM																		
		mp	center.bms_version			15								#	bms版本																	
		statemp	center.staTmo1			bms-main-tmo			const	bms-tmo				#	设置超时timer，5s																	
		statemp	center.staTmo2			bms-chm-send			const	bms-send			#	设置超时timer，5s																		
		statemp	center.staTmo3			bms-insulfin-timo			30000					#	绝缘检测超时																	
		statemp	center.staChk			bms-wait-insulfin			1000																							
		state	bms-wait-insulfin		0																											
																																
		if	<<insul-15>>																													
			mp	center.chgStatus		const	st-insul																									
		endif																														
																																
		mp	bms.BEM		0									#	初始化BEM																	
		mp	bms.BST		0									#	初始化BST																	
		mp	bms.BRM		0									#	初始化BRM为0																	
	endif												#																			
													#																			
[state]	bms-insulfin-timo	发送chm		250ms							#																			
#tag	command																															
	log	"bms-insulfin-timo"
	mpofs	center.stopReason		0	const	sr-insult-tmo		#绝缘检测超时
	statemp	center.staTmo3			idle			0				#	停止timer																				
	call	bms-main-tmo																														
																																
[state]	bms-chm-crm-send	发送chm		250ms							#																			
#tag	command												#																			
	log	"发送bms-chm-crm-send"
	mp	bms.CHM		1									#	发送																		
	mp	bms.CRM		0									#	发送充电机识别报文:00																		
																																
[state]	bms-chm-send	发送chm		250ms							#																			
#tag	command												#																			
	#log	"发送chm"
	mp	bms.CHM		1									#	发送																		
																																
[state]	bms-wait-insulfin	等待绝缘检测完成		250ms							#																			
#tag	command												#																			
	#log	"BMS等待绝缘检测完成="	mp	center.chgStatus
																																
	if	<<insul-15>>																														
		if	mp	center.chgStatus		=	const	st-insulok					#	未收到BRM																		
			log	"BMS等待 绝缘检测完成 成功！！！！！"																												
			call	bms-chm-tmo																												
			return										#																			
																																
		elseif	mp	center.chgStatus			>=	const	st-stop				#	充电状态为停机中
			log	"等待绝缘检测完成 失败！！！！！="	mp	center.chgStatus																												
			
			statemp	center.staTmo1			idle			0			#	清空定时器																		
			statemp	center.staTmo2			idle			0			#	清空定时器																		
			statemp	center.staTmo3			idle			0			#	清空定时器																		
			statemp	center.staChk			idle			0			#	清空定时器																		
			state	bms-err-stop		-1000							#	等待停机																		
		endif											#	回到待机状态，间隔也恢复																		
	else																															
		#log	"跳过insulok 绝缘检测完成"										#	未收到BRM																		
		call	bms-chm-tmo																													
		return																														
	endif																															
																																
	lock	bms.BHM																														
	if	mp	bms.BHM	!=	1								#	未收到BRM																		
		unlock	bms.BHM																													
	else												#	收到BRM																		
		unlock	bms.BHM																													
		mp	bms.BEM		0									#	初始化BEM																	
		mp	bms.BST		0									#	初始化BST																	
		mp	bms.BRM		0									#	初始化BRM为0																	
		statemp	center.staTmo1			bms-main-tmo			const	bms-tmo				#	设置超时timer，5s																	
	endif												#																			
																																
																																
[state]	bms-chm-tmo	超时跳到CRM		250ms							#																			
#tag	command												#																			
#	mp	bms.bmsVer		2011																												
	log	"超时跳到CRM"
#	mp	center.chgStatus				const	st-piles						#	收到BHM后,将充电状态置为"绝缘检测"																		
	mp	bms.BEM		0									#	初始化BEM																		
	mp	bms.BST		0									#	初始化BST																		
	mp	bms.BRM		0									#	初始化BRM为0																		
	statemp	center.staTmo1			bms-main-tmo			const	bms-tmo				#	设置超时timer，5s																		
	statemp	center.staTmo2			bms-handshake-send			const	bms-send				#	设置循环发送timer																		
	statemp	center.staTmo3			idle			0					#	设置循环发送timer																		
	statemp	center.staChk			idle			0																								
	state	bms-handshake		0									#																			
	mp	bms.CEMReason			0xFCC0F0FD		#BRM超时																									
																																
																																
[state]	bms-config	充电配置										#																			
#tag	command												#																			
	log	"充电配置"
	if	mp	center.chgStatus			=	0						#	充电状态，0：初始状态，1：认证通过，2：配置完成，准备充电，3：停止充电																		
		state	bms-standby		1000								#																			
	else	if	mp	center.chgStatus			=	const	st-configed				#	配置完成，准备充电																		
			mp	bms.BRM		0							#	初始化BRM为0																		
			mp	bms.CRM		0							#	发送充电机识别报文:00																		
			statemp	center.staTmo1		bms-main-tmo			const	bms-tmo			#	设置超时timer，5s																		
			statemp	center.staTmo2		bms-handshake-send			const	bms-send			#	设置循环发送timer																		
			state	bms-handshake		0							#																			
		endif																														
	endif												#																			
													#																			
[state]	bms-handshake	握手，等待收到BRM后触发										#																			
#tag	command												#																			
	log	"握手，等待收到BRM后触发"
	if	mp	bms.BEM	!=	0	call	bms-err		return	endif			#	收到BEM，错误包																		
																																
#	将来加入mp初始化，处理相关测点																															
	#log	"handshake"																														
	lock	bms.BRM																														
	if	mp	bms.BRM	!=	1								#	未收到BRM																		
#		mp	bms.CRM		0								#	发送充电机识别报文:00																		
		unlock	bms.BRM																													
	else												#	收到BRM																		
		mp	bms.BRM		0								#	重置BRM为0																		
		unlock	bms.BRM																													
		mp	bms.BCP		0								#	初始化BCP为0																		
		statemp		center.staTmo1			bms-main-tmo		const	bms-tmo			#	设置超时timer，5s																		
		statemp		center.staTmo2			bms-parm-send		const	bms-send			#	设置循环发送timer																		
		state	bms-parm		0								#	等待充电参数																		
		mp	bms.CRM		170								#	发送充电机识别报文:AA																		
		#log	"recv BRM"																													
	endif												#																			
													#																			
[state]	bms-handshake-send	握手循环发送		250ms							#																			
#tag	command												#																			
#	log	"握手循环发送"
	mp	bms.CRM		0									#	发送充电机识别报文:00																		
													#																			
[state]	bms-parm	充电参数报文等待，收到BCP触发										#																			
#tag	command												#																			
#	log	"充电参数报文等待，收到BCP触发"
	if	mp	bms.BEM	!=	0	call	bms-err		return	endif			#	收到BEM，错误包																		
	lock	bms.BCP																														
	#log	"BCP:"	mp	bms.BCP		"===CAN ID===:"		%x	canid																							
	if	mp	bms.BCP		=	0							#	未收到BCP																		
#		mp	bms.CRM	170									#	发送充电机识别报文:AA																		
		unlock	bms.BCP																													
	else												#	收到BCP																		
		unlock	bms.BCP																													
		if	(	canid	&	0xFF0000		)	=	0xEB0000			#	TPDT，多包数据																		
			var	mc	mp	bms.BCP																										
			mp	bms.maxReqC		4000	-	vardt	ptr	mc	2	2																				
			mp	bms.maxReqV		vardt	ptr	mc	6	2																						
		endif																														
		log	"recv BCP-C:"		mp	bms.maxReqC																										
		log	"recv BCP-V:"		mp	bms.maxReqV																										
																																
		statemp		center.staTmo1			idle	0					#	清空timer																		
		statemp		center.staTmo2			idle	0					#	清空timer																		
		state	bms-req-assist			mini							#	请求辅助																		
		call	mp	pile.pile-state									#	调用piles流程,要在最后运行此句,不然无辅桩时,会马上回调,引发错误																		
	endif												#																			
													#	回到待机状态，间隔也恢复																		
													#																			
[state]	bms-parm-send	参数等待循环发送			250ms							#																			
#tag	command												#																			
	#log	"参数等待循环发送"
	mp	bms.CRM		170									#	发送充电机识别报文:AA																		
													#																			
[state]	bms-req-assist	请求辅桩										#																			
#tag	command												#																			
#	log	"请求辅桩"
	if	mp	bms.BEM	!=	0	call	bms-err		return	endif																						
	if	1		#无多桩，永真									#	辅桩确定																		
		#log	"piles ok"																													
		mp	bms.BCP		0								#	重置BCP为0，由于有多桩流程，此测点一直未重置																		
		mp	bms.BRO		-1								#	电池准备就绪，00：未准备好，AA：准备完成，FF：无效,-1:未收到BRO																		
		statemp		center.staChk			bms-main-tmo		const	bms-bro-tmo																						
		statemp	center.staTmo1			bms-main-tmo			const	bms-tmo			#	设置超时timer，5s																		
		statemp	center.staTmo2			bms-to-ready-send			const	bms-send			#	设置循环发送timer																		
		state	bms-to-ready		0								#	等待充电参数																		
		mp	bms.CTS		1	mp	bms.CML		1				#	发送充电机时间同步报文及最大输出能力报文（CML）																		
		mp	bms.CEMReason			0xFCC0F4FC		#BRO AA超时					#																			
		#call	acbc-getPile																													
	elseif	mp	center.chgStatus			=	const	st-stop					#	充电状态为停机中,说明辅桩请求过程中有错误或告警																		
	#	|	mp	bms.BST	=	1							#	BMS发送停止指令																		
#		state	charging		mini								#	充电阶段,并马上运行一次,其实是调用此状态的充电结束处理																		
		call	bms-charging																													
	endif												#																			
																																
[state]	bms-to-ready-tmo	等待bms完成充电准备,强行下一结点									#																			
#	mp	center.setTime			0						#		设置充电开始时间																			
	log	"等待bms完成充电准备,强行下一结点"
	mp	bms.BCS			0						#		重置																			
	statemp	center.staTmo1			bms-main-tmo		const	bms-tmo		#	设置超时timer，5s																					
	statemp	center.staTmo2			bms-wait-BCS-send		const	bms-send		#	设置循环发送timer																					
	state	bms-wait-BCS			0						#		等待bms充电总状态																			
	mp	bms.CRO			170						#		发送充电机准备完成																			
																																
[state]	bms-to-ready	等待bms完成充电准备，收到BRO触发										#																			
#tag	command												#																			
#	log	"等待bms完成充电准备，收到BRO触发"
	if	mp	bms.BEM	!=	0	call	bms-err		return	endif																						
	if	mp	center.chgStatus			=	const	st-stop					#	充电状态为停机中																		
		call	bms-charging																													
		return																														
	endif																															
	lock	bms.BRO																														
	if	mp	bms.BRO		=	-1							#	未收到BRO,bms ready																		
#		mp	bms.CTS	1									#	发送充电机时间同步报文及最大输出能力报文（CML）																		
		#log	"BRO=-1"																													
		unlock	bms.BRO																													
	elseif	mp	bms.BRO		=	0			#永假,临时				#	收到BRO,未准备好																		
		statemp	center.staTmo1			bms-main-tmo			const	bms-tmo			#	设置超时timer，5s																		
		mp	bms.BRO		-1								#	重置，-1：未收到BRO																		
		unlock	bms.BRO																													
		#log	"recv BRO 00"																													
	elseif	mp	bms.BRO		=	170							#	收到BRO,AA:准备完成																		
#		mp	bms.BRO		-1								#	不重置，屏蔽掉之后的BRO																		
		unlock	bms.BRO																													
		mp	center.chgStatus				const	st-start					#	切换成起机中,通知acb流程,和开关,起机																		
		#log	"recv BRO AA"										#																			
		if	1	#mp	chgr.status		=	const	chgr-mode-charging				#	充电模块已启机																		
		#	mp	center.setTime			0							#	设置充电开始时间																	
			statemp	center.staTmo1			bms-main-tmo		60000				#	设置超时timer，5s																		
			statemp	center.staTmo2			bms-wait-switch-on-send			const	bms-send		#	设置循环发送timer																		
			statemp	center.staChk			idle	0						#	检查状态初始化																
			state	bms-wait-switch-on			1000							#	等待bms充电总状态																	
		elseif	mp	center.staTmo2		!=	state	bms-to-ready-tmo					#	已收到AA，未设置强行跳转timer																		
		#	statemp		center.staTmo2			idle	0				#	已经收到BRO AA,不再发送CTS与CML																		
			statemp		center.staTmo2			bms-to-ready-tmo			3000		#	已经收到BRO AA,3s后强行下一结点																		
		endif																														
	else																															
		unlock	bms.BRO																													
	endif												#	回到待机状态，间隔也恢复																		
													#																			
[state]	bms-to-ready-send	等待bms完成充电准备，循环发送						250ms			#																			
#tag	command												#																			
	#log	"等待bms完成充电准备，循环发送"
	mp	bms.CTS		1		mp	bms.CML		1				#	发送充电机时间同步报文及最大输出能力报文（CML）																		
	#log	"send CTS"											#																			
													#																			
[state]	bms-wait-switch-on	等待输出接触器闭合						250ms			#																			
#tag	command												#																			
	#log	"等待输出接触器闭合="	mp	center.chgStatus
																																
	if	mp	center.chgStatus			=	const	st-charge					#	等待充电中表示K12合																		
																																
	#	mp	center.setTime			0							#	设置充电开始时间																		
		mp	bms.BCS			0							#	重置																		
		statemp	center.staTmo1			bms-main-tmo		const	bms-tmo			#	设置超时timer，5s																			
		statemp	center.staTmo2			bms-wait-BCS-send		const	bms-send			#	设置循环发送timer																			
		statemp		center.staChk			idle	0						#	检查状态初始化																	
		state	bms-wait-BCS			0							#	等待bms充电总状态																		
		mp	bms.CRO			170							#	发送充电机准备完成																		
	elseif	mp	center.chgStatus			=	const	st-stop					#	充电状态为停机中																		
	#	|	mp	bms.BST	=	1							#	BMS发送停止指令																		
#		state	charging		mini								#	充电阶段,并马上运行一次,其实是调用此状态的充电结束处理																		
		call	bms-charging																													
	endif												#	回到待机状态，间隔也恢复																		
																																
[state]	bms-wait-switch-on-send	发送CRO 00						250ms			#																			
#tag	command												#																			
#	log	"发送CRO"
	mpc	bms.CRO		0									#	发送CRO 00																		
													#																			
[state]	bms-wait-BCS	等待bms充电总状态包，收到BCS触发										#																			
#tag	command												#																			
#	log	"等待bms充电总状态包，收到BCS触发"
	if	mp	bms.BEM	!=	0	call	bms-err		return	endif																						
	lock	bms.BCS																														
	if	mp	center.chgStatus			=	const	st-stop					#	充电状态为停机中																		
	#	|	mp	bms.BST	=	1							#	BMS发送停止指令																		
#		state	charging		mini								#	充电阶段,并马上运行一次,其实是调用此状态的充电结束处理																		
		unlock	bms.BCS																													
		call	bms-charging																													
	elseif	mp	bms.BCS		!=	1							#	未收到BCS,bms charge status																		
		|	mp	bms.BCL		!=	1																									
#		mp	bms.CRO		170								#	发送充电机准备完成报文																		
		unlock	bms.BCS																													
	else												#	收到BCS																		
		mp	bms.BCS		0								#	重置																		
		unlock	bms.BCS																													
		mp	bms.BST		0								#	重置																		
		statemp	center.staTmo1			bms-charging-tmo			const	bms-chgtmo			#	设置超时timer，100ms																		
		statemp	center.staTmo3			bms-charging-tmo-bcs			const	bms-tmo			#	设置超时timer，100ms																		
		statemp	center.staTmo2			bms-charging-send			const	bms-chgsend			#	设置循环发送timer																		
		state	bms-charging		0								#	充电进行状态																		
	#	lock	bms.BCL										#	收到BCL,充电需求																		
		mp	bms.BCL		0								#	重置																		
	#	unlock	bms.BCL										#	收到BCL,充电需求																		
		mp	bms.CCS		1								#	发送充电机状态																		
		#log	"recv BCS"										#																			
	endif												#																			
													#																			
[state]	bms-wait-BCS-send	BCS等待循环发送				250ms			#																			
#tag	command												#																			
#	log	"BCS等待循环发送"
	mp	bms.CRO		170									#	发送充电机准备完成报文																		
	#log	"send CRO"											#																			
													#																			
[state]	bms-charging	充电状态										#																			
#tag	command												#																			
#	log	"bms充电状态"	gun	
	if	mp	bms.BEM	!=	0	call	bms-err		return	endif																						
#	lock	bms.BCL											#	收到BCL,充电需求																		
	if	mp	bms.BCL	=	1								#	收到BCL,充电需求
		if	(	canid	&	0xFF0000		)	=	0x100000			#	BST																		
			mpdt	bms.dBCL		0	5		candt	0	5																					
		endif																														
		statemp	center.staTmo1		bms-charging-tmo			const	bms-chgtmo				#	重设超时时间																		
		mp	bms.BCL		0								#	重置																		
#		log	"recv BCL:"		mp	bms.reqV		","	mp	bms.reqC																						
																																
		if	(	mp	center.chgStatus		>	const	st-start	)																						
			&	(	mp	center.chgStatus		<	const	st-stop	)																					
																																
			var	old-reqV		mp	chgr.reqV							#	保存原来的充电需求																	
			var	old-reqC		mp	chgr.reqC																									
																																
			if	mp	bms.reqV	>	mp	center.maxOutV					#	超出额定输出电压																	
				mp	chgr.reqV	mp	center.maxOutV	*	100
			else
				mp	chgr.reqV		mp	bms.reqV	*	100		#BMS上送的均为电压10倍,chgr下发需要按mv单位下发 *100																								
			endif																													
			if	mp	chgr.reqV	>	mp	bms.maxReqV	*	100	
				mp	chgr.reqV	mp	bms.maxReqV	*	100																								
			endif																													
																																
#			log	"bms outV:"		mp	center.ratedOutV		"-"	mp	bms.maxReqV		"-"	mp	chgr.reqV																	
																																
			mp	chgr.reqC		mp	bms.reqC	*	100																									
			var	rc	mp	center.ratedOutC			*	mp	center.chgrPerPile			*	mp	center.usedPileNum																
																																
			if	mp	chgr.reqC		>	var	rc	*	100																							
				mp	chgr.reqC		var	rc	*	100																									
			endif																													
																																
		#	#计算充电桩实际可能的最大输出电流																													
		#	#var	rc	mp	center.ratedOutC			*	mp	center.chgrPerPile			*	mp	center.usedPileNum																
		#	call	acbc-reComputerOutputI																												
		#	var	rc	mp	center.actualI																										
		#																														
		#	if	mp	bms.reqC		>	var	rc					#	超出额定输出电流																	
		#		mp	chgr.reqC		var	rc																								
		#	else																													
		#		mp	chgr.reqC		mp	bms.reqC																								
		#	endif																													
		#重新配置充电模块数量	
			var	isLinkA	mp	a.acb.linkCarState	&	0x01	
			var	isLinkB	mp	b.acb.linkCarState	&	0x01	
			var	isBothLink	0	
		if	mp	center.isDoubleGun	=	1
			if	(	var	isLinkA	=	0x01	)	&&	(	var	isLinkB	=	0x01	)	#A、B枪均连接
				mp	a.chgr.PerGunNum		2							#	A枪占用模块数量																																								
				mp	b.chgr.PerGunNum		2							#	B枪占用模块数量																																								
				mpofs	a.chgr.GunAddr		0	1						#	A枪模块地址寄存器																																								
				mpofs	a.chgr.GunAddr		1	2						#	A枪模块地址寄存器																																							
				mpofs	b.chgr.GunAddr		0	3						#	B枪模块地址寄存器																																								
				mpofs	b.chgr.GunAddr		1	4						#	B枪模块地址寄存器																																																																																												
				mp	center.chgrPerPile		2							#	每个桩2个充电模块
				mp	a.center.chargeType		1
				var	isBothLink	1	
			elseif	(	var	isLinkA	=	0x01	)	&&	(	var	isLinkB	!=	0x01	)	#A枪连接
				mp	a.chgr.PerGunNum		4							#	A枪占用模块数量																																								
				mp	b.chgr.PerGunNum		0							#	B枪占用模块数量																																								
				mpofs	a.chgr.GunAddr		0	1						#	A枪模块地址寄存器																																								
				mpofs	a.chgr.GunAddr		1	2						#	A枪模块地址寄存器																																							
				mpofs	a.chgr.GunAddr		2	3						#	B枪模块地址寄存器																																								
				mpofs	a.chgr.GunAddr		3	4						#	B枪模块地址寄存器																																																																																												
				mp	center.chgrPerPile		4							#	每个桩2个充电模块
				mp	a.center.chargeType		0
			elseif	(	var	isLinkA	!=	0x01	)	&&	(	var	isLinkB	=	0x01	)	#B枪连接
				mp	a.chgr.PerGunNum		0							#	A枪占用模块数量																																								
				mp	b.chgr.PerGunNum		4							#	B枪占用模块数量																																								
				mpofs	b.chgr.GunAddr		0	1						#	A枪模块地址寄存器																																								
				mpofs	b.chgr.GunAddr		1	2						#	A枪模块地址寄存器																																							
				mpofs	b.chgr.GunAddr		2	3						#	B枪模块地址寄存器																																								
				mpofs	b.chgr.GunAddr		3	4						#	B枪模块地址寄存器																																																																																												
				mp	center.chgrPerPile		4							#	每个桩2个充电模块
				mp	a.center.chargeType		0
			endif
		elseif	mp	center.isDoubleGun	=	0
			mp	a.chgr.PerGunNum		4							#	A枪占用模块数量																																								
			mp	b.chgr.PerGunNum		0							#	B枪占用模块数量																																								
			mpofs	a.chgr.GunAddr		0	1						#	A枪模块地址寄存器																																								
			mpofs	a.chgr.GunAddr		1	2						#	A枪模块地址寄存器																																							
			mpofs	a.chgr.GunAddr		2	3						#	B枪模块地址寄存器																																								
			mpofs	a.chgr.GunAddr		3	4						#	B枪模块地址寄存器																																																																																												
			mp	center.chgrPerPile		4							#	每个桩2个充电模块
			mp	a.center.chargeType		1
		endif
		
			call	acbc-linkSwitchState
			var	isCommLinkOn	var	rtn	
			if	mp	a.center.chargeType	=	0	&&	var	isCommLinkOn	=	0
				call	acbc-openLinkSwitch	#合母联
			#	log	"1111设置充电模块输出电压和输出电流+chgr.reqV"	mp	chgr.reqV	"++"	mp	bms.maxReqV	"++"	mp	center.ratedOutV	#	J2.设置充电模块输出电压和输出电流	
				call		acbc-startChargerModule																#	启动充电模块				
			endif

			if	mp	chgr.reqC		>	mp	bms.maxReqC	*	100																							
				mp	chgr.reqC		mp	bms.maxReqC	*	100																								
			endif																													
																																
			#log	"bms outC:"		var	rc		"-"	mp	bms.reqC		"-"	mp	chgr.reqC																	
																																
			if	var	old-reqV		!=	mp	chgr.reqV					#	检查充电需求是否变化																	
				mp	bms.newReqV		1																									
			endif																													
			if	var	old-reqC		!=	mp	chgr.reqC																							
				mp	bms.newReqC		1																									
			endif																													
			if	mp	bms.newReqV		=	1	|																							
				mp	bms.newReqC		=	1																								
				call	chgr-startupsend																											
				mp	bms.newReqV		0																									
				mp	bms.newReqC		0																									
			endif																													
		endif																														
	endif												#																			
	if	mp	bms.BCS	=	1								#	收到BCS																		
		statemp		center.staTmo3			bms-charging-tmo-bcs			const	bms-tmo		#	重设超时时间																		
		mp	bms.BCS		0								#	重置																		
		#log	"recv BCS"																													
	endif												#																			
																																
#	unlock	bms.BCL											#	收到BCL,充电需求																		
	if	mp	bms.BST	=	1	|	mp	bms.BEM	!=	0			#	收到BST或BEM,stop																		
		if	(	canid	&	0xFF0000		)	=	0x190000			#	BST																		
			mpdt	bms.dBST		0	4		candt	0	4																					
		endif																														
#		mp	bms.BST		0								#	这里不能重置,跟流程有关!!!																		
		#log	"BSM recv BST or BEM:"			%08x	candt	0	4	","	mp	bms.BEM																				
		if	(	canid	&	0xFF0000		)	=	0x190000			#	BST																		
			var	bst	candt	0	1																									
			if	(	var	bst	&	3	)	=	1	|	#	01表示达到soc目标:充满																		
				(	var	bst	&	0x0C	)	=	4	|	#	01表示达到总电压目标:充满																		
				(	var	bst	&	0x30	)	=	0x10		#	01表示达到单体电压目标:充满																		
				mpofs	center.stopReason		0		const	sr-bms-ok		#充满,BMS提出中止																		
			else																													
				mpofs	center.stopReason		0		const	sr-bms-err		#BMS端出现错误																		
			endif																													
		else											#	BEM																		
			mpofs	center.stopReason			0	const	sr-bms-err		#	BMS端出现错误																		
		endif																														
		mp	bms.stopReason			0	#回应BST,没原因	
		mp	center.chgStatus				const	st-stop					#	充电状态:停机中																		
		goto	charging-stop										#																			
	endif												#																			
	if	mp	center.chgStatus			=	const	st-stop					#	刷卡结束充电或告警																		
		if	mp	center.alarmStatus			!=	0	#有告警																							
		#	mp	bms.stopReason			0x040010		#回应BST,故障中止																							
			if	(	mp	center.alarmComm			&	0x01	)	=	0x01		#急停故障																	
				mp	bms.stopReason			0xf0f10010		#停止原因，急停故障																						
			else																													
				mp	bms.stopReason			0xf0f40010		#停止原因，其他故障																						
			endif																													
		else																														
			mp	bms.stopReason			0xf0f00004		#回应BST,人工中止																							
		endif																														
		#log	"BMS find stop status!"																													
		goto	charging-stop										#																			
	endif												#																			
																																
	var	cmd	canid	&	0xFF0000																											
	if	var	cmd	=	0x100000								#	BCL																		
		mp	bms.chargeMode			candt	4	1					#	充电模式																		
#	elseif	var	cmd	=	0x130000								#	BSM																		
	endif																															
	if		mpdt	bms.BSM		5	1		!=	0																						
		|	(	mpdt	bms.BSM		6	1	&	0x0f	)		!=	0																		
		mp	bms.stopReason			0xf0f000d0																										
	#	mp	bms.CST		0xf0f000d0			#终止原因故障终止																								
		mpofs	center.stopReason		0		const	sr-bms-err		#BMS端出现错误																				
		#log	"BMS recv abnormal BSM data!"																													
		goto	charging-stop																													
																																
	endif																															
	return												#																			
charging-stop													#	发送CST,stop																		
	mp	chgr.status		const	chgr-mode-stop								#	通知充电模块流程停机																		
	call	mp	chgr.state										#	调用充电机流程,通知其停机																		
	statemp		center.staTmo1			bms-fatal		13000																								
	statemp		center.staTmo2			bms-shutdown-send			const	bms-chgsend																						
	statemp		center.staTmo3			idle	0																									
	state	bms-shutdown		500									#	停机状态,500ms检查一次,是否已停机																		
													#																			
[state]	bms-charging-tmo	充电状态超时								#																			
#tag	command												#																			
	log	"充电状态超时"
	if	mp	bms.BCL	=	1								#	收到BCL,充电需求																		
		statemp		center.staTmo1		bms-charging-tmo			const	bms-chgtmo			#	重设超时时间																		
		mp	bms.BCL		0								#	重置																		
		#log	"recv BCL"																													
	else												#	未收到CCS,超时																		
		call	bms-main-tmo																													
	#	mp	chgr.status		const	chgr-mode-stop							#	通知充电模块流程停机																		
	#	state	bms-shutdown		500								#	停机状态,500ms检查一次,是否已停机																		
	#	statemp	center.staTmo1			bms-shutdown-send			const	bms-chgsend			#	发送CCS																		
	#	statemp	center.staTmo2			idle		0																								
	endif												#																			
													#																			
																																
[state]	bms-charging-tmo-bcs	充电状态超时								#																			
#tag	command												#																			
	log	"充电状态超时bcs"
	mp	bms.CEMReason			0xFCC1F0FC		#BCS超时						#																			
	call	bms-main-tmo											#	停机状态,500ms检查一次,是否已停机																		
																																
[state]	bms-charging-send	充电时循环发送			50ms					#																			
#tag	command												#																			
	#log	"bms充电时循环发送"
	mp	bms.CCS		1									#	发送充电机状态																		
													#																			
																																
[state]	bms-shutdown	停机										#																			
#tag	command												#																			
	log	"bms停机"
	if	mp	bms.BEM	!=	0	call	bms-err		return	endif																						
	if	mp	chgr.status		=	const	chgr-mode-standby						#	充电模块已停机																		
	#	mp	center.setTime			1							#	设置充电结束时间																		
		if	mp	bms.BST	=	1							#	收到BST,stop																		
			mp	bms.CST		mp	bms.stopReason						#	发送CST,stop																		
			call	bms-stopping									#	调用stopping，结束充电																		
		else																														
			statemp	center.staTmo1		bms-forCheckout			const	bms-tmo			#	设置超时timer																		
			statemp	center.staTmo2		bms-stopping-send			const	bms-stopsend			#	设置循环发送timer																		
			state	bms-stopping		0							#	停止充电状态																		
			mp	bms.CST		mp	bms.stopReason						#	发送CST,stop																		
		endif											#																			
	endif												#																			
																																
[state]	bms-shutdown-send	停机-发送CCS							#																			
#	log	"停机-发送CCS"
	mp	bms.CCS		1																												
																																
[state]	bms-fatal	停机-发送CCS							#																			
#	statemp		center.staTmo1			idle	0						#	停止超时timer																		
#	statemp		center.staTmo2			idle	0						#	停止发送timer																		
#	statemp		center.staChk			idle	0						#	检查状态初始化																		
#	state	idle	0																													
#	call	acbc-stopModuleFatalError											#	无法停止充电模块的致命错误节点																		
																																
#	mp	center.setTime			1		#记录结束时间																									
	log	"停机-设置fatal原因：模块停机失败"
	mp	center.fatal			1		#设置fatal原因：模块停机失败																									
	call	bms-forCheckout					#等待结账																									
																																
[state]	bms-stopping	结束充电状态,等待BST							#																			
#tag	command												#																			
	#log	"结束充电状态,等待BST"
	if	mp	bms.BEM	!=	0	call	bms-err		return	endif																						
	if	mp	bms.BST	=	1	|	mp	bms.BEM	!=	0			#	收到BST或BEM,stop																		
	#	#log	"stop charger,open K1 K2"																													
		mp	bms.BSD		-1								#	重置																		
		statemp	center.staTmo1		bms-forCheckout			const	bms-tmo				#	设置超时timer																		
		statemp	center.staTmo2		bms-statistics-send				const	bms-stopsend			#	设置循环发送timer																		
		state	bms-statistics		0								#	充电进行状态																		
	endif												#																			
													#																			
[state]	bms-stopping-send	结束时循环发送			10ms					#																			
#tag	command												#																			
	#log	"结束时循环发送"
	mp	bms.CST		mp	bms.stopReason								#	发送充电结束																		
													#																			
[state]	bms-statistics	充电统计状态								#																			
#tag	command												#																			
	log	"充电统计状态"
	if	mp	bms.BEM	!=	0	call	bms-err		return	endif																						
	if	mp	bms.BSD	!=	-1								#	收到BSD或BEM,statistics data																		
		statemp		center.staTmo1			idle	0					#	先将timer停止																		
		statemp		center.staTmo2			idle	0					#																			
		mp	bms.CSD		1								#	发送充电统计																		
		call	bms-forCheckout					#只运行一次					#	结账准备																		
	endif												#																			
													#																			
													#																			
[state]	bms-statistics-send	充电统计时循环发送			10ms					#																			
	mp	bms.CST		mp	bms.stopReason								#	发送充电结束																		
[state]	bms-forCheckout	结账准备										#																			
#tag	command												#																			
	log	"结账准备center.chgStatus="	mp	center.chgStatus
	statemp		center.staTmo1			bms-standby	20000					#	20秒后结束																		
	statemp		center.staTmo2			idle	0						#	
	if	mp	center.chgStatus	<	const	st-stopped
		mp	center.chgStatus			const	st-stopped							#	已停机,通知acb流程断开关,枪回桩,停辅助电源
	endif
		state	bms-waitEnd		1000									#	等待结账																		
																																
[state]	bms-waitEnd	等待结账结束,整个充电过程完成										#																			
#tag	command												#																			
	log	"等待结账结束,整个充电过程完成"	gun	mp	center.chgStatus	
	if	mp	center.chgStatus			=	const	st-standby					#	待机,结束充电																		
		state	bms-standby		1000								#																			
#		mpofs	pile.status		mp	center.curPile			0				#	恢复桩状态																		
#	elseif	mp	center.chgStatus			=	const	st-checkouted		#	已结账,通知pile流程恢复状态																		
#	#	mpofs	pile.status		mp	center.curPile			0				#	恢复桩状态																		
#		call	mp	pile.pile-state									#	调用多桩流程																		
#	elseif	mp	center.chgStatus			=	const	st-handshake					#	握手,切换充,切换至B枪																		
#		call	mp	pile.pile-state									#	调用多桩流程																		
#		mp	bms.BEM		0								#	初始化BEM																		
#		mp	bms.BST		0								#	初始化BST																		
#		mp	bms.BRM		0								#	初始化BRM为0																		
#		mp	bms.CRM		0								#	发送充电机识别报文:00																		
#		statemp	center.staTmo1			bms-main-tmo			const	bms-tmo			#	设置超时timer，5s																		
#		statemp	center.staTmo2			bms-handshake-send			const	bms-send			#	设置循环发送timer																		
#		state	bms-handshake		0								#																			
	endif																															

	#tag	command												#																			
	mp	bms.CRM		0									#	发送																		
																																
[state]	idle	空闲状态，相当于NULL										#																			
#	log	"空闲状态，相当于NULL"
#tag	command												#																			
#	#log	"idle"											#																			
																																
#tag	command			#	多包状态定义,状态名以mpkg为前缀																																							
[state]{lock}	mpkg-standby	多包等待					#																																		
	#log	"多包等待"
	lock	bms.mpkg-status																																										
	if	mp	bms.mpkg-recv	=	const	mpkg-recv-RTS				#	收到CM_RTS																																	
		if	mp	bms.mpkg-pf	<	21				#	21:0x15,BMV																																	
			mp	bms.mpkg-status	2					#	多包状态:0:等待,1:发送,2:接收																																	
			statemp	bms.mpkg-state	mpkg-recv	0				#	切换到多包的接收状态																																	
			mp	bms.mpkg-send	const	mpkg-recv-CTS				#	发送CTS,请求发送更多包																																	
			statemp	bms.mpkg-stTmo	mpkg-timeout	const	mpkg-tmo			#	超时判断																																	
		else								#	不支持（或不处理）的报文																																	
			mp	bms.mpkg-send	const	mpkg-recv-Abort				#	发送abort，不接收这些包																																	
		endif																																										
	elseif	mp	bms.mpkg-status	=	1					#	发送处理，已发送CM_RTS,并第一次收到对方反馈包																																	
#		mp	bms.mpkg-recv	0						#	重置																																	
#		statemp	bms.mpkg-stTmo	mpkg-timeout	1250					#	超时判断																																	
		statemp	bms.mpkg-state	mpkg-send	0					#	切换到多包的发送状态																																	
		call	mpkg-send							#	调用send状态																																	
	else									#																																		
		mp	bms.mpkg-recv	0						#	重置																																	
	endif																																											
	unlock	bms.mpkg-status																																										
																																												
[state]	mpkg-timeout	超时判断					#																																		
	log	"超时判断"
	lock	bms.mpkg-status																																										
#	if	mp	bms.mpkg-tmo	=	1					#	超时																																	
		mp	bms.mpkg-status	0						#	多包状态:0:等待,1:发送,2:接收																																	
		statemp	bms.mpkg-stTmo	idle	0					#	取消超时判断																																	
		statemp	bms.mpkg-state	mpkg-standby	0					#	切换到多包等待状态																																	
#	endif									#																																		
	unlock	bms.mpkg-status																																										
																																												
																																												
[state]{lock}	mpkg-recv	接收					#																																		
	#log	"mpkg-recv接收"
	lock	bms.mpkg-status																																										
	if	mp	bms.mpkg-recv	=	const	mpkg-recv-Abort				#	接收到Abort																																	
		mp	bms.mpkg-recv	0						#	重置																																	
		mp	bms.mpkg-status	0						#	多包状态:0:等待,1:发送,2:接收																																	
		statemp	bms.mpkg-stTmo	idle	0					#	取消超时判断																																	
		statemp	bms.mpkg-state	mpkg-standby	0					#	切换到等待状态																																	
		goto	mpkg-tag-end																																									
	endif									#																																		
	if	mp	bms.mpkg-count	=	0					#	接收完成，余数为0																																	
		if	mp	bms.mpkg-pf	=	0x02				#	BRM																																	
			mpdt	bms.dBRM	0	41	mpdt	ptr	bms.mpkg-data		0	41																																
																																												
			mpdt	bms.carId	0	17	mpdt	bms.dBRM	24	17																																		
			call	bgm-print-carId																																								
																																												
			call	bgm-changeCarId	#转换车架号格式,剔除不可见字符																																							
			call	bgm-print-carId																																								
																																												
		elseif	mp	bms.mpkg-pf	=	0x06				#	BCP																																	
			mpdt	bms.dBCP	0	13	mpdt	ptr	bms.mpkg-data		0	13																																
																																												
		elseif	mp	bms.mpkg-pf	=	0x11				#	BCS																																	
			mpdt	bms.dBCS	0	9	mpdt	ptr	bms.mpkg-data		0	9																																
																																												
		endif																																										
		mp	bms.mpkg-status	0						#	多包状态:0:等待,1:发送,2:接收																																	
		statemp	bms.mpkg-stTmo	idle	0					#	取消超时判断																																	
		statemp	bms.mpkg-state	mpkg-standby	0					#	切换到等待状态																																	
		mp	bms.mpkg-send	const	mpkg-recv-End					#	发送EndofMsgAck																																	
		if	mp	bms.mpkg-callSta	>	-1				#	有效状态																																	
			call	mp	bms.mpkg-callSta					#	调用主控状态																																	
		endif																																										
		goto	mpkg-tag-end							#																																		
	else	#count>0, 有剩余包																																										
	#	mp	bms.mpkg-send	2						#	发送CTS,请求发送更多包																																	
	endif									#																																		
	statemp	bms.mpkg-stTmo	mpkg-timeout	const	mpkg-tmo					#	重新设置超时判断																																	
mpkg-tag-end																																												
	unlock	bms.mpkg-status																																										
																																												
																																												
[state]	mpkg-send	发送					#																																		
	log	"mpkg-send发送"
	lock	bms.mpkg-status																																										
	if	mp	bms.mpkg-recv	=	const	mpkg-recv-Abort				#	接收到Abort																																	
		mp	bms.mpkg-recv	0						#	重置																																	
		goto	mpkg-tag-stop																																									
	endif									#																																		
	if	mp	bms.mpkg-recv	=	const	mpkg-recv-End				#	接收到EndofMsgAck																																	
		mp	bms.mpkg-recv	0							#	重置																																
		if	mp	bms.mpkg-count	=	0				#	发送完成，余数为0																																	
			goto	mpkg-tag-stop						#	结束																																	
		endif								#																																		
	endif									#																																		
	if	mp	bms.mpkg-recv	=	const	mpkg-recv-CTS				#	收到CTS																																	
		mp	bms.mpkg-recv	0						#	重置																																	
		mp	bms.mpkg-send	const	mpkg-recv-DT					#	发送DT																																	
	endif									#																																		
	statemp	bms.mpkg-stTmo	mpkg-timeout	const	mpkg-tmo					#	重新设置超时判断																																	
	goto	mpkg-tag-end																																										
mpkg-tag-stop	mp	bms.mpkg-status	0							#	多包状态:0:等待,1:发送,2:接收																																	
	statemp	bms.mpkg-stTmo	idle	0						#	取消超时判断																																	
	statemp	bms.mpkg-state	mpkg-standby	0					#	切换到等待状态																																	
mpkg-tag-end																																												
	unlock	bms.mpkg-status																																										

#tag	command						#	主逻辑控制											#																																																																															
																																																																																																		
																																																																																																		
[state]	acbc-check-alarm	检查报警												#																																																																															
	#log	"acbc检查报警="		gun	mpofs	acb.frontIn		mp	center.curPile
	#log	"acbc检查报警="	gun	"--"	mp	acb.ledTipCount	"++"	mp	center.chgStatus	"=="	mp	a.center.gunLinkCarOK
	
	if	gun	=	0
		#	检查急停开关状态																																																																																																
		var	this-frontIn	mpofs	a.acb.frontIn		mp	center.curPile										#	本桩前置开入量																																																																														
																																																																																																			
		if	(	var	this-frontIn		&	mp	acb.emergency		)	!=	0								#	检查急停开关状态，报警位为：1																																																																														
			or	mpofs	center.alarmStatus	0	0x01														#	状态为1，报警																																																																													
		else																																																																																																	
			and	mpofs	center.alarmStatus	0	(	not	0x01	)											#	状态为0，取消报警																																																																													
		endif																																																																																																	
																																																																																																			
		#	检查避雷器状态																																																																																																
		var	this-frontIn	mpofs	a.acb.frontIn		mp	center.curPile										#	本桩的后置开入量																																																																														
		if	(	var	this-frontIn		&	mp	acb.arrester		)	!=	0								#	检查避雷器状态，报警位为：2																																																																														
			or	mpofs	center.alarmStatus			0	0x02												#	状态为1，报警																																																																													
		else																																																																																																	
			and	mpofs	center.alarmStatus			0	(	not	0x02	)									#	状态为0，取消报警																																																																													
		endif																																																																																																	
	
		call	acbc-addModuleCommAlarm																	#	将充电模块的报警状态更新到总的报警状态和警示状态																																																																														
																																																																																																			
																																																																																																
		#if	mp	acb.state		=	state	acb-standby												#	待机时检查上传地址																																																																														
		#	call	acbc-checkBroadUpAddress														#	定时下发查询地址请求																																																																														
		#endif																																																																																																	
	
		#log	"温度gun="	gun
		#log	"温度="	mp	a.acb.envionmenttemp
		#log	"风扇启动阀值a="	mp	a.center.mpFanStartTemper	"风扇启动阀值b="	mp	center.mpFanStartTemper	
		#mp	center.mpFanStartTemper	100
		if	mp	acb.envionmenttemp	>	mp	center.mpFanStartTemper
			call	acbc-doFanOut
		elseif	mp	acb.envionmenttemp	<	mp	center.mpGunTemperUpper	-	50
			call	acbc-doCutFanOut
		endif
	
		if	mpofs	center.alarmStatus			0	!=	0																																																																																										
			|	mpofs	center.alarmStatus			1	!=	0																																																																																									
			|	mp	center.fatal		!=	0																																																																																											
																																																																																																			
			#log	"****************************  alarm state:"								%X	mpofs	center.alarmStatus			0																																																																																		
			call	acbc-printAlarmBit																#	打印报警信息																																																																														
		endif																																																																																																	
	
	endif

	if	(	mp	acb.state		=	state	acb-standby		)									#	待机或者充电中检查采样板的通讯状态																																																																														
		|	(	mp	acb.state		=	state	acb-waitStopCharging			)																																																																																						
																																																																																																		
		call	acbc-checkCommState																#	检查通讯状态																																																																														
	else																																																																																																	
																																																																																																		
		call	acbc-resetCommState																#	将通讯状态检查计数置为0																																																																														
	endif																																																																																																	
	
	call	acbc-isLinkOK
	
	#	驱动指示灯
	#if	gun	=	0	
	#	if	mp	a.center.chgStatus	=	const	st-standby	
	#		log	"驱动指示灯------"	mp	a.center.ledTipCount	
	#		if	mp	a.center.ledTipCount	=	0																																																																																	
	#			add	mp	a.center.ledTipCount	1	
	#			mp	io.LEDOFF_1	0
	#		else
	#			if	mp	center.gunLinkCarOK	=	1
	#				mp	io.LEDON_1	0
	#			else	
	#				mp	io.LEDOFF_1	0
	#			endif
	#			mp	a.center.ledTipCount		0
	#		endif
	#	elseif	mp	a.center.chgStatus	=	const	st-charge
	#		mp	io.LEDON_1	0
	#	else
	#		mp	io.LEDOFF_1	0
	#	endif
	#endif
	#
	#	
	#if	gun	=	1	
	#	if	mp	b.center.chgStatus	=	const	st-standby																																																																														
	#		if	mp	b.center.ledTipCount	=	0																																																																																	
	#			add	mp	b.center.ledTipCount	1	
	#			mp	io.LEDOFF_2	0
	#		else
	#			if	mp	b.center.gunLinkCarOK	=	1
	#				mp	io.LEDON_2	0
	#			else	
	#				mp	io.LEDOFF_2	0
	#			endif
	#			mp	b.center.ledTipCount	0
	#		endif
	#	elseif	mp	b.center.chgStatus	=	const	st-charge
	#		mp	io.LEDON_2	0
	#	else
	#		mp	io.LEDOFF_2	0
	#	endif
	#endif

	##TESTLED	if	mp	acb.state	=	state	acb-standby																																																																														
	##TESTLED		if	mp	acb.ledTipCount	=	0																																																																																	
	##TESTLED			add	mp	acb.ledTipCount			1	
	##TESTLED			mpc	io.setLED-GUN1	0
	##TESTLED			mpc	io.setLED-GUN2	0
	##TESTLED		else
	##TESTLED			if	mp	a.center.gunLinkCarOK	=	1
	##TESTLED				mpc	io.setLED-GUN1	1
	##TESTLED			else	
	##TESTLED				mpc	io.setLED-GUN1	0
	##TESTLED			endif
	##TESTLED			
	##TESTLED			if	mp	b.center.gunLinkCarOK	=	1
	##TESTLED				mpc	io.setLED-GUN2	1	
	##TESTLED			else	
	##TESTLED				mpc	io.setLED-GUN2	0
	##TESTLED			endif
	##TESTLED			mp	acb.ledTipCount	0
	##TESTLED		endif
	##TESTLED	endif
	##TESTLED	
	##TESTLED	call	a.acbc-isInAlarmStatus																																																																																																
	##TESTLED	var	errorA	var	rtn																																																																																														
	##TESTLED	call	b.acbc-isInAlarmStatus																																																																																																
	##TESTLED	var	errorB	var	rtn																																																																																														
	##TESTLED																																																																																																		
	##TESTLED	if	var	errorA	!=	0																																																																																													
	##TESTLED		|	var	errorB	!=	0																																																																																												
	##TESTLED		mpc	io.setLED-FAULT	1	#	设置开出3,故障,红灯																																																																																											
	##TESTLED	else																																																																																																	
	##TESTLED		mpc	io.setLED-FAULT	0																																																																																													
	##TESTLED	endif																																																																																																	
																																																																																																		
	mpc	io.WdtFeed			1			#喂狗																																																																																										
																																																																																																		
#	#log	"test shell cmd"																																																																																																
#	shell	"setcan.sh can2"				#重新复位bms can2口																																																																																												
																																																																																																		
[state]	acbc-isInAlarmStatus	检查设备是否为报警状态												#																																																																															
#tag	command																																																																																																	
	#log	"检查设备是否为报警状态="	gun
																																																																																																		
	var	rtn	0																																																																																															
	if	mp	center.alarmStatus			!=	0												#	检查报警状态																																																																														
		#if	gun	=	0																																																																																																
			log	"center.alarmStatus have alarm status , center.alarmStatus:"	%X	mpofs	center.alarmStatus	0	","	mpofs	center.alarmStatus			1																																																																											
		#endif																																																																																																
		var	rtn	1																																																																																														
	endif																																																																																																	
																																																																																																		
	var	i	0
	# 需要完善报警状态 添加模块报警信息
	##	do	while	var	i	<	4													#	检测4个充电模块的报警状态																																																																														
	##																																																																																																		
	##		var	chgr-alarm	mpofs	chgr.status1	var	i										#	获得模块的报警状态																																																																														
	##		var	alarm-flag	(	var	chgr-alarm	&	0xFF000000	)	>>	24																																																																																				
	##	#	var	alarm-flag			(	var	alarm-flag		&	0xF7	)																																																																																						
	##																																																																																																		
	##		if	var	alarm-flag		!=	0												#	检查报警状态																																																																														
	##			log	"module "		var	i	" find alarm , alarm flag:"				%X	var	alarm-flag																																																																																				
	##			var	rtn		1																																																																																												
	##		endif																																																																																																
	##																																																																																																		
	##		add	var	i	1																																																																																													
	##	loop																																																																																																	
																																																																																																		
[state]	acbc-addModuleCommAlarm	将充电模块的报警状态更新到总的报警状态和警示状态												#																																																																															
#tag	command																																																																																																	
	var	module-comm	(	mp	center.alarmComm	&	0xFFFF00	)	>>	8						#	第一个字节的低四位																																																																														
	var	module-comm2			var	module-comm		<<	18									#模块通讯报警占center.alarmStatus的18-25bit(从0开始)																																																																																							
	#	将模块的通讯报警状态加到center.alarmStatus中(18个字节+8个字节)																																																																																																
	mpofs	center.alarmStatus	0	(	(	mpofs	center.alarmStatus	0	)	&	0xFFF3FFFF	)	|	var	module-comm2	#	加上8个模块的通讯状态																																																																										
[state]	acbc-printAlarmBit	打印报警信息为												#																																																																															
#tag	command																														
	var	i		0																											
	var	base-bit		0x01																											
	do	while	var	i	<	32																									
		if	(	mp	center.alarmStatus			&	var	base-bit		)	!=	0																	
			log	"!!!!!!!!!!alarm bit - "			(	var	i	+	1	)																			
		endif																													
																															
		var	base-bit		var	base-bit		<<	1																						
		add	var	i	1																										
	loop																														
[state]	acbc-standby-check	待机时检查动作												#																																																																															
#tag	command																		#	充电状态，0：待机，1：辅助中，2：锁桩，3：密码验证完成，4：配置完成；5：起机中，6：充电中；7：停机中；8：待结账																																																																														
	#log	"待机时检查动作="	gun
	#log	"center.chgStatus = "	mp	center.chgStatus
	if	(	mp	center.chgStatus	=	const	st-configed		)								#	当状态为：配置完成																																																																														
		#	&	(	var	linkCarOK		=	1	)		#暂时注销,防止枪状态突变,节点无法跳转							#	并且枪也插到车上																																																																														
		statemp		acb.state		acb-startCharging				0									#	转到启动中状态																																																																														
	endif																																																																																																	
																																																																																																		
	if	mp	center.chgStatus	=	const	st-standby											#	待机时检测枪锁状态	如果锁了要解锁																																																																													
			mp	center.isAsistV24	0								# 恢复12V				
			call	acbc-isLockGunToCarInFree															#	检查枪是否插到车上且上锁																																																																														
			if	var	rtn	=	1																																																																																											
			call	acbc-unlockGunFromCarWithLock														#	带上锁重试的从车上解锁函数																																																																															
			endif																																																																																															
			#	确保直流输出开关分,联络开关分,泄放回路分																																																																																														
			call	acbc-checkStandbyIOStatus																																																																																														
	endif																																																																																																	
[state]	acb-standby	待机												#																																																																															
#tag	command	
	#log	"待机"	gun
	if	(	gun	=	1	)	&&	(	mp	center.isDoubleGun	=	0	)
		return
	endif
	mpofs	center.stopReason				0	0		#复位停止原因																																																																																																
	call	acbc-updateCommState																	#	更新板卡通信状态																																																																														
	call	acbc-checkGunToCarState																	#	检查枪连接车状态	
	var	isLinkA	mp	a.acb.linkCarState	&	0x01	
	var	isLinkB	mp	b.acb.linkCarState	&	0x01	
	var	isBothLink	0	
	#call	acbc-openLinkSwitch	
	if	mp	center.isDoubleGun	=	1
		if	(	var	isLinkA	=	0x01	)	&&	(	var	isLinkB	=	0x01	)	#A、B枪均连接
			mp	a.chgr.PerGunNum		2							#	A枪占用模块数量																																								
			mp	b.chgr.PerGunNum		2							#	B枪占用模块数量																																								
			mpofs	a.chgr.GunAddr		0	1						#	A枪模块地址寄存器																																								
			mpofs	a.chgr.GunAddr		1	2						#	A枪模块地址寄存器																																							
			mpofs	b.chgr.GunAddr		0	3						#	B枪模块地址寄存器																																								
			mpofs	b.chgr.GunAddr		1	4						#	B枪模块地址寄存器																																																																																												
			mp	center.chgrPerPile		2							#	每个桩2个充电模块
			mp	a.center.chargeType		1
			var	isBothLink	1	
		elseif	(	var	isLinkA	=	0x01	)	&&	(	var	isLinkB	!=	0x01	)	#A枪连接
			mp	a.chgr.PerGunNum		4							#	A枪占用模块数量																																								
			mp	b.chgr.PerGunNum		0							#	B枪占用模块数量																																								
			mpofs	a.chgr.GunAddr		0	1						#	A枪模块地址寄存器																																								
			mpofs	a.chgr.GunAddr		1	2						#	A枪模块地址寄存器																																							
			mpofs	a.chgr.GunAddr		2	3						#	B枪模块地址寄存器																																								
			mpofs	a.chgr.GunAddr		3	4						#	B枪模块地址寄存器																																																																																												
			mp	center.chgrPerPile		4							#	每个桩2个充电模块
			mp	a.center.chargeType		0
		elseif	(	var	isLinkA	!=	0x01	)	&&	(	var	isLinkB	=	0x01	)	#B枪连接
			mp	a.chgr.PerGunNum		0							#	A枪占用模块数量																																								
			mp	b.chgr.PerGunNum		4							#	B枪占用模块数量																																								
			mpofs	b.chgr.GunAddr		0	1						#	A枪模块地址寄存器																																								
			mpofs	b.chgr.GunAddr		1	2						#	A枪模块地址寄存器																																							
			mpofs	b.chgr.GunAddr		2	3						#	B枪模块地址寄存器																																								
			mpofs	b.chgr.GunAddr		3	4						#	B枪模块地址寄存器																																																																																												
			mp	center.chgrPerPile		4							#	每个桩2个充电模块
			mp	a.center.chargeType		0
		endif
	elseif	mp	center.isDoubleGun	=	0
		#log	"单枪充电"
		mp	a.chgr.PerGunNum		4							#	A枪占用模块数量																																								
		mp	b.chgr.PerGunNum		0							#	B枪占用模块数量																																								
		mpofs	a.chgr.GunAddr		0	1						#	A枪模块地址寄存器																																								
		mpofs	a.chgr.GunAddr		1	2						#	A枪模块地址寄存器																																							
		mpofs	a.chgr.GunAddr		2	3						#	B枪模块地址寄存器																																								
		mpofs	a.chgr.GunAddr		3	4						#	B枪模块地址寄存器																																																																																												
		mp	center.chgrPerPile		4							#	每个桩2个充电模块
		mp	a.center.chargeType		1
	endif	
	var	chgrStates0		mpofs	chgr.chgr	0	
	var	chgrStates1		mpofs	chgr.chgr	1	
	var	chgrStates2		mpofs	chgr.chgr	2	
	var	chgrStates3		mpofs	chgr.chgr	3	
	
	if	var	chgrStates0	=	const	moudle-close	
		var	chgrclose0	1	
	endif
	if	var	chgrStates1	=	const	moudle-close	
		var	chgrclose1	1
	endif
	if	var	chgrStates2	=	const	moudle-close	
		var	chgrclose2	1
	endif
	if	var	chgrStates3	=	const	moudle-close	
		var	chgrclose3	1
	endif
		
	if	var	isBothLink	=	1	
		call	acbc-linkSwitchState													#																																																																													
		if	var	rtn	=	1
			if	(	(	(	var	chgrStates0	=	1	)	&&	(	var	chgrStates1	=	1	)	)	)
				call	acbc-closeLinkSwitch	
			elseif	(	(	var	chgrStates2	=	1	)	&&	(	var	chgrStates3	=	1	)	)	
				call	acbc-closeLinkSwitch	
			endif
		endif
	endif
[state]	acbc-standby-init	初始化状态												#																																																																															
#tag	command																																																																																																	
	#log	"acb初始化状态="	gun
																																																																																																		
	mp	acb.doLockCarFlag				0																																																																																												
	mp	acb.doUnlockFreeFlag				0																																																																																												
	mp	acb.doUnlockCarFlag				0																																																																																												
	mp	center.fatal				0																																																																																												
	mp	acb.inFault				0																																																																																												
	#mp	acb.chgrRunTime				0		joy																																																																																										
																																																																																																		
	lock	acb.dbOperLock																																																																																																
		mp	acb.dbOperCount			0																																																																																												
	unlock	acb.dbOperLock																																																																																																
																																																																																																		
	lock	acb.tcpCheckLock																																																																																																
		mp	acb.tcpCheckCount			0																																																																																												
	unlock	acb.tcpCheckLock																																																																																																
																																																																																																		
	mp	bms.chargeMode				0																																																																																												
	#mp	bms.soc				0																																																																																												
	mpdt	bms.BSM		3	1	50																																																																																												
	mpdt	bms.BSM		1	1	50																																																																																												
	mp	bms.rmnTime				0																																																																																												
	mp	acb.timeCount				0																																																																																												
																																																																																																		
	statemp		acb.state-tmo			acbc-standby-check			1000			#	待机定时动作																																																																																					
	statemp		acb.state-send			idle						0				#	超时重发动作																																																																																					
	statemp		acb.state-his			idle						0				#	保存历史记录定时器																																																																																					
	statemp		acb.state				acb-standby					0				#	待机时检查,等待进入充电过程																																																																																					
[state]	acbc-isLockGunInFree	检查是不是"枪不在桩上且不在车上"												#																																																																															
#tag	command																																																																																																	
																																																																																																		
	#	充电桩没有枪头归位信号,所以把有关枪头归位的判断都屏蔽																																																																																																
	#	if	(	mpofs	acb.frontIn		mp	center.curPile			&	mpofs	acb.gunBack		0	)	=	0	#	枪1不在桩上																																																																														
	#	endif																																																																																																
	#	if	(	mpofs	acb.frontIn		mp	center.curPile			&	mpofs	acb.gunBack		1	)	=	0	#	枪2不在桩上																																																																														
	#	endif																																																																																																
	#log	"检查是不是枪不在桩上且不在车上"
																																																																																																		
	var	rtn	0																#	返回1表示枪在自由状态时处于上锁状态																																																																														
	var	output-unlock			0														#	如果枪1不在车上,枪1未连接比较值为1																																																																														
																																																																																																		
	if	(	mpofs	acb.frontCmpr	0	&	mpofs	acb.linkOK	0	)	=	mpofs		acb.linkGunState	0																																																																										
		if	func	acbc-isGunLock		mp	center.curPileNo			=	1								#	如果电磁锁为锁状态(1表示锁状态)																																																																														
			var	output-unlock			1												#	需要解锁枪																																																																														
		endif																																																																																																
	endif																																																																																																	
																																																																																																		
	if	(	var	output-unlock		=	1	)											#	如果有需要控制的锁定输出信号																																																																														
																																																																																																		
		var	rtn	1															#																																																																															
	endif																																																																																																	
																																																																																																		
																																																																																																		
#[state]	acbc-unlockGunInFree	当枪不在桩和车上时,解锁枪												#																																																																															
##tag	command																																																																																																	
#																																																																																																		
#	#	充电桩没有枪头归位信号,所以把有关枪头归位的判断都屏蔽																																																																																																
#	#	if	(	mpofs	acb.frontIn		mp	center.curPile			&	mpofs	acb.gunBack		0	)	=	0	#	枪1不在桩上																																																																														
#	#	endif																																																																																																
#	#	if	(	mpofs	acb.frontIn		mp	center.curPile			&	mpofs	acb.gunBack		1	)	=	0	#	枪2不在桩上																																																																														
#	#	endif																																																																																																
#	log	"当枪不在桩和车上时,解锁枪"
#																																																																																																		
#	var	rtn	0																#	返回1表示需要执行解锁操作																																																																														
#	var	output-unlock			0																																																																																													
#	if	(	mpofs	acb.frontCmpr		mp	center.curPile		&	mpofs	acb.linkOK		mp	center.curPile			)	=	mpofs		acb.linkGunState		mp	center.curPile																																																																										
#		if	func	acbc-isGunLock		mp	center.curPileNo			=	1								#	如果电磁锁为锁状态(1表示锁状态)																																																																														
#			var	output-unlock			1												#	需要解锁枪																																																																														
#		endif																																																																																																
#	endif																																																																																																	
#																																																																																																		
#	if	(	var	output-unlock		=	1	)											#	如果有需要控制的锁定输出信号																																																																														
#																																																																																																		
#		#log	"unlock the gun in acb unlockGunInFree"																																																																																															
#																																																																																																		
#		lock		acb.backOut																																																																																														
#																																																																																																		
#		if	mp	acb.doUnlockFreeFlag			=	0																																																																																										
#			if	var	output-unlock		=	1																																																																																										
#				and	mpofs	acb.backOut	0	not	mpofs	acb.gunLock-O	0	#	解锁车上电磁锁1，0：解锁,1:上锁																																																																														
#			endif																																																																																															
#			mp	acb.doUnlockFreeFlag				1																																																																																										
#		else	#	空闲时解锁失败,先上锁一次																																																																																														
#			if	var	output-unlock		=	1																																																																																										
#				or	mpofs	acb.backOut	0	mpofs	acb.gunLock-O	0		#	锁车上电磁锁1，0：解锁,1:上锁																																																																														
#			endif																																																																																															
#																																																																																																		
#			mp	acb.doUnlockFreeFlag				0																																																																																										
#		endif																																																																																																
#																																																																																																		
#		mp	a.acb.CJO		mp	center.curPile																																																																																												
#		unlock		acb.backOut																																																																																														
#	else																																																																																																	
#		mp	acb.doUnlockFreeFlag				0												#	解锁成功,复位标志																																																																														
#		var	rtn	1															#	不需要解锁																																																																														
#	endif																																																																																																	
#																																																																																																		
																																																																																																		
[state]	acbc-checkGunToCarState	检查枪连接车的状态												#																																																																															
#tag	command																																																																																																	
#	log	"检查枪连接车的状态="	gun
	var	gunCarState				0														#	表示是否需要解锁1枪																																																																														
	var	is2UnlinkStatus			0
#	log	"CC="	mpofs	acb.frontCmpr		mp	center.curPile
	#判断是否连接成功
	if	(	mpofs	acb.frontCmpr	0	&	mpofs	acb.linkOK	0	)	=	mpofs	acb.linkOK	0																																																																										
		or	var	gunCarState			0x01																																																																																											
	endif					
	#判断是否锁定成功
	if	func	acbc-isGunLock		mp	center.curPileNo	=	1																																																																																								
		or	var	gunCarState			0x02																																																																																											
	endif																																																																																																	
	var	isLink1	mp	acb.linkCarState			&	0x01																																																																																										
	var	isLink2	var	gunCarState			&	0x01																																																																																										
												#状态变了																																																																																						
	#if	(	var	isLink1		!=	var	isLink2		)		#新状态为连接中断																																																																																						
	#	&	(	var	isLink2		=	0	)																																																																																									
	#	var	is2UnlinkStatus			1																																																																																												
	#endif																																																																																																	
	if	mp	acb.linkCarState			!=	var	gunCarState																																																																																										
		mp	acb.linkCarState			var	gunCarState																																																																																											
	endif																																																																																																	
																																																																																																		
	#判断枪状态是否从连接变为未连接																																																																																																	
																																																																																																		
	#if	var	is2UnlinkStatus			!=	0																																																																																											
	#	#log	"reset bms can0 after unlike gun with car!!!"																																																																																															
	#	shell	"setcan.sh can2"				#重新复位bms can2口																																																																																											
	#endif																																																																																																	
																																																																																																		
[state]	acbc-isUnlockGunFromCar	判断枪锁是否已经从车上解锁												#																																																																															
#tag	command																																																																																																	
#	log	"判断枪锁是否已经从车上解锁"
	var	rtn	0																#	返回1表示枪不在车上,或者枪在车上且解锁																																																																														
	var	output-unlock			0														#	表示是否需要解锁枪																																																																														
																																																																																																		
	if	func	acbc-isGunLock		mp	center.curPileNo			=	1																																																																																								
		var	output-unlock			1																																																																																												
	endif																																																																																																	
																																																																																																		
	if	(	var	output-unlock		=	1	)											#	如果有需要控制的锁定输出信号																																																																														
																																																																																																		
		var	rtn	0																																																																																														
	else																																																																																																	
		var	rtn	1															#	枪或者不在车上,或者在车上但是解锁了																																																																														
	endif																																																																																																	
[state]	acbc-isGunToCarLinkAndLockOK	判断枪是否"插到车上,且上锁成功"												#																																																																															
#tag	command																																																																																																	
	log	"判断枪是否"插到车上,且上锁成功"	"
	var	rtn			1														#	1:表示枪连接好;0:枪没有连接好																																																																														
	var	link		mp	acb.linkCarState			&	0x01										#	枪的连接状态																																																																														
	if	(	var	link			=	0x00	)										#	枪都未插																																																																														
		var	rtn	0																																																																																														
	endif																																																																																																	
[state]	acbc-unlockGunFromCar	从车上解锁枪锁												#																																																																															
#tag	command																																																																																																	
	log	"从车上解锁枪锁"
	var	rtn	0																#	返回1表示枪不在车上,或者枪在车上且解锁																																																																														
	var	output-unlock			0														#	表示是否需要解锁枪																																																																														
																																																																																																		
	if	func	acbc-isGunLock	0	=	1																																																																																								
		var	output-unlock			1													#	需要解锁枪																																																																														
	endif																																																																																																	
																																																																																																		
	if	(	var	output-unlock		=	1	)											#	如果有需要控制的锁定输出信号																																																																														
																																																																																																		
		lock	acb.backOut																																																																																														
		and	mpofs	acb.backOut	0	not	mpofs	acb.gunLock-O	0			#	解锁电磁锁，0：解锁,1:上锁																																																																														
		mp	acb.CJO	0																																																																																													
		unlock		acb.backOut																																																																																														
	else																																																																																																	
		var	rtn	1															#	枪或者不在车上,或者在车上但是解锁了																																																																														
	endif																																																																																																	
																																																																																																		
[state]	acbc-unlockGunFromCarWithLock	从车上解锁枪锁(带上锁重试功能)												#																																																																															
#tag	command																																																																																																	
	#log	"从车上解锁枪锁(带上锁重试功能)="	gun
	var	rtn	0																#	返回1表示枪不在车上,或者枪在车上且解锁																																																																														
	var	output-unlock			0														#	表示是否需要解锁枪																																																																														
	if	func	acbc-isGunLock			mp	center.curPileNo			=	1																																																																																							
		var	output-unlock			1													#	需要解锁枪1																																																																														
	endif																																																																																																	
																																																																																																		
	if	(	var	output-unlock		=	1	)											#	如果有需要控制的锁定输出信号																																																																														
		lock	acb.backOut																																																																																														
		if	mp	acb.doUnlockCarFlag	=	0																																																																																										
			and	mpofs	acb.backOut	0	not	mpofs	acb.gunLock-O	0				#	解锁电磁锁，0：解锁,1:上锁																																																																														
			mp	acb.doUnlockCarFlag				1																																																																																										
		elseif	mpofs	acb.restoreErrorCnt			0	<	10												#	解锁失败时,进行一次上锁操作																																																																														
			add	mpofs	acb.restoreErrorCnt			0	1																																																																																									
																																																																																																		
			or	mpofs	acb.backOut	0	mpofs	acb.gunLock-O	0	#	锁电磁锁1，0：解锁,1:上锁																																																																														
																																																																																																		
			mp	acb.doUnlockCarFlag				0																																																																																										
		endif																																																																																																
																																																																																																		
		mp	acb.CJO		mp	center.curPile																																																																																												
		unlock	acb.backOut																																																																																														
																																																																																																		
	else																																																																																																	
		mp	acb.doUnlockCarFlag				0								#	从车上解锁成功,需要复位标志																																																																														
		var	rtn	1															#	枪或者不在车上,或者在车上但是解锁了																																																																														
	endif																																																																																																	
																																																																																																		
[state]	acbc-isLockGunToCarInFree	判断在standby状态时,枪是否"插到车上,且上锁成功"												#																																																																															
#tag	command																																																																																																	
	#log	"判断在standby状态时,枪是否插到车上,且上锁成功"
	var	rtn			0														#	0表示否,1表示时																																																																														
	var	linkcar-ok			0														#	表示枪连车是否成功																																																																														
	if	func	acbc-isGunLock		mp	center.curPileNo			=	1																																																																																								
		var	linkcar-ok			1																																																																																												
	endif																																																																																																	
																																																																																																		
	if	(	var	linkcar-ok		=	1	)											#	连接到车上了,且上锁了																																																																														
		var	rtn	1																																																																																														
	endif																																																																																																	
																																																																																																		
[state]	acbc-isLockGunToCarOK	判断枪是否"插到车上,且上锁成功"												#																																																																															
#tag	command																																																																																																	
																																																																																																		
	log	"判断枪是否插到车上,且上锁成功"
	var	rtn			0														#	0表示否,1表示时																																																																														
	var	linkcar-ok			0														#	表示枪连车是否成功																																																																														
																																																																																																		
	if	func	acbc-isGunLock		mp	center.curPileNo			=	1																																																																																								
																																																																																																		
		var	linkcar-ok			1																																																																																												
																																																																																																		
	endif																																																																																																	
																																																																																																		
																																																																																																		
	if	(	var	linkcar-ok		=	1	)											#	连接到车上了,且上锁了																																																																														
		var	rtn	1																																																																																														
	endif																																																																																																	
																																																																																																		
																																																																																																		
[state]	acbc-lockGunToCar	将枪接到车上且上锁												#																																																																															
	#log	"将枪接到车上且上锁"
	var	rtn	1																#	返回1表示枪在车上,且上锁成功																																																																														
	var	output-lock			0												#	表示是否需要锁枪																																																																														
	#先判断一下是否已锁
	if	func	acbc-isGunLock	0	=	1																																																																																								
		var	output-lock			1
	endif																																																																																																	
																																																																																																		
	if	(	var	output-lock	=	0	)											#	需要锁定																																																																														
		lock		acb.backOut																																																																																														
		if	mp	acb.doLockCarFlag			=	0																																																																																										
			if	var	output-lock		=	0																																																																																										
				or	mpofs	acb.backOut	0	mpofs	acb.gunLock-O	0			#	锁车上电磁锁，0：解锁,1:上锁																																																																														
			endif																																																																																															
			mp	acb.doLockCarFlag				1																																																																																										
		else	#	执行锁枪不成功,则执行一次解锁命令																																																																																														
			if	var	output-lock		=	0																																																																																									
				and	mpofs	acb.backOut	0	not	mpofs	acb.gunLock-O	0	#	锁车上电磁锁，0：解锁,1:上锁																																																																														
			endif																																																																																														
			mp	acb.doLockCarFlag				0																																																																																										
		endif																																																																																																
		#log	"锁枪="		gun	mpofs	acb.backOut	0																																																																																																
		mp	acb.CJO		mp	center.curPile																																																																																												
		unlock		acb.backOut																																																																																														
																																																																																																		
		var	rtn	0															#	有枪接到车上,但是没有锁																																																																														
	else																																																																																																	
		mp	acb.doLockCarFlag				0								#	锁定成功,复位标志																																																																														
		var	rtn	1																																																																																														
	endif																																																																																																	
[state]	acbc-checkStandbyIOStatus	待机状态时,检测确保输出状态正常												#																																																																															
#tag	command																																																																																																	
	#log	"待机状态时,检测确保输出状态正常="	gun																																																																																																		
	var	output1-off		0																																																																																														
																																																																																																		
	#	确保待机时,本机直流输出开关状态为0																																																																																																
	if	(	mpofs	acb.frontIn	0	&	mpofs	acb.outSwitch	0	)	!=	0			#	如果直流输出开关状态为1																																																																														
		var	output1-off		1																																																																																													
	endif																																																																																																	
																																																																																																		
	var	OutswitchtError			0x01																																																																																													
																																																																																																		
	if	var	output1-off		=	1																																																																																												
		or	mpofs	center.alarmStatus			1		var	OutswitchtError										#输出继电器错误																																																																														
		#log	"acbc-checkStandbyIOStatus-----OutswitchSwitchERROR"																																																																																															
	else																																																																																																	
		and	mpofs	center.alarmStatus	1	not	var	OutswitchtError									#输出继电器错误清除																																																																														
		mpofs	acb.restoreErrorCnt	1	0																																																																																											
	endif																																																																																																	
																																																																																																		
	if	(	var	output1-off		=	1	)											#	如果有需要控制的直流输出开关																																																																														
		&	mpofs	acb.restoreErrorCnt			1	<	10			#最多连续操作10次																																																																																						
		log	"!!!!!继电器位置异常"																																																																																																
		lock		a.acb.frontOut																																																																																														
		and	mpofs	a.acb.frontOut	0	not	mpofs	a.acb.outSwitch-O		gun																																																																																
		mp	a.acb.CCO		mp	center.curPile																																																																																												
		unlock		a.acb.frontOut																																																																																														
		add	mpofs	acb.restoreErrorCnt			1		1																																																																																									
	endif																																																																																																	
																																																																																																		
	var	output1-off		0																																																																																														
																																																																																																		
																																																																																																		
	#	待机时要确保辅助电源分开																																																																																																
																																																																																																		
	var	AccError		0x1	<<	2																																																																																												
	#枪未连接																																																																																																	
	if	(	mpofs	acb.frontCmpr	0	&	mpofs	acb.linkOK	0	)	!=	mpofs	acb.linkOK	0																																																																									
		call	acbc-doAccPowerOff														#	分辅助电源																																																																														
	endif																																																																																																	
	
	
	#var	SelestortError			0x01	<<	1																																																																																											
	#if	(	(	mpofs	a.acb.backIn		0	)	&	mpofs	acb.commSwitch		mp	center.curPile		)	!=	0	#	如果联络开关状态为0																																																																														
	#	or	mpofs	center.alarmStatus			1		var	SelestortError									#联络开关错误																																																																															
	#	lock		a.acb.backOut															#	下发控制直流输出开关遥控合命令																																																																														
	#	and	mpofs	a.acb.backOut		0		not		mpofs	acb.commSwitch-O			mp	center.curPile																																																																																			
	#	mp	a.acb.CJO		0																#	控制当前桩后置采样板的直流输出开关为1																																																																														
	#	unlock		a.acb.backOut															#	开出控制量																																																																														
	#else																																																																																																	
	#	and	mpofs	center.alarmStatus			1		not	var	SelestortError									#联络开关错误清除																																																																														
	#endif																																																																																																	
																																																																																																		
	#var	releaseErr		0x1	<<	3																																																																																												
	#if	(	(	mpofs	acb.backOut		mp	center.curPile		)	&	mp	acb.leakLoop		)	!=	0		#	泄放继电器开入不为0																																																																														
	#	or	mpofs	center.alarmStatus			1		var	releaseErr																																																																																								
	#	call	acbc-openRelease																																																																																															
	#else																																																																																																	
	#	and	mpofs	center.alarmStatus			1		not	var	releaseErr								#待机中泄放继电器合错误清除																																																																															
	#endif																																																																																																	
	
	#待机时分泄放
	call	acbc-doCutRelease																	#	切泄放,防止泄放未切																																																																																				

[state]	acbc-resetCommState	复位通讯状态计数												#																																																																															
#tag	command																																																																																																	
	#log	"复位通讯状态计数"
	var	i	0																																																																																															
	do	while	var	i	<	8																																																																																												
		mpofs	acb.commCount		var	i	0																																																																																											
		add	var	i	1																																																																																													
	loop																																																																																																	
[state]	acbc-updateCommState	更新通讯状态计数												#																																																																															

	if	(	canid	&	0xFF0000		)	=	0xB10000										#	CC601																																																																														
		mpofs	acb.commCount			4		0										#	复位通信计数，	CC601的commCount在第4个偏移中存储																																																																													
		mpofs	acb.commRecved			4		1																																																																																									
	endif																																																																																																	
	
	if	(	canid	&	0xFF0000		)	=	0xD10000										#	CJ601
		if	(	canid	&	mp	center.backAddr	)	=	mp	center.backAddr						#AB枪的地址是不相等的
			mpofs	acb.commCount	0	0									#	将前端采样板的计数变为0																																																																														
			mpofs	acb.commRecved	0	1																																																																																								
		endif																																																																																																
	endif																																																																																																	
																																																																																																		
																																																																																																		
[state]	acbc-checkCommState	检查采样板的通讯状态												#																																																																															
#tag	command																																																																																																	
#	log	"检查采样板的通讯状态="	gun
	var	i		0																																																																																														
	var	result-fail		0																																																																																														
	var	index		0																																																																																														
	var	need-check		0																																																																																														
																																																																																																		
	if	gun	=	0																																																																																																	
		var	i	4																			#	CC601的通信状态 只有一个																																																																														
		var	base-value		(	0x01	<<	5	)																																																																																										
																																																																																																			
		if	mpofs	acb.commCount		var	i	>	const	acb-timeout						#	20秒未更新	commCount偏移量为4																																																																													
																																																																																																			
			#log	"front board alarm:"			%X	var	base-value																																																																																										
			or	mpofs	center.alarmStatus	0	var	base-value							#	置第5位报警为1																																																																													
			mpofs	acb.commDown		var	i	0												#	标志通讯中断																																																																														
			call	mp	acb.state																																																																																														
		else																																																																																																	
			and	mpofs	center.alarmStatus	0	not	var	base-value										#	置第5位报警为0
			mpofs	acb.commDown		var	i	1												#	标志通讯正常																																																																														
		endif																																																																																																	
	endif
	
	var	i		0																																																																																														
	do	while	var	i	<	1													#	CJ601	AB枪只检测第一个 ZB																																																																													
		if	mp	center.isDoubleGun	=	0	&	gun	=	1
			break
		endif
		var	index		(	6	+	gun	)										#	第6、7位分别对应AB枪CJ601通信状态 a.center.alarmStatus中 可以不区分AB center 因为都有																																																																															
		#log	"var index="	var	index
		var	base-value		(	0x01	<<	var	index	)																																																																																								
																																																																																																		
		if	(	mpofs	acb.commCount	0	>	const	acb-timeout		)				#	AB枪CJ601通信状态计数均为第0个数组																																																																														
			or	mpofs	a.center.alarmStatus	0	var	base-value																																																																																								
			mpofs	acb.commDown	0	0												#	标志通讯中断 AB枪各自的通信状态																																																																														
			call	mp	acb.state																																																																																													
		else																	#	报警																																																																														
			and	mpofs	a.center.alarmStatus			0	not	var	base-value					#	取消报警																																																																													
			mpofs	acb.commDown	0	1											#	标志通讯正常																																																																														
		endif
		
		add	var	i	1																																																																																													
	loop																																																																																																	
																																																																																																		
	var	i	0																																																																																															
	do	while	var	i	<	8													#	将计数加1	acbc-updateCommState中清零																																																																																																																																																				
																																																																																																		
		if	mpofs	acb.commCount		var	i	<=	const	acb-timeout																																																																																								
																																																																																																		
			add	mpofs	acb.commCount		var	i	1																																																																																									
		endif																																																																																																
																																																																																																		
		add	var	i	1																																																																																													
	loop																																																																																																	
[state]	acbc-checkBroadUpAddress	检查采样板上传地址(下发查询命令)												#																																																																															
#tag	command																																																																																																	
	#log	"检查采样板上传地址(下发查询命令)="	gun
	#if	(	mp	acb.checkCount		+	5	)	%	6	=	0							#	定时读取上传地址																																																																														
	#	mp	a.acb.CFR		mp	center.curPile																																																																																												
	#endif		
	#log	"acb.checkCount"	mp	b.acb.checkCount
	#if	mp	acb.checkCount		>=	5													#	定时读取上传地址																																																																														
	#	mp	acb.CBR		mp	center.curPile																																																																																												
	#	mp	acb.checkCount			0																																																																																												
	#else																																																																																																	
	#	add	mp	acb.checkCount			1																																																																																											
	#endif																																																																																																	
[state]	acbc-isGunLock	判断枪是否锁成功
	#if	gun	=	0																																																																															
	#	log	"判断枪是否锁成功="	gun
	#	log	"acb.backIn="	%X	mpofs	acb.backIn		mp	center.curPile	
	#	log	"acb.gunLock="	%X	mpofs	acb.gunLock		mp	center.curPile
	#endif
	var	gunLockFlag		0			#枪是否上锁标志,1表示上锁,0表示未锁																																																																																											
	if	(	mpofs	acb.backIn		0		&	mpofs	acb.gunLock		0			)	=	1		#如果电磁锁1锁(0表示未上锁)																																																																													
		var	gunLockFlag		1	
		#if	gun	=	0																																																																															
		#	log	"成功"
		#endif
	endif																																																																																																	
	var	rtn	var	gunLockFlag																																																																																														
[state]	acbc-isLinkOK	判断枪是否连接成功												#																																																																															
	#log	"判断枪是否连接成功="	(	mpofs	acb.frontCmpr	0	)	&	(	mpofs	acb.linkOK	0	)	";acb.frontCmpr="	(	mpofs	acb.frontCmpr	0	)	";acb.linkOK="	(	mpofs	acb.linkOK	0	)
	var	statusFlag		0
	#log	"CC601DATA2="	gun	%X	mpofs	acb.frontCmpr	0
	#log	"linkOK="	%X	mpofs	acb.linkOK	0
	if	gun	=	0																																																																																														
		if	(	(	mpofs	acb.frontCmpr	0	)	&	mpofs	acb.linkOK	0	)	=	0x03	#	如果枪1连接到车上																																																																													
			var	statusFlag		1	
			mp	a.center.gunLinkCarOK	1
		else
			mp	a.center.gunLinkCarOK	0
		endif																																																																																																
	endif																																																																																																	
	if	gun	=	1																																																																																														
		if	(	(	mpofs	acb.frontCmpr	0	)	&	mpofs	acb.linkOK	0	)	=	mpofs	acb.linkOK	0	#	如果枪2连接到车上（第4,5位为1）																																																																													
			var	statusFlag		1																																																																																												
			mp	b.center.gunLinkCarOK	1
			#log	"B枪连接"
		else
			mp	b.center.gunLinkCarOK	0
			#log	"B枪未连接"
		endif																																																																																																
	endif																																																																																																	
	#log	"acbc-isLinkOK:"			var	statusFlag																																																																																												
	var	rtn	var	statusFlag																																																																																														
[state]	acbc-startChargerModule	启动充电模块						#																																																																													
	log	"acb启动充电模块"
	if	mp	chgr.status	!=	const	chgr-mode-start		
		mp	chgr.status			const	chgr-mode-start										#	启动充电模块																																																																												
		call	mp	chgr.state																#	调用充电机流程,通知其启机
	endif
[state]	acbc-stopChargerModule	停止充电模块						#																																																																													
	log	"acb停止充电模块"	gun
	mp	chgr.status			const	chgr-mode-stop										#	停止充电模块																																																																												
	call	mp	chgr.state																#	调用充电机流程,通知其停机																																																																												
[state]	acbc-isChargerModuleStart	检测充电模块是否启动			#																																																																													
	#log	"检测充电模块是否启动="	mp	chgr.status	"电压"	mp	acb.chargeV
	var	rtn	0																																																																																													
	if	mp	chgr.status			=	const	chgr-mode-charging							#	启动状态
		if	mp	acb.chargeV	>	600
			var	rtn	1																	#	停止成功,返回值为1
		endif
	endif																																																																																															
[state]	acbc-isChargerModuleStop	检测充电模块是否停止			#																																																																													
	log	"检测充电模块是否停止chgr.status="	mp	chgr.status
	var	rtn	0																																																																																													
	if	mp	chgr.status		=	const	chgr-mode-standby								#	停止状态
		if	mp	acb.chargeV	<	600
			var	rtn	1																	#	停止成功,返回值为1
		else
			log	"停止模块后电压"
			call	acbc-stopChargerModule
		endif
	endif																																																																																															
[state]	acbc-doPutRelease	投泄放									#																																																																													
	if	gun	=	0
		log	"投泄放"
	endif
	lock		acb.backOut																#	控制泄放控制为1																																																																												
	or	mpofs	acb.backOut		mp	center.curPile	mp	acb.leakLoop																																																																																						
	mp	acb.CJO		mp	center.curPile																																																																																											
	unlock		acb.backOut																																																																																													
[state]	acbc-doCutRelease	切泄放									#																																																																													
	#if	gun	=	0
	#	log	"切泄放="	gun
	#endif
	lock		acb.backOut																#	控制泄放控制为0																																																																												
	and	mpofs	acb.backOut		mp	center.curPile	not	mp	acb.leakLoop																																																																																					
	mp	acb.CJO		mp	center.curPile																																																																																											
	unlock		acb.backOut
[state]	acbc-doSwitchV	投24V辅助电压									#																																																																													
#	if	gun	=	0
#		log	"投泄放"
#	endif
	lock		acb.backOut																#	控制24V辅助电源投入																																																																												
	or	mpofs	acb.backOut		0	mp	acb.AsistVSwitch																																																																																						
	mp	acb.CJO		mp	center.curPile																																																																																											
	unlock		acb.backOut																																																																																													
[state]	acbc-doCutSwitchV	切24V辅助电压									#																																																																													
	#if	gun	=	0
	#	log	"切泄放="	gun
	#endif
	mp	center.isAsistV24	0	
	lock		acb.backOut																#	控制24V辅助电源退出																																																																												
	and	mpofs	acb.backOut		0	not	mp	acb.AsistVSwitch																																																																																					
	mp	acb.CJO		mp	center.curPile																																																																																											
	unlock		acb.backOut	
[state]	acbc-doFanOut	投交流风扇									#																																																																													
#	if	gun	=	0
#		log	"投泄放"
#	endif
	lock		acb.backOut																#	控制24V辅助电源投入																																																																												
	or	mpofs	acb.backOut		0	mp	acb.FanOut																																																																																						
	mp	acb.CJO		mp	center.curPile																																																																																											
	unlock		acb.backOut																																																																																													
[state]	acbc-doCutFanOut	切交流风扇									#																																																																													
	#if	gun	=	0
	#	log	"切泄放="	gun
	#endif
	lock		acb.backOut																#	控制24V辅助电源退出																																																																												
	and	mpofs	acb.backOut		0	not	mp	acb.FanOut																																																																																					
	mp	acb.CJO		mp	center.curPile																																																																																											
	unlock		acb.backOut		
[state]	acbc-doAccPowerUCheckOFF	执行"辅助电源电压检测切换"退出动作					#																																																																													
#tag	command																																																																																															
	#log	"执行辅助电源电压检测切换退出"
	#																																																																																															
	#var	rtn	0																			#	返回1表示"辅助电源电压检测切换动作开入"为0																																																																												
	#																																																																																															
	#if	(	mpofs	a.acb.frontIn	0	&	mp	acb.accCheck	)	!=	0	#	如果"辅助电源电压检测切换动作开入"不为0																																																																												
	#	lock		a.acb.frontOut														#	开出"辅助电源电压检测切换"为0																																																																												
	#	and	mpofs	a.acb.frontOut	mp	center.curPile	not	mp	a.acb.accCheck-O																																																																																				
	#	mp	a.acb.CCO	mp	center.curPile																																																																																										
	#	unlock	a.acb.frontOut																																																																																												
	#else																																																																																															
	#	var	rtn	1																		#	如果"辅助电源电压检测切换动作开入"为0																																																																												
	#endif																																																																																															
[state]	acbc-isAccPowerOn	判断是否检测到辅助电源												#																																																																													
#	log	"判断是否检测到辅助电源="	gun
	var	rtn	1																																																																																													
	#var	bms-mask		mpofs	acb.accPowerV		mp	center.curPile																																																																																								
	#if	gun	=	0																																																																																												
	#	if	(	mpofs	acb.frontCmpr	mp	center.curPile	&	var	bms-mask	)	!=	0	#	A枪有辅助电源																																																																												
	#		var	rtn	1																																																																																											
	#	endif																																																																																														
	#else																																																																																															
	#	if	(	mpofs	acb.frontCmpr-b	mp	center.curPile	&	var	bms-mask	)	!=	0	#	B枪有辅助电源																																																																												
	#		var	rtn	1																																																																																											
	#	endif																																																																																														
	#endif																																																																																															
																																																																																																
[state]	acbc-doAccPowerOn	执行辅助电源投入动作														#																																																																													
	#log	"执行辅助电源投入动作="	gun	
	lock		a.acb.frontOut																																																																																														
	or	mpofs	a.acb.frontOut	0	mpofs	acb.accPowerOn-O	gun	#	投辅助电源																																																																												
	mp	a.acb.CCO		mp	center.curPile																																																																																											
	unlock		a.acb.frontOut																																																																																													
[state]	acbc-doAccPowerOff	执行辅助电源退出动作									#																																																																													
	#log	"执行辅助电源退出动作="	gun
	lock		a.acb.frontOut																			#	如果有辅助电源，则继续切																																																																													
	and	mpofs	a.acb.frontOut	0	not	mpofs	acb.accPowerOn-O	gun					#	切除辅助电源的开出																																																																													
	mp	a.acb.CCO		mp	center.curPile																																																																																											
	unlock		a.acb.frontOut																																																																																													
[state]	acbc-isGetBatteryU	判断是否检测到电池电压-即充电电压												#																																																																													
#	log	"判断是否检测到电池电压"	mpofs	acb.chargeV	0
	var	rtn	1																																																																																													
#	var	rtn	1	#JINGZHENG																																																																																													

	if	mpofs	acb.chargeV	0	>	1000																																																																																														
		var	rtn	1																																																																																											
	endif																																																																																														
																																																																																																
[state]	acbc-doOutSwitchON	设置输出开关状态为1												#																																																																													
#tag	command																																																																																															
	#log	"设置输出开关状态为1="	gun
	#log	"++++++="	%X	mpofs	acb.outSwitch-O	0		
	#log	"------="	%X	mpofs	acb.outSwitch-O	1		
	#log	"继电器状态1="	%X	mpofs	acb.frontIn	0	
	#log	"继电器状态1="	%X	mpofs	acb.outSwitch	0	
	var	rtn	0																#	输出开关状态为1,返回值为1,否则下发控制命令并返回0																																																																												
																																																																																																
	if	(	mpofs	acb.frontIn	0	&	mpofs	acb.outSwitch	0	)	=	0	#	如果直流输出开关状态为0																																																																												
		lock		a.acb.frontOut															#	下发控制直流输出开关遥控合命令																																																																												
		or	mpofs	a.acb.frontOut	0	mpofs	acb.outSwitch-O	gun	
		mp	a.acb.CCO		mp	center.curPile													#	控制当前桩后置采样板的直流输出开关为1																																																																												
		unlock		a.acb.frontOut															#	开出控制量																																																																												
	else																																																																																															
		var	rtn	1															#	直流输出开关状态为1																																																																												
	endif																																																																																															
[state]	acbc-doOutSwitchOFF	设置输出开关状态为0												#																																																																													
#tag	command																																																																																															
#	log	"设置输出开关状态为0"	gun	"--"	mpofs	acb.frontOut	0
	var	rtn	0																#	输出开关状态为1,返回值为1,否则下发控制命令并返回0																																																																												
	#不论如何都分直流输出开关,防止急停的时候不开出分直流输出信号																																																																																															
	lock		a.acb.frontOut																#	下发控制直流输出开关遥控分命令																																																																												
	and	mpofs	a.acb.frontOut	0	not	mpofs	acb.outSwitch-O	gun																																																																																			
	mp	a.acb.CCO		mp	center.curPile														#	控制当前桩后置采样板的直流输出开关为0																																																																												
	unlock		a.acb.frontOut																#	开出控制量																																																																												
[state]	acbc-isStartInterrupted	起机过程中被中断												#																																																																													
#tag	command																																																																																															
	if	mp	center.chgStatus			>=	const	st-stop											#	如果起机中发现状态被置为停机中,																																																																												
		|	mp		center.fatal		!=	0																																																																																								
		#log	"start charging process be interrupted!!!"																																																																																													
		log	"起机过程中被中断"
		statemp		acb.state-tmo			idle				0																																																																																					
		statemp		acb.state-send			idle				0																																																																																					
		statemp		acb.state			acb-stopBeginProcess				mini								#	则中止起机操作																																																																												
	endif																																																																																															
[state]	acbc-isStartInsulationInterrupted	绝缘监测启动中被中断												#																																																																													
#tag	command																																																																																															
	if	mp	center.chgStatus			>=	const	st-stop											#	如果绝缘监测启动中发现状态被置为停机中,																																																																												
		|	mp		center.fatal		!=	0																																																																																								
		log	"绝缘监测启动中被中断"
		#log	"start charging process be interrupted!!!"																																																																																													
		statemp		acb.state-tmo			idle				0																																																																																					
		statemp		acb.state-send			idle				0																																																																																					
		statemp		acb.state			acb-stopInsulationCheck				mini								#	则中止绝缘监测操作																																																																												
	endif																																																																																															
[state]	acbc-saveFailLog	出错时保存错误日志																																																																																									
	if	(	mpofs	center.stopReason	0	!=	const	acb-fill-OK		)																																																																																		
		&	(	mpofs	center.stopReason	0	!=	const	acb-card-stop		)																																																																																	
		&	(	mpofs	center.stopReason	0	!=	const	acb-app-stop		)																																																																																	
		shell	"checkFailLog.sh"																																																																																													
	endif																																																																																															
[state]	acbc-setStartTime	设置起始时间																																																																																									
	#log	"设置起始时间"
	mp	center.setTime			0														#	开始时间																																																																												
#	mp	center.setTime			1														#	结束时间																																																																												
[state]	acbc-setEndTime	设置截止时间																																																																																									
#	log	"设置截止时间"
	mp	center.setTime			1																																																																																											
[state]	acbc-openLinkSwitch	合母联																																																																																									
	var	rtn	0																	#	母联开关状态为1,返回值为1,否则下发控制命令并返回0																																																																												
																																																																																																
	if	(	mpofs	acb.frontIn	0	&	mpofs	acb.commSwitch	0	)	!=	mpofs	acb.commSwitch	0		#	如果母联开关状态为0																																																																												
#		log	"设置联络开关状态--合"	%X	mpofs	acb.frontIn	0
		lock		a.acb.frontOut												#	下发控制母联开关遥控合命令																																																																												
		or	mpofs	a.acb.frontOut	0	mpofs	acb.commSwitch-O	0	
#		log	"888888---"	%X	mpofs	a.acb.frontOut	0
		mp	a.acb.CCO	0													#	开出控制量																																																																												
		unlock		a.acb.frontOut																																																																																											
	else																																																																																															
		var	rtn	1															#	直流输出开关状态为1																																																																												
	endif																																																																																															
[state]	acbc-closeLinkSwitch	分母联																																																																																									
#	log	"设置联络开关状态--分"

	#不论如何都分母联开关																																																																																															
	lock		a.acb.frontOut												#	下发控制直流输出开关遥控分命令																																																																												
	and	mpofs	a.acb.frontOut	0	not	mpofs	acb.commSwitch-O	0																																																																																			
	mp	a.acb.CCO		0													#	控制当前桩后置采样板的直流输出开关为0																																																																												
	unlock		a.acb.frontOut																#	开出控制量																																																																												
																																																																																															
[state]	acbc-linkSwitchState	检测母联开关状态												#																																																																													
	var	rtn	0																																																																																													
																																																																																																
	if	(	(	mpofs	acb.frontIn	0	)	&	mpofs	acb.commSwitch	0	)	=	mpofs	acb.commSwitch	0	#	如果母联开关状态非0																																																																												
		var	rtn	1															#	母联开关状态为1																																																																												
	endif																																																																																															
																																																																																																
#[state]	acbc-openRelease	分泄放												#																																																																													
#	log	"分泄放"
#																																																																																																
#	lock		acb.backOut																#	控制泄放控制为0																																																																												
#																																																																																																
#	var	UID	0																																																																																													
#	var	UID	(	0x98c10000		|	(	(	mpofs	center.backAddr		mp	center.curPile		)	<<	8	)	)																																																																													
#	var	UID	(	var	UID	|	(	mpofs	center.addr		mp	center.curPile		)	)																																																																																	
#																																																																																																
#	var	len	2																																																																																													
#	varsz	dt	2																																																																																													
#	vardt	dt	0	2	mpofs	acb.backOut		mp	center.curPile																																																																																							
#	and	var	dt		not	mp	acb.leakLoop																																																																																									
#																																																																																																
#	canwr	acb.state			addr	UID																																																																																										
#																																																																																																
#	unlock		acb.backOut																																																																																													
#	
##tag	command						#	主逻辑控制											#																																																																																					
																																																																																																								
[state]	acb-startCharging	充电机起机中												#																																																																																					
#tag	command																		#																																																																																					
	#log	" ****** Begin Charging ----------"																																																																																																						
																																																																																																								
#	mp	center.curGun			0														#	初始化A枪充电时间变量																																																																																				
#	mp	center.setTime			0														#	开始时间																																																																																				
#	mp	center.setTime			1														#	结束时间																																																																																				
#	mp	center.curGun			1														#	初始化B枪充电时间变量																																																																																				
#	mp	center.setTime			0														#	开始时间																																																																																				
#	mp	center.setTime			1														#	结束时间																																																																																				
#	mp	center.curGun			0																																																																																																			
	#log	"充电机起机中="	gun
#	call	acbc-isLinkOK

	call	acbc-setStartTime															#	设置启机时间																																																																																																					
																																																																																																								
	mp	center.bms_version		0														#	初始化bms版本																																																																																																
	mp	center.cardStop			0														#	将"刷卡停机"标识置为0																																																																																				
	mp	acb.startOK				0																																																																																																		
	mp	acb.linkGunNum				0																																																																																																		
	mp	acb.timeCount				0																																																																																																		
#	var	linkCarOK-a		mp	acb.linkCarState-1			&	0x01						#	判断初始枪																																																																																				
#	if	var	linkCarOK-a		!=	0																																																																																																		
#		mp	center.curGun				0																																																																																																	
#	else																																																																																																							
#		mp	center.curGun				1																																																																																																	
#	endif																																																																																																							
																																																																																																								
	mpofs	center.stopReason				0	0										#	将停止原因复位(A枪)																																																																																				
#	mpofs	center.stopReason				1	0										#	将停止原因复位(B枪)																																																																																				
	mp	center.fatal				0													#	将致命错误置为0																																																																																				
	mp	acb.startStatus				0																																																																																																		
	mpofs	acb.acbStopReason				0	0																																																																																																	
#	mpofs	acb.acbStopReason				1	0										#	将停止原因复位(B枪)																																																																																				
	mp	center.insultFail				0												#	默认绝缘检测失败状态为0																																																																																				
																																																																																																								
	call	acbc-resetTimeKwh															#	复位分时电量																																																																																				
	mp	acb.moneyCount				0																																																																																																		
	mp	acb.kwhCount				0																																																																																																		
	mp	acb.timeCount				0																																																																																																		
	mp	bms.soc				0																																																																																																		
	mp	bms.rmnTime				0																																																																																																		
	mp	center.serviceCost	0																																																																																																							
	statemp		acb.state-tmo			idle				0									#	停止超时动作																																																																																				
	statemp		acb.state-send			idle				0									#	停止超时发送动作																																																																																				
	log	"isAsistV24="	mp	center.isAsistV24	
	if	mp	center.isAsistV24	=	1				#	如果需要24V电源则进行切换
		call	acbc-doSwitchV
	endif
	
	call	acbc-doAccPowerOff																	#	切辅助电源																																																																																				
	call	acbc-doCutRelease																	#	切泄放,防止泄放未切																																																																																				
	call	acbc-isInAlarmStatus																#	S1.判断有无报警,有报警则停机																																																																																				
	if	var	rtn	!=	0																			#	有报警信号,则停机																																																																																				
																																																																																																								
		log	"find center alarm, change to stop beginProcess, alarmStatus: "																																																																																						
																																																																																																								
		mpofs	acb.acbStopReason			0			1						#	充电停止原因1:启动中有报警																																																																																				
		statemp		acb.state		acb-stopBeginProcess				0						#	直接调用停止流程																																																																																				
		statemp		acb.state-tmo			idle			0									#	锁枪超时时,直接跳至起机失败节点																																																																																				
		statemp		acb.state-send			idle			0									#	暂停重复执行定时器																																																																																				
	else																																																																																																							
		mp	acb.doLockCarFlag				0																																																																																																	
		call	acbc-lockGunToCar																#	枪与车上锁																																																																																				
																																																																																																								
		mpofs		acb.acbStopReason	0				30						#	停止充电原因:30.启动前锁枪失败																																																																																				
		statemp		acb.state-tmo		acb-stopBeginProcess			10000					#	锁枪超时时,直接跳至起机失败节点																																																																																				
		statemp		acb.state-send		acbc-lockGunToCar				2000					#	2S锁/解锁一次																																																																																				
		statemp		acb.state			acb-waitLockGunOK				0						#																																																																																					
	endif																						#	等待绝缘检测																																																																																				
	mp	center.usedPileNum	1															#	默认使用一个桩																																																																																				
	mp	acb.timeCount		0																																																																																																				
	mp	acb.kwhCount		0																																																																																																				
																																																																																																								
	#varsz	t	2	#time,time2a都需要分配2个int的空间	joy封掉，无用																																																																																																	
	#var	t	0	#表示取当前时间																																																																																																				
	#time	addr	t	#得时间,从1970年起的秒与微秒																																																																																																				
	#mp	acb.chgrRunTime			var	t																																																																																																		
	mpofs	center.beginKwh			mp	center.curPile			mp	acb.curKwh																																																																																														
#	log	"当前KWH="	mpofs	center.beginKwh			mp	center.curPile																																																																																																								
[state]	acb-waitLockGunOK	等待锁枪成功												#																																																																																					
	#log	"等待锁枪成功"	gun
	#log	"-"	gun	"------------ state:"				mpofs	acb.frontIn	0																																																																																													
	call	acbc-checkAlarmInStartProcess						#检查起机过程中是否有报警																																																																																																
	call	acbc-checkGunToCarState								#	检查枪连接车状态																																																																																				
	if	mp	acb.linkCarState	=	0x03								#连接且锁定成功																																																																																																	
		#log	"find gun unlike car in waiting gun lock to car !!!"																																																																																																					
		mpofs		acb.acbStopReason			0			30						#	停止充电原因:30.启动前锁枪失败																																																																																					
																																																																																																								
		if	<<insul-11>>		=	1																																																																																																		
			statemp		acb.state-tmo			idle				0								#	锁枪超时时,直接跳至起机失败节点																																																																																			
			statemp		acb.state-send			idle				0								#	暂停重复执行定时器																																																																																			
			statemp		acb.state			acb-startCheckInsulation				mini			#																																																																																			
		else																																																																																																						
			statemp		acb.state-tmo			idle				0																																																																																												
			statemp		acb.state-send			idle				0																																																																																												
			statemp		acb.state			acb-startAGunCharging				mini																																																																																												
		endif																																																																																																						
	endif																																																																																																							
[state]	acb-startCheckInsulation	绝缘检测,绝缘检测过程中的起始点												#																																																																																					
#tag	command																																																																																																							
#	log	"绝缘检测,绝缘检测过程中的起始点********"
	#log	"CheckInsulation 1: begin check insulation ******"																																																																																																						
																																																																																																								
	call	acbc-checkAlarmInStartProcess						#检查起机过程中是否有报警																																																																																																
																																																																																																	
	mp	center.insultFail				0						#	默认绝缘检测失败状态为0																																																																																				
	mp	center.insultFail-1				0						#	默认绝缘检测失败状态为0																																																																																				
	mp	center.insultFail-2				0						#	停止过程中的绝缘检测失败																																																																																				
																																																																																																	
	var	batVoltDirect		0																																																																																																				
																																																																																																								
	if	gun	=	0																																																																																																				
		if	(	(	mpofs	acb.frontCmpr		mp	center.curPile		)	&	mpofs	acb.batteryV-neg		mp	center.curPile			)	>	0																																																																																		
			var	batVoltDirect		1																																																																																																		
		endif																																																																																																						
	else																																																																																																							
		if	(	(	mpofs	acb.frontCmpr-b		mp	center.curPile		)	&	mpofs	acb.batteryV-neg		mp	center.curPile			)	>	0																																																																																		
			var	batVoltDirect		1																																																																																																		
		endif																																																																																																						
	endif																																																																																																							
	if	var	batVoltDirect		!=	0													#	电池反接																																																																																				
																																																																																																								
		log	"电池反接!!!!"																																																																																																					
																																																																																																								
		mp		center.insultFail-1			11												#	预置 绝缘检测错误代码11:绝缘检测时检测到反向电池电压																																																																																				
																																																																																																								
		statemp		acb.state-tmo			idle					0																																																																																												
		statemp		acb.state-send			idle					0																																																																																												
		statemp		acb.state			acb-stopInsulationCheck					mini							#	跳至结束绝缘检测流程																																																																																				
																																																																																																								
		return																																																																																																						
	endif																																																																																																							
																																																																																																								
	if	mpofs	acb.batVolt		mp	center.curPile			>	1000									#	如果有电池电压																																																																																				
																																																																																																								
		#log	"CheckInsulation 0: find battery volt in insulation check, stop insulation !!!!"																																																																																																					
																																																																																																								
		mp		center.insultFail-1			6												#	预置 绝缘检测错误代码6:绝缘检测时检测到电池电压																																																																																				
																																																																																																								
		statemp		acb.state-tmo			idle					0																																																																																												
		statemp		acb.state-send			idle					0																																																																																												
		statemp		acb.state			acb-stopInsulationCheck					mini							#	跳至结束绝缘检测流程																																																																																				
																																																																																																								
	else																																																																																																							
		if	(	(	mpofs	acb.backOut		mp	center.curPile		)	&	mp	acb.leakLoop		)	!=	0																																																																																						
																																																																																																								
			mpofs		acb.acbStopReason			0			42							#	启机过程中泄放继电器非法合																																																																																				
			statemp		acb.state-tmo			idle				0																																																																																												
			statemp		acb.state-send			idle				0							#	暂停重复执行定时器																																																																																				
			statemp		acb.state			acb-stopBeginProcess				0							#	直接调用停止流程																																																																																				
		else																																																																																																						
			if	<<colseOutSwitchInsulateCheck>>					=	1																																																																																														
				mp		center.insultFail-1			3									#	预置 绝缘检测错误代码3:合输出继电器失败																																																																																					
				call	acbc-doOutSwitchON																																																																																																			
				#乐陵
				
				if	mp	a.center.chargeType	=	0
					call	acbc-openLinkSwitch	#合母联
				endif
				statemp		acb.state-tmo			acb-stopInsulationCheck				5000																																																																																											
				statemp		acb.state-send			acbc-doOutSwitchON				1000					#	设置重复执行定时器																																																																																					
				statemp		acb.state				acb-closeOutSwitchInsulation				0			#	等待合直流输出开关成功																																																																																					
			#else																																																																																																					
			#	lock		acb.backOut													#	J1.投"绝缘检测																																																																																				
			#	or	mpofs	acb.backOut		mp	center.curPile				mp	acb.insultCheck					#	"设置“绝缘检测控制”为1																																																																																				
			#	mp	acb.CJO		mp	center.curPile																																																																																																
			#	unlock		acb.backOut																																																																																																		
			#	log	"设置充电模块输出电压和输出电流"	mp	bms.maxReqV									#	J2.设置充电模块输出电压和输出电流																																																																																				
			#	mp	chgr.reqV		mp	center.ratedOutV																																																																																															
			#	if	mp	center.bms_version			=	15									#	如果为15版规约,则需要检查最高需求电压																																																																																				
			#		&	mp	chgr.reqV		>	mp	bms.maxReqV	*	100																																																																																											
			#		mp	chgr.reqV		mp	bms.maxReqV	*	100																																																																																																
			#	endif																																																																																																				
			#	#log	"设置充电模块输出电压和输出电流CHGR"	mp	chgr.reqV									#	J2.设置充电模块输出电压和输出电流																																																																																				
			#	mp	chgr.reqC	mp	center.minOutC	*	mp	center.chgrPerPile																																																																																													
			#																																																																																																					
			#	mp	center.insultFail-1				1																																																																																															
			#	call	acbc-startChargerModule														#	启动充电模块																																																																																				
			#																																																																																																					
			#	log	"等待充电模块启动-----------"																																																																																																			
			#																																																																																																					
			#	statemp		acb.state-tmo			acb-stopInsulationCheck					15000					#	设置模块启动操作操作的超时时间																																																																																				
			#	statemp		acb.state-send			idle					0					#	设置重复执行定时器																																																																																				
			#	statemp		acb.state			acb-waitModuleStartInInsulateCheck					0					#	等待模块启动成功																																																																																				
																																																																																																								
			endif																																																																																																					
		endif																																																																																																						
	endif																																																																																																							
																																																																																																								
[state]	acb-closeOutSwitchInsulation	绝缘检测,绝缘检测过程中合输出继电器												#																																																																																					
																																																																																																						
	if	(	mpofs	a.acb.frontIn	gun	&	mpofs	acb.outSwitch	0	)	!=	0			#	如果直流输出开关状态为1																																																																																				
		lock		acb.backOut															#	J1.投"绝缘检测																																																																																				
		or	mpofs	acb.backOut	0	mp	acb.insultCheck							#	"设置“绝缘检测控制”为1																																																																																				
		mp	acb.CJO		mp	center.curPile																																																																																																		
		unlock		acb.backOut																																																																																																				
	#	log	"设置充电模块输出电压和输出电流-chgr.reqV"	mp	chgr.reqV	"--"	mp	bms.maxReqV	"--"	mp	center.ratedOutV	#	J2.设置充电模块输出电压和输出电流	
		mp	chgr.reqV		mp	center.ratedOutV	*	100																																																																																																		
		if	mp	center.bms_version			=	15											#	如果为15版规约,则需要检查最高需求电压																																																																																				
			&	mp	chgr.reqV		>	mp	bms.maxReqV										#	电压均以0.1V为单位																																																																																													
			mp	chgr.reqV		mp	bms.maxReqV	*	100																																																																																																
		endif	
		if	mp	chgr.reqV	>	mp	center.maxOutV	*	100	
			mp	chgr.reqV		mp	center.maxOutV	*	100	
		endif
		mp	chgr.reqC		mp	center.minOutC	*	mp	center.chgrPerPile	*	100																																																																																														
		log	"设置充电模块输出电压和输出电流+chgr.reqV"	mp	chgr.reqV	"++"	mp	bms.maxReqV	"++"	mp	center.ratedOutV	#	J2.设置充电模块输出电压和输出电流	
																																																																																																							
		mp	center.insultFail-1				1																																																																																																	
		call	acbc-startChargerModule																#	启动充电模块																																																																																				
																																																																																																								
#		log	"wait charger modules start ----------"			mp	chgr.reqV																																																																																																				
																																																																																																								
		statemp		acb.state-tmo			acb-stopInsulationCheck					15000		#	结束绝缘检测																																																																																				
		statemp		acb.state-send			idle					0							#	设置重复执行定时器																																																																																				
		statemp		acb.state				acb-waitModuleStartInInsulateCheck		0			#	等待模块启动成功																																																																																				
																																																																																																								
	endif																																																																																																							
																																																																																																								
[state]	acbc-checkAlarmInStartCheckInsult	启动绝缘检测过程中，检查报警												#																																																																																					
																																																																																																								
	call	acbc-isInAlarmStatus																	#	S1.判断有无报警,有报警则停机																																																																																				
	if	var	rtn	!=	0														#	有报警信号,则停机																																																																																				
																																																																																																								
		#log	"find center alarm in checkinsulation, alarmStatus: "										mp	center.alarmStatus																																																																																										
		log	"启动绝缘检测过程中，有报警="	var	rtn
																																																																																																								
		mp		center.insultFail-1			8																																																																																																	
		statemp		acb.state-tmo			idle					0							#	设置模块启动操作操作的超时时间																																																																																				
		statemp		acb.state-send			idle					0							#	设置重复执行定时器																																																																																				
		statemp		acb.state			acb-stopInsulationCheck					0							#	直接调用停止流程																																																																																				
	endif																																																																																																							
																																																																																																								
																																																																																																								
[state]	acb-waitModuleStartInInsulateCheck	在绝缘检测中,等待充电模块开机												#																																																																																					
#tag	command																																																																																																							
#	log	"在绝缘检测中,等待充电模块开机"
	call	acbc-checkAlarmInStartCheckInsult						#启动绝缘检测过程中，检查报警																																																																																																
	call	acbc-isChargerModuleStart																	#	调用启动模块节点																																																																																				
	if	var	rtn	=	1																																																																																																			
		#log	"CheckInsulation 2: the charger module started !!!!!"																																																																																																					
		mp		center.insultFail-1			2												#	预置 绝缘检测错误代码2:输出电压未达到额定电压																																																																																				
																																																																																																								
		statemp	acb.state-tmo	acb-stopInsulationCheck	20000		#	设置等待模块输出电压到达额定电压的超时时间:20S	可根据实际进行调整																																																																																			
		statemp	acb.state	acb-waitOutputUOK	0																																																																																													
	endif																																																																																																							
	call	acbc-isStartInsulationInterrupted						#绝缘监测起机中被中断																																																																																																
																																																																																																								
[state]	acb-waitOutputUOK	绝缘检测中,等待充电模块输出电压达到要求												#																																																																																					
#tag	command																																																																																																							
#	log	"枪"	gun	"绝缘检测中,等待充电模块输出电压达到要求"	mp	chgr.reqV
#	log	"实际电压"	mp	acb.chargeV	
	call	acbc-checkAlarmInStartCheckInsult						#启动绝缘检测过程中，检查报警																																																																																																
	var	need-volt		(	90	*	mp	chgr.reqV			/	10000	)	#	chgr.reqV是以毫伏为单位	acb.chargeV为伏*10																																																																																							
	#log	"charger output volt : "				mp	acb.chargeV		",need volt : "			var	need-volt																																																																																											
	if	mp	acb.chargeV		>	var	need-volt												#	充电机输出电压,达到要求电压的的90%以上 																																																																																				
		log	"OK!!!-绝缘电压达标"																																																																																																					
		mp		center.insultFail-1			3												#	预置 绝缘检测错误代码3:绝缘对地电压值不达标																																																																																				
																			#	J5.判断绝缘正对地电压是否达到要求																																																																																				
		statemp		acb.state-tmo			idle			0									#	停止超时定时																																																																																				
		statemp		acb.state-send			idle			0									#	暂停重复执行定时器																																																																																				
		statemp		acb.state			acb-waitInsultUOK			mini									#	等待绝缘正对地电压是否达到要求																																																																																				
	endif																																																																																																							
	call	acbc-isStartInsulationInterrupted							#绝缘监测起机中被中断																																																																																															
[state]	acb-waitInsultUOK	绝缘检测中,检测绝缘正对地电压是否达到要求												#																																																																																					
#tag	command																																																																																																							
#	log	"绝缘检测中,检测绝缘正对地电压是否达到要求"
																																																																																																								
	call	acbc-checkAlarmInStartCheckInsult						#启动绝缘检测过程中，检查报警																																																																																																
																																																																																																								
	var	insuVp-need			mp	acb.chargeV													#	绝缘电压的标准值:输出电压的一半																																																																																				
																																																																																																								
	log	"charger insulation positive volt : "							mp	acb.insuVp		", standard:"		mp	acb.chargeV																																																																																										
	if	(	mp	acb.insuVp		>	var	insuVp-need			/	10	)						#	判断绝缘正对地电压应该大于额定电压的0.1或者大于额定电压的0.9																																																																																				
		&	(	mp	acb.insuVp		<	9	*	var	insuVp-need			/	10	)																																																																																								
		log	"-----绝缘监测正常------"																																																																																																							
		#log	"CheckInsulation 4: the insulation positive U is OK !!!!!!"																#	绝缘正对地电压达到要求																																																																																				
																																																																																																								
		mp	center.insultFail-1			0													#	绝缘检测错误代码0:绝缘检测成功																																																																																				
	else																																																																																																							
		log	"!!!!!!绝缘监测异常!!!!!!"																																																																																																							
																																																																																																								
		mp	center.insultFail-1			0													#	绝缘检测错误代码3:绝缘对地电压值不达标																																																																																				
	endif																																																																																																							
																																																																																																								
	statemp		acb.state		acb-stopInsulationCheck				mini										#	调用绝缘检测结束节点																																																																																				
																																																																																																								
																																																																																																								
[state]	acbc-checkAlarmInStopCheckInsult	停止绝缘检测过程中，检查报警												#																																																																																					
#	log	"停止绝缘检测过程中，检查报警"
																																																																																																								
	call	acbc-isInAlarmStatus																	#	S1.判断有无报警,有报警则停机																																																																																				
	if	var	rtn	!=	0														#	有报警信号,则停机																																																																																				
																																																																																																								
		#log	"find center alarm in checkinsulation, alarmStatus: "										mp	center.alarmStatus																																																																																										
																																																																																																								
		mp		center.insultFail-1			8																																																																																																	
	endif																																																																																																							
																																																																																																								
																																																																																																								
[state]	acb-stopInsulationCheck	结束绝缘检测												#																																																																																					
#tag	command																		#	停止步骤:模块停机,投泄放,切泄放,判断绝缘正对地电压是否够低																																																																																				
#	log	"结束绝缘检测"
																																																																																																								
	call	acbc-checkAlarmInStopCheckInsult						#停止绝缘检测过程中，检查报警																																																																																																
																																																																																																								
	#log	"CheckInsulation 5: stop insulation check , center.insultFail:"											mp	center.insultFail-1																																																																																										
																																																																																																								
	if	mp	center.insultFail-1			!=	0																																																																																																	
																																																																																																								
		log	"get fail in insulation check !---------------------------------------------------"	mp	center.insultFail-1																																																																																																				
	endif																																																																																																							
																																																																																																								
	mp	center.insultFail-2				0													#	绝缘检测时,停止过程中产生的错误代码																																																																																				
																																																																																																								
	#	暂时将切绝缘检测的时间放在泄放之后																																																																																																						
	#	lock		acb.backOut															#	J6.切"绝缘检测"																																																																																				
	#	and	mpofs	acb.backOut		mp	center.curPile			not	mp	acb.insultCheck							#	控制绝缘检测控制为0																																																																																				
	#	mp	acb.CJO		mp	center.curPile																																																																																																		
	#	unlock		acb.backOut																																																																																																				
																																																																																																								
	mp	center.insultFail-2				4													#	绝缘检测错误代码4:充电模块停机异常																																																																																				
																																																																																																								
	call	acbc-stopChargerModule																	#	J7.停充电模块																																																																																				
																																																																																																								
	#log	"wait charger modules stop -------------"																																																																																																						
																																																																																																								
	statemp		acb.state-tmo			acb-stopModuleFatalError					15000		#	超时调用"致命错误节点"																																																																																				
	statemp		acb.state-send			acbc-stopChargerModule						500			#	设置重复执行定时器																																																																																				
	statemp		acb.state			acb-waitModuleStopInInsulateCheck				0			#	等待模块停机																																																																																				
																																																																																																								
																																																																																																								
[state]	acb-waitModuleStopInInsulateCheck	绝缘检测中,等待模块停机												#																																																																																					
#tag	command																																																																																																							
	log	"绝缘检测中,等待模块停机"	gun
																																																																																																								
	call	acbc-checkAlarmInStopCheckInsult						#停止绝缘检测过程中，检查报警																																																																																																
																																																																																																								
	call	acbc-isChargerModuleStop																																																																																																						
																																																																																																								
	if	var	rtn	=	1																																																																																																			
																																																																																																								
		log	"CheckInsulation 6: stop successful charger module in insulation check !!!"	gun																																																																																																					
																																																																																																								
		#log	"CheckInsulation 7: put release in insulation check !!!"																																																																																																					
																																																																																																								
		mp	center.insultFail-2				7												#	预置 绝缘检测错误代码7:分输出继电器失败																																																																																				
		call	acbc-doOutSwitchOFF																																																																																																					
																																																																																																								
		statemp		acb.state-tmo			acb-finalInsultCheck					5000							#	致命错误3:分直流输出开关失败																																																																																				
		statemp		acb.state-send			acbc-doOutSwitchOFF					1000							#	设置重复执行定时器																																																																																				
		statemp		acb.state			acb-openOutSwitchInRelease					0							#	K2.等待分直流输出开关																																																																																				
	endif																																																																																																							
																																																																																																								
																																																																																																								
[state]	acb-openOutSwitchInRelease	绝缘检测中,分输出继电器												#																																																																																					
	log	"绝缘检测中,分输出继电器"
																																																																																																								
	if	(	mpofs	acb.backIn		mp	center.curPile		&	mpofs	acb.outSwitch		mp	center.curPile		)	=	0	#	如果直流输出开关状态为0																																																																																				
																																																																																																								
		call	acbc-doPutRelease																#	控制泄放控制为1																																																																																				
																																																																																																								
		statemp		acb.state-tmo			acb-cutReleaseInInsulateCheck					3000							#	等待3秒钟后,调用切泄放																																																																																				
		statemp		acb.state-send			idle					0																																																																																												
		statemp		acb.state			acb-checkAlarmInRelease					0							#	J9.切泄放																																																																																				
	endif																																																																																																							
																																																																																																								
[state]	acb-checkAlarmInRelease	判断有无报警												#																																																																																					
	#log	"判断有无报警"
																																																																																																								
	call	acbc-isInAlarmStatus																	#	S1.判断有无报警,有报警则停机																																																																																				
	if	var	rtn	!=	0														#	有报警信号,则停机																																																																																				
																																																																																																								
		log	"find center alarm in checkinsulation, alarmStatus: "										mp	center.alarmStatus																																																																																										
																																																																																																								
		mp		center.insultFail-1			8																																																																																																	
	endif																																																																																																							
																																																																																																								
																																																																																																								
[state]	acb-cutReleaseInInsulateCheck	绝缘检测中,切泄放												#																																																																																					
#tag	command																																																																																																							
																																																																																																								
	#log	"CheckInsulation 8: cut release in insulation check !!!"																																																																																																						
																																																																																																								
	#	将切绝缘放在切泄放之后																																																																																																						
	log	"绝缘检测中,切泄放"
	lock		acb.backOut																#	J6.切"绝缘检测"																																																																																				
	and	mpofs	acb.backOut		mp	center.curPile			not	mp	acb.insultCheck		#	控制绝缘检测控制为0																																																																																				
	mp	acb.CJO		mp	center.curPile																																																																																																			
	unlock		acb.backOut																																																																																																					
																																																																																																								
	call	acbc-doCutRelease																	#	控制泄放控制为0																																																																																				
																																																																																																								
	mp	center.insultFail-2			12														#	绝缘检测错误代码5:分泄放不成功																																																																																				
																																																																																																								
	statemp		acb.state-tmo			acb-finalInsultCheck				5000									#																																																																																					
	statemp		acb.state-send			acbc-doCutRelease				1000									#	暂停重复执行定时器																																																																																				
	statemp		acb.state			acb-waitOpenRelease				0									#	J10.等待分泄放成功																																																																																				
																																																																																																								
																																																																																																								
[state]	acb-waitOpenRelease	绝缘检测中,等待切泄放成功												#																																																																																					
	log	"绝缘检测中,等待切泄放成功"
	if	(	(	mpofs	acb.backOut	0	)	&	mp	acb.leakLoop	)	=	0		#	泄放开入为0																																																																																				
		&	(	canid	&	0xFF0000	)	=	0xD10000									#	收到D1																																																																																				
		mp	center.insultFail-2			5													#	绝缘检测错误代码5:分泄放不成功(电压)																																																																																				
		statemp		acb.state-tmo			acb-RelaseFailFatalError				6000								#																																																																																					
		statemp		acb.state-send			idle				0								#	暂停重复执行定时器																																																																																				
		statemp		acb.state			acb-checkOutUDown				0								#	J10.等待输出电压降到规定电压																																																																																				
	endif																																																																																																							
[state]	acb-checkOutUDown	绝缘检测中,投切泄放后,检测直流输出电压是否下降到指定值												#																																																																																					
#tag	command																																																																																																							
	log	"绝缘检测中,投切泄放后,检测直流输出电压是否下降到指定值"	mp	acb.chargeV
																																																																																																								
	call	acbc-checkAlarmInStopCheckInsult						#停止绝缘检测过程中，检查报警																																																																																																
																																																																																																								
	log	"after put release, the charger volt:"							mp	acb.chargeV																																																																																														
																																																																																																								
	if	mp	acb.chargeV		<	600													#	直流输出电压小于60V																																																																																				
																																																																																																								
		mp	center.insultFail-2			0													#	绝缘检测最终成功																																																																																				
		log	"CheckInsulation 9: the output volt is down successful in insulation check !!!"																																																																																																					
																																																																																																								
		statemp		acb.state		acb-finalInsultCheck				mini																																																																																														
		statemp		acb.state-tmo			idle				0																																																																																													
		statemp		acb.state-send			idle				0								#	暂停重复执行定时器	
	else			#防止模块假停机
		call	acbc-stopChargerModule
	endif																																																																																																							
																																																																																																								
																																																																																																								
[state]	acb-finalInsultCheck	绝缘检测最终节点												#																																																																																					
#tag	command																																																																																																							
	log	"绝缘检测最终节点"
																																																																																																								
	call	acbc-checkAlarmInStopCheckInsult						#停止绝缘检测过程中，检查报警																																																																																																
																																																																																																								
	mp	center.insultFail			mp	center.insultFail-1																																																																																																		
	if	(	mp	center.insultFail-1			=	0	)										#	判断绝缘检测失败标志																																																																																				
		&	(	mp	center.insultFail-2			!=	0	)																																																																																														
		mp	center.insultFail			mp	center.insultFail-2																																																																																																	
	endif																																																																																																							
																																																																																																								
	log	"CheckInsulation 10: finally insulate check, result center.insultFail:"											mp	center.insultFail																																																																																										
																																																																																																								
	if	mp	center.insultFail			!=	0																																																																																																	
																																																																																																								
		mpofs		acb.acbStopReason			0			2								#	停止充电原因:2.绝缘检测失败																																																																																				
																																																																																																								
		statemp		acb.state-tmo			idle				0																																																																																													
		statemp		acb.state-send			idle				0								#	暂停重复执行定时器																																																																																				
		statemp		acb.state			acb-stopBeginProcess				0								#	停止起机																																																																																				
	else																																																																																																							
		if	(	mpofs	acb.frontCmpr	0	&	mpofs	acb.linkOK	0	)	=	mpofs		acb.linkOK	0																																																																														
			var	link-a		1																																																																																																		
		endif																																																																																																						
		if	mp	center.bms_version			=	15																																																																																																
				#15版绝缘检测完成																																																																																																				
				#log	"15版绝缘检测完成"																																																																																																			
				if	mp	center.chgStatus			<	const	st-insulok																																																																																													
					mp	center.chgStatus			const	st-insulok									#	设置充电状态为"绝缘检测成功"																																																																																				
				endif																																																																																																				
																																																																																																								
				statemp		acb.state			acb-waitToCloseLinkSwitchState					-1000					#	等待充电状态变为起机中																																																																																				
		else																																																																																																						
			#log	"前置绝缘检测完成"																																																																																																				
			if	var	link-a	!=	0												#	A枪连接,则启动A枪																																																																																				
				statemp		acb.state			acb-startAGunCharging				0																																																																																											
			endif																																																																																																					
		endif																	#	开始A枪充电																																																																																				
																			#	开始A枪充电																																																																																				
		statemp		acb.state-tmo			idle				0																																																																																													
		statemp		acb.state-send			idle				0								#	暂停重复执行定时器																																																																																				
	endif																																																																																																							
																																																																																																								
																																																																																																								
[state]	acb-startAGunCharging	启动充电												#																																																																																					
#	log	"A枪启动充电"	gun
																																																																																																								
#	mp	center.curGun			0														#	将"当前枪"标识设为0(A枪)																																																																																				
#	mp	center.setTime			0														#	开始时间																																																																																				
#	mp	center.setTime			1														#	结束时间																																																																																				
																																																																																																								
	call	acbc-setStartTime																																																																																																						
																																																																																																								
	mp	acb.startOK				0																																																																																																		
																																																																																																								
	mp	acb.startStatus				0																																																																																																		
	call	acbc-setBeginTimeKwh																	#	设置起始分时电量																																																																																				
																																																																																																								
	#log	"begin"		mp	center.curPile			"Gun Charging ------------------ "																																																																																																
																																																																																																								
	call	acbc-isInAlarmStatus																																																																																																						
	if	var	rtn	!=	0														#	有报警信号,则停机																																																																																				
		mpofs	acb.acbStopReason			0			1									#	充电停止原因1:启动中有报警																																																																																				
		statemp		acb.state		acb-stopBeginProcess				0									#	直接调用停止流程																																																																																				
	endif																																																																																																							
																																																																																																								
																																																																																																								
#	mpofs		acb.acbStopReason			0			3									#	停止原因3:启动中,控制辅助电源电压检测切换失败																																																																																				
#	call		acbc-doAccPowerUCheckON																#	投入"辅助电源电压检测切换"																																																																																				
#																																																																																																								
#	statemp		acb.state			acb-waitAccPowerUCheckON				0									#	停止充电原因:3."辅助电源电压检测切换"控制失败																																																																																				
#	statemp		acb.state-tmo			acb-stopBeginProcess				5000									#	设置投辅助电源超时动作																																																																																				
#	statemp		acb.state-send			acbc-doAccPowerUCheckON				1000									#	设置重复执行定时器																																																																																				
																																																																																																								
	mpofs		acb.acbStopReason			0			4									#	停止充电原因:4.投辅助电源失败																																																																																				
																																																																																																								
	call		acbc-doAccPowerOn															#	投辅助电源																																																																																					
	#log	"START 2: begin change BMS assist power supply to ON ----------"																																																																																																						
																																																																																																								
	statemp		acb.state-tmo			acb-stopBeginProcess				15000																																																																																														
	statemp		acb.state-send			acbc-doAccPowerOn				1000								#	设置重复执行定时器																																																																																					
	statemp		acb.state			acb-waitAccPowerOn				0								#	等待辅助电源投入																																																																																					
[state]	acbc-checkAlarmInStartProcess	起机过程中检查报警												#																																																																																					
	#log	"起机过程中检查报警"
	call	acbc-isInAlarmStatus																																																																																																						
	if	var	rtn	!=	0														#	有报警信号,则停机																																																																																				
		log	"起机过程中有报警"
		mpofs		acb.acbStopReason			0			1								#	充电停止原因1:启动中有报警																																																																																				
		statemp		acb.state-tmo			idle				0																																																																																													
		statemp		acb.state-send			idle				0								#	暂停重复执行定时器																																																																																				
		statemp		acb.state			acb-stopBeginProcess				0								#	直接调用停止流程																																																																																				
	endif																																																																																																							
																																																																																																								
[state]	acb-waitAccPowerOn	等待辅助电源投入												#																																																																																					
#tag	command																																																																																																							
#	log	"等待辅助电源投入"	gun
																																																																																																								
	call	acbc-checkAlarmInStartProcess						#检查起机过程中是否有报警																																																																																																
																																																																																																								
		if	func	acbc-isAccPowerOn	gun	!=	0											#	检测到辅助电源																																																																																				
																																																																																																								
		#log	"-"	gun	":START 2: BMS assist power supply changed to ON OK OK OK OK !!!!!!"																																																																																																			
																																																																																																								
		call	acbc-isStartInterrupted																#	检查启动过程是否被中断																																																																																				
																																																																																																								
		if	mp	center.chgStatus			<	const	st-handshake																																																																																															
			mp	center.chgStatus			const	st-handshake											#	设置充电状态为"握手"																																																																																				
		endif																																																																																																						
#		log	"辅助电源投入"	gun
																																																																																																								
		#log	"gun"	gun	":acb set center.chgStatus to st-handshake @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"																																																																																																			
																																																																																																								
		#log	"gun"	gun	":START 3: wait center.state change to CloseLinkSwitchState ----------"																																																																																																			
		mpofs		acb.acbStopReason			0			21									#	停止充电原因:BMS通信失败 未检测到版本号																																																																																				
		
		statemp		acb.state-tmo			acb-stopBeginProcess				15000			#	超时转至停止流程																																																																																											
#		statemp		acb.state-tmo			idle					0							#	停止计量超时时间																																																																																				
		statemp		acb.state-send			idle					0							#	设置重复执行定时器																																																																																				
		statemp		acb.state			acb-waitBmsVersionState					0				#	等待检测到版本号																																																																																				
	endif																																																																																																							
																																																																																																								
	call	acbc-isStartInterrupted																																																																																																						
																																																																																																								
																																																																																																								
[state]	acb-waitBmsVersionState	等待bms检测到版本号												#																																																																																					
#tag	command																																																																																																							
	log	"等待bms检测到版本号"	mp	center.bms_version
	call	acbc-isStartInterrupted																	#	检查启动过程是否被中断																																																																																				
																																																																																																								
	if	mp	center.bms_version			=	15																																																																																																	
																																																																																																								
		if	<<insul-15>>																																																																																																					
			#15版绝缘检测																																																																																																					
			log	"检测版本号成功"
			statemp		acb.state-tmo			idle					0					#	停止计量超时时间																																																																																					
			statemp		acb.state-send			idle					0					#	设置重复执行定时器																																																																																					
			statemp		acb.state			acb-waitToInsulationState	0					#	等待跳转至"绝缘检测"节点																																																																																					
		else																																																																																																						
			#跳过15版绝缘检测																																																																																																					
			statemp		acb.state-tmo			idle					0					#	停止计量超时时间																																																																																					
			statemp		acb.state-send			idle					0					#	设置重复执行定时器																																																																																					
			statemp		acb.state	acb-waitToCloseLinkSwitchState		0					#	等待跳转至"合联络开关"节点																																																																																					
		endif																																																																																																						
	endif																																																																																																							
																																																																																																								
[state]	acb-waitToInsulationState	等待跳转至"绝缘检测"节点												#																																																																																					
#tag	command																																																																																																							
	#log	"等待跳转至"绝缘检测"节点"
																																																																																																								
	#log	"wait center status to st-insul state, now status is : "									mp	center.chgStatus																																																																																												
																																																																																																								
	if	mp	center.chgStatus			=	const	st-insul											#	等待充电状态变为"绝缘检测"																																																																																				
																																																																																																								
		#log	"START 3: the center status changed to st-insul,begin to check insulation !!!!"																																																																																																					
		#log	"开始绝缘检测"																																																																																																					
																																																																																																								
		statemp		acb.state			acb-startCheckInsulation				mini								#	开始进行绝缘检测																																																																																				
																																																																																																								
	elseif		mp	center.chgStatus			>=	const	st-stop										#	如果状态变为停机中,则转停机流程																																																																																				
																																																																																																								
		#log	"**** FAIL : the center status changed to st-stop, begin to stop  begin process !!!!"																																																																																																					
																																																																																																								
		statemp		acb.state-tmo			idle				0																																																																																													
		statemp		acb.state-send			idle				0																																																																																													
		statemp		acb.state			acb-stopBeginProcess				0		
	else
		log	"!!!!="	mp	center.chgStatus	
	endif																																																																																																							
																																																																																																								
																																																																																																								
[state]	acb-waitToCloseLinkSwitchState	等待跳转至合联络开关节点												#																																																																																					
#tag	command																																																																																																							
																																																																																																								
	#log	"-"	gun	":****************************************************************************************************************"																																																																																																				
	#log	"-"	gun	":****************************************************************************************************************"																																																																																																				
	#log	"-"	gun	":wait center status to st-start, now status is : "						mp	center.chgStatus																																																																																													
	#log	"-"	gun	":****************************************************************************************************************"																																																																																																				
	#log	"-"	gun	":****************************************************************************************************************"																																																																																																				
	#log	"等待跳转至合联络开关节点"	mp	center.chgStatus
																																																																																																								
	call	acbc-checkAlarmInStartProcess						#检查起机过程中是否有报警																																																																																																
																																																																																																								
	if	mp	center.chgStatus			=	const	st-start											#	等待充电状态变为"起机中"																																																																																				
																																																																																																								
		mpofs		acb.acbStopReason			0			6								#	停止充电原因 6.启动中,检测电池电压失败																																																																																				
																																																																																																								
	#	call		acb-doPutBatUCheck															#	执行"电池电压检测"操作																																																																																				
																																																																																																								
		log	"-"	gun	":START 4: wait get battery volt ------------"																																																																																																			
																																																																																																								
		statemp		acb.state-tmo			acb-stopBeginProcess				20000								#	暂停超时等待																																																																																				
	#	statemp		acb.state-send			acb-doPutBatUCheck				1000								#	设置重复执行定时器																																																																																				
		statemp		acb.state-send			idle				0								#	设置重复执行定时器																																																																																				
		statemp		acb.state			acb-waitGetBatteryU				0								#	等待检测到电池电压																																																																																				
																																																																																																								
	elseif		mp	center.chgStatus			>=	const	st-stop										#	如果状态变为停机中,则转停机流程																																																																																				
																																																																																																								
		#log	"-"	gun	":**** FAIL : the center status changed to st-stop, begin to stop  begin process !!!!"																																																																																																			
																																																																																																								
		statemp		acb.state-tmo			idle				0																																																																																													
		statemp		acb.state-send			idle				0																																																																																													
		statemp		acb.state			acb-stopBeginProcess				0																																																																																													
	endif																																																																																																							
																																																																																																								
	call	acbc-isStartInterrupted																																																																																																						
																																																																																																								
																																																																																																								
[state]	acb-waitGetBatteryU	等待检测到电池电压												#																																																																																					
#tag	command																																																																																																							
#	log	"等待检测到电池电压"
	call	acbc-checkAlarmInStartProcess						#检查起机过程中是否有报警																																																																																																
	call	acbc-isStartInterrupted	
	call	acbc-doOutSwitchON
	
	#JINGZHENGTESTif	func	acbc-isGetBatteryU			0	!=	0											#	如果有电池电压																																																																																				
	if	1										#	如果有电池电压																																																																																				
																			#	S7.合直流输出开关																																																																																				
		#log	"-"	gun	":START 4: get battery volt OK OK OK OK OK OK !!!!!"																																																																																																			
																																																																																																								
		mpofs		acb.acbStopReason			0			7								#	停止充电原因:7.合直流输出开关失败																																																																																				
		call	acbc-doOutSwitchOFF																																																																																																						
#		var	chgrState		0																																																																																																			
#		if	gun	=	0														#	辅助桩辅助充电中																																																																																				
#			var	chgrState		mp	b.center.chgStatus																																																																																																	
#		else																																																																																																						
#			var	chgrState		mp	a.center.chgStatus																																																																																																	
#		endif																																																																																																						
#																																																																																																								
#		if	var	chgrState		=	1																																																																																																	
#			#log	"assist: gun"			gun	" batU check set confirm assist ++++++"																																																																																																
#			mp	chgr.assit			2																																																																																																	
#		endif																																																																																																						
																																																																																																								
		if	(	(	mpofs	acb.backOut	0	)	&	mp	acb.leakLoop		)	!=	0																																																																																						
			mpofs		acb.acbStopReason			0			42							#	停止充电原因:42.启机过程中，泄放开关合																																																																																				
			statemp		acb.state-tmo			idle				0																																																																																												
			statemp		acb.state-send			idle				0							#	暂停重复执行定时器	
			#log	"++++++acb-stopBeginProcess"
			statemp		acb.state			acb-stopBeginProcess				0				#	直接调用停止流程																																																																																				
		else
			statemp	acb.state-tmo	idle					0							#	暂停超时等待																																																																																				
			statemp	acb.state-send	idle					0							#	设置重复执行定时器																																																																																				
			statemp	acb.state		acb-15-beginCharging	mini						#	转到2015规约处理流程																																																																																				
		endif
#			call	acbc-closeLinkSwitch																																																																																																				
#			statemp		acb.state-tmo			acb-stopBeginProcess				10000																																																																																												
#			statemp		acb.state-send			acbc-closeLinkSwitch				1000		#	设置重复执行定时器																																																																																				
#			statemp		acb.state				acb-waitLinkSwitchON				0				#	等待合直流输出开关成功																																																																																				
#		endif																																																																																																						
																																																																																																								
	endif																																																																																																							
																																																																																																								
																																																																																																								
[state]	acb-waitLinkSwitchON	等待输出开关状态为1												#																																																																																					
	#log	"等待输出开关状态为1"
	#var	needCloseLinkSwitch			0																																																																																																			
	#call	acbc-linkSwitchState																																																																																																						
	#if	(	var	rtn	=	1	&	mp	chgr.assit		=	2	)																																																																																											
	#	|	mp	chgr.assit			!=	2																																																																																																
	#	var	needCloseLinkSwitch			1							#联络状态开关正常																																																																																											
	#endif																																																																																																							
	#																																																																																																							
	#if	var	needCloseLinkSwitch			=	1																																																																																																	
	#	if	mp	center.bms_version	=	15	#2015规约																																																																																													
	#		statemp	acb.state-tmo	idle					0							#	暂停超时等待																																																																																				
	#		statemp	acb.state-send	idle					0							#	设置重复执行定时器																																																																																				
	#		statemp	acb.state		acb-15-beginCharging	mini						#	转到2015规约处理流程																																																																																				
	#	endif																																																																																																						
	#endif																																																																																																							
																																																																																																								
[state]	acb-15-beginCharging	15版开始充电												#																																																																																					
#	log	"15版开始充电"
	call	acbc-checkAlarmInStartProcess						#检查起机过程中是否有报警																																																																																																
	#启动充电模块																																																																																																							
	mpofs		acb.acbStopReason			0			8									#	停止充电原因:8.启动充电模块失败																																																																																				
																																																																																																								
	mp	chgr.reqV		mp	bms.batVolt	*	100									#启动模块时充电模块输出电压设置为bms获取的电池电压																																																																																				
	mp	chgr.reqC		mp	center.minOutC	*	mp	center.chgrPerPile	*	100	#	输出电流为最小额定电流																																																																																				
																																																																																																								
#	log	"acb staring charger:"				mp	chgr.reqV		"-"	mp	chgr.reqC																																																																																													
	call		acbc-startChargerModule																#	启动充电模块																																																																																				
	#log	"START 6: begin to start charger module --------- "																																																																																																						
	statemp		acb.state-tmo			acb-stopBeginProcess						15000																																																																																												
	statemp		acb.state-send			idle						0							#	设置重复执行定时器																																																																																				
	statemp		acb.state			acb-15-waitModuleStartInStartProcess						0							#	等待启动充电模块成功																																																																																				
[state]	acb-15-waitModuleStartInStartProcess	在正式开机过程中,等待启动充电模块												#																																																																																					
#	log	"15在正式开机过程中,等待启动充电模块"
																																																																																																								
	call	acbc-checkAlarmInStartProcess						#检查起机过程中是否有报警
	
	if	(	mpofs	acb.frontIn	0	&	mpofs	acb.outSwitch	0		)	!=	0	#	如果直流输出开关状态为1																																																																																				
		call	acbc-doOutSwitchOFF																																																																																																						
	endif																																																																																																						
																																																																																																								
	call		acbc-isChargerModuleStart																#	启动充电模块																																																																																				
																																																																																																								
	if	var	rtn	=	1																																																																																																			
																			#	S9.启动充电机成功,将状态置为"启动中"																																																																																				
		log	"START 7: start charger modules in startprocess successful OK OK OK OK OK OK !!!!!!!"																																																																																																					
																																																																																																								
		mpofs		acb.acbStopReason			0			33								#	停止充电原因:33.起机时,输出电压不达标																																																																																				
																																																																																																								
		statemp		acb.state-tmo			acb-stopBeginProcess				15000																																																																																													
		statemp		acb.state-send			idle				0																																																																																													
		statemp		acb.state			acb-15-waitChargerOutputOK				1000								#	等待充电模块输出电压达标																																																																																				
																																																																																																								
	endif																																																																																																							
																																																																																																								
	call	acbc-isStartInterrupted																	#	检查启动过程是否被中断																																																																																				
																																																																																																								
[state]	acb-15-waitChargerOutputOK	在正式开机过程中,等待充电模块输出正常												#																																																																																					
	log	"等待充电模块输出正常"	mp	bms.batVolt	"and"	mp	acb.chargeV		"###"	mp	bms.maxReqV																																																																																																					
	call	acbc-checkAlarmInStartProcess						#检查起机过程中是否有报警																																																																																																
	
	#此处后续需解封 
	#var	abs-volt		(	mp	bms.batVolt	-	mp	acb.chargeV		)							#	bms电池电压和acb电池电压差值																																																																																				
	#if	var	abs-volt		<	0																																																																																																		
	#	var	abs-volt		neg	var	abs-volt																																																																																																	
	#endif																																																																																																							
																																																																																																								
	var	pair-volt		(	mp	bms.batVolt	-	mp	acb.chargeV		)							#	内外侧电压差值																																																																																				
	if	var	pair-volt		<	0																																																																																																		
		var	pair-volt		neg	var	pair-volt																																																																																																	
	endif

	
	#此处后续需解封 
																																																																																																								
	#if	(	var	abs-volt		<	mp	bms.batVolt		*	5	/	100	)		#bms电池电压和acb电池电压差值小于5%																																																																																								
	#	&	(	mp	bms.batVolt	<=	mp	center.maxOutV		)					#外电压为充电机输出范围内																																																																																								
	#	&	(	mp	bms.batVolt	>=	mp	center.minOutV		)																																																																																													
	#	&	(	var	pair-volt		<	100	)									#内外电压差值小于10																																																																																								
																																																																																																								
	if	(	var	pair-volt		<	100	)																																																																																																
		#log	"charger output volt is OK, begin close output switch ------"																																																																																																					
																																																																																																								
		mpofs		acb.acbStopReason			0			7								#	停止充电原因:7.合直流输出开关失败																																																																																				
																																																																																																								
																																																																																																								
		call	acbc-doOutSwitchON																#	合直流输出开关																																																																																				
																																																																																																								
		log	"START 8: begin change DC output switch to OK ------"																																																																																																					
																																																																																																								
		statemp		acb.state-tmo			acb-stopBeginProcess				5000																																																																																													
		statemp		acb.state-send			acbc-doOutSwitchON				1000								#	设置重复执行定时器																																																																																				
		statemp		acb.state			acb-15-waitOutSwitchON				0								#	等待合直流输出开关成功																																																																																				
	endif																																																																																																							
																																																																																																								
	call	acbc-isStartInterrupted																	#	检查启动过程是否被中断																																																																																				
																																																																																																								
																																																																																																								
[state]	acb-15-waitOutSwitchON	等待直流开关闭合												#																																																																																					
																																																																																																								
#	log	"等待直流开关闭合"
	call	acbc-checkAlarmInStartProcess						#检查起机过程中是否有报警																																																																																																
																																																																																																								
	call	acbc-isStartInterrupted																	#	检查启动过程是否被中断																																																																																				
																																																																																																								
	if	(	mpofs	acb.frontIn	0	&	mpofs	acb.outSwitch	0		)	!=	0	#	如果直流输出开关状态为1																																																																																				
																			#	S8.启动充电模块																																																																																				
		log	"-"	gun	":START 5: DC output switch state be closed OK OK OK OK OK OK !!!!!"		mp	center.chgStatus																																																																																																		
																																																																																																								
		if	mp	center.chgStatus			<	const	st-charge																																																																																															
			mp	center.chgStatus			const	st-charge											#	设置成充电中状态																																																																																				
		endif																																																																																																						
																																																																																																								
		#log	"-"	gun	":START 6: begin to start charger module --------- "																																																																																																			
																																																																																																								
		statemp		acb.state-tmo			idle						0																																																																																											
		statemp		acb.state-send			idle						0						#	设置重复执行定时器																																																																																				
		statemp		acb.state			acb-finalStartProcess						0						#	等待启动充电模块成功																																																																																				
	endif																																																																																																							
																																																																																																								
																																																																																																								
[state]	acb-finalStartProcess	最终启动成功												#																																																																																					
	log	"最终启动成功"	mp	center.chgStatus
	mp	acb.startOK			1														#	充电桩起机成功																																																																																				
	mpofs		acb.acbStopReason			0			0									#	设置充电原因为0																																																																																				
	statemp		acb.state-tmo			idle				0																																																																																														
	statemp		acb.state-send			idle				0									#	设置重复执行定时器																																																																																				
	statemp		acb.state			acb-waitStopCharging				0									#	启动成功,等待状态转到停机中																																																																																				
[state]	acb-stopBeginProcess	停止充电的启动流程												#																																																																																					
	log	"-"	gun	":--start process Fail !!!!  --- stop reason:"	mpofs	acb.acbStopReason	mp	center.curPile																																																																																					
	#log	"停止充电的启动流程"
	log	"acb.acbStopReason"	mp	acb.acbStopReason
	if	mp	acb.startStatus			=	1								#bms启动节点启动后,由bms节点将状态设置为1 此时BMS已经由待机转为启动																																																																																			
		if	mp	center.chgStatus			<	const	st-stop																																																																																															
			mp	center.chgStatus			const	st-stop																																																																																																
		endif																																																																																																						
		call	acbc-resetCommState			#	重置acb通讯状态																																																																																				
		statemp		acb.state-tmo			idle				0																																																																																													
		statemp		acb.state-send			idle				0																																																																																													
		statemp		acb.state			acb-waitStopCharging	0		#启动失败,将状态直接转到停机中																																																																																				
	else																																																																																																							
		if	mp	center.chgStatus			<	const	st-stopped																																																																																															
			mp	center.chgStatus			const	st-stopped																																																																																																
		endif																																																																																																						
		statemp		acb.state-tmo			idle				0																																																																																													
		statemp		acb.state-send			idle				0																																																																																													
		statemp		acb.state			acb-beginStopCharging				0								#	启动失败,将状态直接转到停机中																																																																																				
	endif																																																																																																							
																																																																																																								
[state]	acb-stopModuleFatalError	无法停止充电模块的致命错误节点												#																																																																																					
#tag	command																																																																																																							
	#log	"-"	gun	":-------------------happen fatal error : charger module can not stop !!!"																																																																																																				
	log	"无法停止充电模块的致命错误节点"
	mp		center.fatal			1													#	致命错误1:充电模块无法停机																																																																																				
	if		mp	center.chgStatus			=	const	st-configed																																																																																															
		statemp		acb.state-tmo			idle				0																																																																																													
		statemp		acb.state-send			idle				0																																																																																													
		statemp		acb.state			acb-stopBeginProcess				0								#	绝缘检测模块停机失败																																																																																				
	else																																																																																																							
		statemp		acb.state-tmo			idle				0																																																																																													
		statemp		acb.state-send			idle				0																																																																																													
		statemp		acb.state			acb-beginStopCharging				0								#	K2.等待分直流输出开关																																																																																				
	endif																																																																																																							
																																																																																																								
[state]	acb-RelaseFailFatalError	泄放失败的致命错误节点												#																																																																																					
#tag	command																																																																																																							
																																																																																																								
	#log	"-"	gun	":-------------------happen fatal error : still have high volt after release !!!"																																																																																																				
	log	"泄放失败的致命错误节点"
																																																																																																								
	mp		center.fatal			2													#	致命错误2:泄放后仍然有电压																																																																																				
	statemp		acb.state-tmo			idle				0																																																																																														
	statemp		acb.state-send			idle				0																																																																																														
	statemp		acb.state			acb-fatalError				0									#	启动失败,将状态直接转到停机中																																																																																				
																																																																																																								
																																																																																																								
[state]	acb-fatalError	致命错误节点												#																																																																																					
	log	"-"	gun	":-------------------happen fatal error : "					mp	center.fatal
	call	acbc-standby-init																	#	结束后转至待机流程
	call	bms-init
	mp	center.chgStatus	const	st-standby	
[state]	acb-waitStopCharging	等待充电机状态变为停机中												#																																											
#tag	command																																																													
#	log	"等待充电机状态变为停机中"	mp	center.chgStatus
	if	mp	center.chgStatus			>=	const	st-stop											#	等待状态变为"停机中"																																										
		log	"-"	gun	":the center status changed to st_stop, begin stop charging !!!="	mp	center.chgStatus																																																									
		statemp		acb.state			acb-beginStopCharging				mini								#	执行"停机"节点																																										
		return																																																												
	endif																																																													
	call	acbc-updateCommState																	#	更新板卡通讯状态																																										
	call	acbc-checkRuningAlarm																	#	充电中出现报警																																										
																																																														
	if	var	rtn	=	1																																																									
		log	"-"	gun	":充电中出现报警，置为停机 !!!"	mp	acb.acbStopReason																																																								
		if	mp	center.chgStatus			<	const	st-stop																																																					
			mp	center.chgStatus			const	st-stop											#	充电中出现报警,则把充电状态置为"停机中"																																										
		endif																																																												
		statemp		acb.state			acb-beginStopCharging				mini								#	执行"停机"节点																																										
	endif																																																													
																																																														
[state]	acbc-checkRuningAlarm	充电过程中检查各种状态												#																																											
#tag	command																		#																																											
#	log	"充电过程中检查各种状态"
																																																														
	var	rtn	0																																																											
																																																														
	#	检测是否有报警记录																																																												
	call	acbc-isInAlarmStatus																																																												
	if	var	rtn	!=	0														#	如果检测到报警信息																																										
		log	"-"	gun	":find alarm in charging"																																																									
		mpofs	acb.acbStopReason			0			9									#	停止充电原因:9.充电中,检测到报警																																										
		var	rtn	1																																																										
		return																																																												
	endif																																																													
																																																														
	if	(	mp	center.alarmComm			&	0xFF	)	!=	0								#	检查充电模块通讯状态																																										
		log	"-"	gun	":find alarm in charging, charger module comm be cut !!!"																																																									
		mpofs	acb.acbStopReason			0			9									#	停止充电原因:9.充电中,检测到报警																																										
		var	rtn	1																																																										
		return																																																												
	endif																																																													
#	#	电压是否越限																																																												
#	if	mp	acb.chargeV		>	(	mp	center.ratedOutV			*	const	acb-U-top		/	100	)																																													
#																																																														
#		#log	"find charger volt off-limit alarm !!!"																																																											
#																																																														
#		mpofs	acb.acbStopReason			mp	center.curGun			18									#	停止充电原因:18.充电中,电压越限																																										
#		var	rtn	1																																																										
#		return																																																												
#	endif																																																													
																																																														
	#	电压是否越限
	#log	"acb.chargeV="	mp	acb.chargeV	"bms.maxReqV="	mp	bms.maxReqV
	#log	"差"		mp	acb.chargeV	-	mp	bms.maxReqV	
	#log	"比值"		mp	bms.maxReqV		/	20	
	if	(	mp	acb.chargeV	-	mp	bms.maxReqV	)	>	(	mp	bms.maxReqV		/	20	)	# 差值为额定需求的5%																																																						
		log	"find charger volt lager than  bms.maxReqV !!!"																																																											
		mpofs	acb.acbStopReason			0			18									#	停止充电原因:18.充电中,电压越限																																										
		var	rtn	1																																																										
		return																																																												
	endif																																																													
																																																														
	#	电流是否越限																																																												
	var	rateOutC		(	mp	center.ratedOutC			*	mp	center.chgrPerPile			*	mp	center.pileNum		)																																												
																																																														
	if	mp	acb.chargeC		>	(	var	rateOutC		*	const	acb-U-top		/	100	)																																														
																																																														
		#log	"find charger current off-limit alarm !!!"																																																											
																																																														
		mpofs	acb.acbStopReason			mp	center.curGun			19									#	停止充电原因:19.充电中,电流越限																																										
		var	rtn	1																																																										
		return																																																												
	endif																																																													
		#log	"temprA="	mpofs	acb.temprA	0	";temprB="	mpofs	acb.temprB	0	
		#log	"枪温阀值="	mp	center.mpGunTemperUpper	
		#判断温度是否越限																																																												
		if	(	mpofs	acb.temprA	0	)	>	mp	center.mpGunTemperUpper																																																		
																																																														
			#log	"gun A tempture is off-limit alarm !!!"																																																										
																																																														
			mpofs	acb.acbStopReason			mp	center.curGun			20								#	停止充电原因:20.充电中,A1枪温度越限																																										
			var	rtn	1																																																									
			return																																																											
																																																														
		endif																																																												
																																																														
		if	(	mpofs	acb.temprB	0	)	>	mp	center.mpGunTemperUpper																																																	
																																																														
			#log	"gun B tempture is off-limit alarm !!!"																																																										
																																																														
			mpofs	acb.acbStopReason			mp	center.curGun			22								#	停止充电原因:21.充电中,A2枪温度越限																																										
			var	rtn	1																																																									
			return																																																											
																																																														
		endif																																																												
																																																														
	#	判断枪是否连接到车																																																												
	var	linkCarStatus			0																																																									
	var	linkCarStatus	(	mpofs	acb.frontCmpr	0	&	mpofs	acb.linkOK		0	)	
		
	if	var	linkCarStatus	!=	mpofs	acb.linkOK		0																																																									
		mpofs	acb.acbStopReason			0			10									#	停止充电原因:10.充电中,检测到充电枪未连接到车上																																										
		var	rtn	1																																																										
		return																																																												
	endif																																																													
																																																														
#	call	acbc-isCloseLinkSwitch																																																												
#	if	var	rtn	=	0														#	联络开关应合但未合																																										
#																																																														
#		#log	"link switch is not closed, stop chargering !!!!"																																																											
#																																																														
#		mpofs	acb.acbStopReason			mp	center.curGun			25									#	停止充电原因:25.充电中,联络开关未合																																										
#		var	rtn	1																																																										
#		return																																																												
#																																																														
#	endif																																																													
#																																																														
#	call	acbc-isOpenBorderLinkSwitch																																																												
#	if	var	rtn	!=	0														#	边界联络开关应分但未分																																										
#																																																														
#		#log	"link switch of border is not opened, stop chargering !!!!"																																																											
#																																																														
#		mpofs	acb.acbStopReason			mp	center.curGun			26									#	停止充电原因:26.充电中,边界联络开关未分																																										
#		var	rtn	1																																																										
#		return																																																												
#																																																														
#	endif																																																													
																																																														
	#	判断辅助电源电压,暂时不用																																																												
	#	if	(	mpofs	acb.frontCmpr		mp	center.curPile		&	mp	acb.accPowerV			)	=	0		#	没有辅助电压了																																										
	#																																																													
	#		#log	"can not find auxiliary power volt in charging"																																																										
	#																																																													
	#		mpofs	acb.acbStopReason			mp	center.curGun			11								#	停止充电原因:11.充电中未检测到辅助电源																																										
	#		var	rtn	1																																																									
	#	endif																																																												
																																																														
	#	判断电池电压																																																												
	if	(	func	acbc-isGetBatteryU	0	)	=	0					#	没有检测到电池电压																																										
		log	"-"	gun	":充电中未检测到电池电压"																																																									
		mpofs	acb.acbStopReason	mp	center.curPile	12				#	停止充电原因:12.充电中未检测到电池电压																																										
		var	rtn	1																																																										
	endif																																																													
																																																														
	#	判断是否刷卡停机																																																												
	if	mp	center.cardStop			=	1												#	刷卡电流																																										
																																																														
#		log	"-"	gun	":swip card to stop in charging"																																																									
																																																														
		mp	center.cardStop			0													#	将刷卡停机标识位复位																																										
		mpofs	acb.acbStopReason			0			13									#	停止充电原因:13.刷卡停机																																										
		var	rtn	1																																																										
		return																																																												
	endif																																																													
																																																														
	#	检查急停开关状态																																																												
	if	(	mpofs	acb.frontIn		mp	center.curPile			&	mp	acb.emergency		)	!=	0			#	检查急停开关状态，报警位为：1																																										
																																																														
#		log	"gun "		gun	" find emergency action!!!"																																																								
		mpofs	acb.acbStopReason	0			9									#	停止充电原因:9.充电中,检测到报警																																										
		var	rtn	1																																																										
		return																																																												
																																																														
	endif																																																													
																																																														
#	#log	"out switch status:"				%X	\																																																							
#		(	mpofs	acb.backIn		mp	center.curPile		&	mpofs	acb.outSwitch		mp	center.curGun		)																																														
	#判断直流输出继电器状态																																																													
	if	(	mpofs	acb.frontIn	0	&	mpofs	acb.outSwitch	0	)	=	0	#	直流输出接触器																																										
#		log	"-"	gun	"@@@@@@@@@1111@@@@@"	mpofs	acb.frontIn	0	"--"	mpofs	acb.outSwitch	0																																																									
		mpofs	acb.acbStopReason	0	28		#joy																																																				
		var	rtn	1																																																										
	endif																																																													
																																																														
	#log	"gun"		gun	" - com-switch status:"					mpofs	a.acb.backIn		0	&	mpofs	acb.commSwitch		mp	center.curPile			\																																								
																																																														
	call		acbc-calculateTimeKwh																#	计算分时计费的充电电量和充电金额																																										
	call		acbc-calculateChargerTime																#	计算充电时间																																										
																																																														
	var	balance	(	mpdt	bgm.balance	3	-4	)	#余额（规约下发高低字节为反）

	var	money_left	(	var	balance	-	(	mpofs	acb.moneyCount	0	)	-	(	mp	center.serviceCost	)	)
	
	if	var	money_left		<=	0																																																						
		log	"remain money is very little, remainMoney:"	var	money_left																																																	
		mpofs	acb.acbStopReason			mp	center.curGun			14																																																			
		var	rtn	1																																																									
		return																																																											
	endif																																																												
																			#																																											
[state]	acbc-resetTimeKwh	复位分时电量值												#																																											
#tag	command																																																													
																																																														
#	mp	center.curGun			0														#	初始化A枪充电时间变量																																										
#	mp	center.setTime			0														#	开始时间																																										
#	mp	center.setTime			1														#	结束时间																																										
#	mp	center.curGun			1														#	初始化B枪充电时间变量																																										
#	mp	center.setTime			0														#	开始时间																																										
#	mp	center.setTime			1														#	结束时间																																										
#	mp	center.curGun			0																																																									
#	log	"复位分时电量值"
																																																														
	#设置电量统计的初始值																																																													
	var	i	0																																																											
	do	while	var	i	<	5																																																								
		mpofs	acb.calKwh		var	i	0																																																							
		add	var	i	1																																																									
	loop																																																													
	mp	acb.lastKwh			mpofs	acb.curKwh			0																																																					
																																																														
	var	i	0																																																											
	do	while	var	i	<	5																																																					
		mpofs	center.beginKwh			var	i	mpofs	acb.calKwh		var	i		#	初始化起始电量																																										
		mpofs	center.endKwh			var	i	mpofs	acb.calKwh		var	i																																													
																																																														
		mpofs	center.chargeKwh			var	i	0								#	初始化充电电量																																										
		mpofs	center.chargeMoney			var	i	0																																																						
																																																														
		add	var	i	1																																																									
	loop																																																													
																																																														
	mp	acb.timeCount			0																																																									
	var	i	0																																																											
	do	while	var	i	<	5																																																								
		mpofs	acb.kwhCount				var	i	0																																																					
		mpofs	acb.moneyCount				var	i	0																																																					
																																																														
		add	var	i	1																																																									
	loop																																																													
																																																														
	#复位SOC及剩余时间																																																													
	mp	bms.soc		0																																																										
	mp	bms.rmnTime		0																																																										
	mp	center.serviceCost	0																																																														
	mp	acb.meterDataError			0	#电表数据异常标志																																																								
																																																														
	mpofs	bms.BSM		0	0	#将bms的电池温度数据置为0																																																								
	mpofs	bms.BSM		1	0																																																									
																																																														
																																																														
[state]	acbc-setBeginTimeKwh	设置起始分时电量												#																																											
#tag	command																																																													
#	log	"设置起始分时电量"
																																																														
	if	mpofs	center.price		4	=	2			#	0：无电表，1：单费率电表，2：多费率电表								#	复费率																																										
																																																														
		var	index	(	mp	center.curGun		*	5	)									#	起始电量的偏移量起始值																																										
		var	i	0																																																										
																																																														
		do	while	var	i	<	5												#	分别统计各个分时电量																																										
			mpofs	center.beginKwh			var	index	mpofs	acb.calKwh		var	i																																																	
																																																														
			add	var	index	1																																																								
			add	var	i	1																																																								
		loop																																																												
																																																														
	else																																																													
																			#	单费率																																										
		var	i	(	mp	center.curGun		*	5	)																																																				
		mpofs	center.beginKwh			var	i	mp	acb.calKwh										#	总电量																																										
																																																														
	endif																																																													
																																																														
																																																														
[state]	acbc-calculateTimeKwh	计算充电中的分时电量												#																																											
#tag	command																																																													
#	log	"计算分时电量="	mpofs	center.price		4																																																													
	var	meter-error		0
	
	if	mp	acb.curKwh		<	mpofs	center.beginKwh			0								#	判断电量是否合理																																										
		var	meter-error		1																																																								
	endif																																																												
																																																														
	if	var	meter-error		=	1																																																								
		mp	acb.meterDataError			1	#电表数据异常标志																																																							
		return																																																												
	endif																																																													
																																																														
	#将当前消费的电量进行记录,分别保存到相应的时段中																																																													
	if	mp	acb.lastKwh		<	mpofs	acb.curKwh		0																																																					
																																																														
		var	newKwh		mpofs	acb.curKwh		0																																																						
		var	addKwh		(	var	newKwh	-	mp	acb.lastKwh		)						#获得电量增量,并保存为上次处理值																																												
		mp	acb.lastKwh		mpofs	acb.curKwh		0																																																						
																																																														
		#log	"TIME kwh: add kwh = "					var	addKwh																																																					
		#获取当前时间(00:00:00开始的秒数)，确定属于哪一个费率范围																																																												
		varsz	t	2	#time,time2a都需要分配2个int的空间																																																									
		var	t	0	#表示取当前时间																																																									
		time	addr	t	#得时间,从1970年起的秒与微秒																																																									
		time2a	addr	t	#得时间,CP56Time2a格式,扩展了一个字节,存年的高2位

		var	hour		vardt	t	3	1				#时																																																																																																	
		var	min			vardt	t	2	1				#分																																																																																																	
		var	sec		(	vardt	t	0	2	)	/	1000	#秒		
		#log	"小时="	var	hour	"分钟="	var	min	"秒="	var	sec
		var	passSec	(	var	hour	*	3600	+	var	min	*	60	+	var	sec	)
		#log	"当前逝去秒="	var	passSec
		
		#获取当前费率
		var	i	0
		var	curPrice	0
		
		do	while	var	i	<	mp	center.rateNum
			if	(	var	passSec	>	mpofs	center.rateTimeStart	var	i	)	&&	(	var	passSec	<=	mpofs	center.rateTimeEnd	var	i	)
				var	curPrice	(	mpofs	center.rate	var	i	)
			endif
			add	var	i	1	
		loop
		#if	var	curPrice	!=	0	#获取成功
		#	log	"当前电费="	var	curPrice
		#endif
																																																														
		add	mpofs	acb.calKwh		0			var	addKwh				#加总电量																																																
		#add	mpofs	acb.calKwh		var	time-flag		var	addKwh		#加相应的分时电量	后续可将尖峰平谷电费区分开来																																															
	else																																																													
		return		#总数值没有变化																																																										
	endif																																																													
																			#	单费率																																										
	if	mp	center.curGun			=	0																																																						
		var	this-kwh		(	mp	acb.calKwh		-	mpofs	center.beginKwh			0	)			#	单位:0.01kwh																																										
		mpofs	center.chargeKwh			0		var	this-kwh										#	A枪总电量																																										
		mp	acb.kwhCount			var	this-kwh																																																						
																																																													
		add	(	mpofs	center.chargeMoney			0	)	(	(	var	addKwh		*	var	curPrice	)	/	10000	)	#A枪总金额																																										
	#	div	(	mpofs	center.chargeMoney	0	)	10
	#	log	"gun 1 now kwh:"			mp	acb.calKwh		" - begin kwh:"			mpofs	center.beginKwh			0																																													
	#	log	"charge kwh:"			mpofs	center.chargeKwh			0																																																			
	#	log	"center.chargeMoney:"				mpofs	center.chargeMoney			0																																																		
	#																																																												
	#else																																																												
	#	var	this-kwh		(	mp	acb.calKwh		-	mpofs	center.beginKwh			5	)			#	枪2的电量																																										
	#	mpofs	center.chargeKwh			5		var	this-kwh									#	B枪电量																																										
	#	mpofs	center.chargeKwh			6		var	this-kwh									#	默认为尖电量																																										
	#	mp	acb.kwhCount		(	var	this-kwh		+	mpofs	center.chargeKwh			0	)			#	B枪工作时:总电量要加上A的电量																																										
	#																																																												
	#	mpofs	center.chargeMoney			5	(	var	this-kwh		*	mp	center.price		)	/	100000		#B枪总金额																																										
	#	mpofs	center.chargeMoney			6	(	var	this-kwh		*	mp	center.price		)	/	100000																																												
	#																																																												
	#	log	"gun 2 now kwh:"			mp	acb.calKwh		" - begin kwh:"			mpofs	center.beginKwh			5																																													
	#	log	"charge kwh:"			mpofs	center.chargeKwh			5																																																			
	#	log	"center.chargeMoney:"				mpofs	center.chargeMoney			5																																																		
	endif																																																												
																																																													
	mp	acb.moneyCount		(	mpofs	center.chargeMoney			0	)	/	10		#	单位:分																																										
	


	mp	center.serviceCost	(	(	mpofs	acb.kwhCount	0	)	*	mp	center.servicePrice	)	/	100	#总服务费
	
	#log	"total kwh:"			mp	acb.kwhCount																																																							
	#log	"toatal money:"			mp	acb.moneyCount																																																							
[state]	acbc-calculateChargerTime	计算充电时间												#																																											
#	log	"计算充电时间"
	call	acbc-setEndTime					#重置停止时间																																																							
	varsz	t	2	#time,time2a都需要分配2个int的空间																																																										
	var	t	0	#表示取当前时间		
		
	time	addr	t	#得时间,从1970年起的秒与微秒	
																																																												
	if	mp	center.curGun			=	0												#	统计充电时间	
	mp	acb.timeCount				(	var	t	-	mpofs	center.startTime			0	)																																														
	mpofs	acb.chgrTimeCount			0	(	var	t	-	mpofs	center.startTime			0	)	/	60	
	
	#log	"枪="	mp	center.curGun	";1枪当前时间="	var	t	";1枪起始时间="	mpofs	center.startTime	0	"计时="	mpofs	acb.chgrTimeCount			0		
	else
		mp	acb.timeCount				(	var	t	-	mpofs	center.startTime			1	)																																														
		mpofs	acb.chgrTimeCount			0	(	var	t	-	mpofs	center.startTime			1	)	/	60
		#log	"枪="	mp	center.curGun	";2枪当前时间="	var	t	";2枪起始时间="	mpofs	center.startTime			1	"计时="	mpofs	acb.chgrTimeCount			0
	endif																																																													
[state]	acb-beginStopCharging	充电机停机中												#																																																																																	
#tag	command																																																																																																			
	#ZB测试 chargeC!!!! < 50
	#log	"gun"	gun	":****** wait center.chgStatus to  st-stopped ******"																																																																																																
	#log	"ACB充电机停机中gun= status="	gun	mp	center.chgStatus
	#log	"acb.chargeC="	%X	mp	acb.chargeC																																																																																																		
	if	mp	center.chgStatus			>=	const	st-stopped											#	K1.等待充电状态变为已停机																																																																																
		&	(	mp	acb.chargeC		<	500	)															#	电流小于5A																																																																																
																																																																																																				
		if	mpofs	center.stopReason			0			=	0							#	将acb中的停止原因覆盖到center的停止原因																																																																																
			mpofs	center.stopReason			0			mpofs	acb.acbStopReason			0																																																																																				
		endif																																																																																																		
																																																																																																				
		#log	"gun"	gun	":begin stop charging, stop reason:"						mpofs	center.stopReason			0																																																																																			
																																																																																																				
		#log	"gun"	gun	":stop 1: begin open the DC output switch ----------"																																																																																															
																																																																																																				
		statemp		acb.state-his			idle				0								#	停止自动保存历史数据定时器																																																																																
		call	acbc-stopChargerModule																	#	J7.停充电模块																																																																																				
																																																																																																		
		call	acbc-doOutSwitchOFF																																																																																																	
																																																																																																				
		statemp		acb.state-tmo			acb-openDCSwitchFailFatalError		5000						#	致命错误3:分直流输出开关失败																																																																																
		statemp		acb.state-send			acbc-doOutSwitchOFF					1000						#	设置重复执行定时器																																																																																
		statemp		acb.state			acb-waitOutSwitchOFF					0							#	K2.等待分直流输出开关																																																																																
	endif																																																																																																			
[state]	acb-waitOutSwitchOFF	等待分直流输出开关												#																																																																																	
#tag	command																																																																																																			
#	log	"等待分直流输出开关"
	if	(	mpofs	acb.frontIn	0	&	mpofs	acb.outSwitch	0	)	=	0	#	如果直流输出开关状态为0	
		log	"分直流输出开关后投泄放"
		call	acbc-putRealse																																																																																																	
	endif																																																																																																			
[state]	acbc-putRealse	是否需要泄放												#																																																																																	
#	log	"是否需要泄放"
	if	mp		center.fatal		!=	0																																																																																													
		|	mp	center.insultFail-2			!=	0	
		log	"分母联开关"
		call	acbc-closeLinkSwitch																																																																																																	
		statemp		acb.state-tmo			acb-openLinkSwitchFailFatalError					5000																																																																																								
		statemp		acb.state-send			acbc-openLinkSwitch					0																																																																																								
		statemp		acb.state			acb-waitLinkSwitchOFFInStop					0																																																																																								
	else																																																																																																			
		log	"直接投泄放"
		call	acbc-doPutRelease																#	控制泄放控制为1																																																																																
		statemp		acb.state-tmo			acb-cutReleaseInStop				3000								#	等待三秒钟																																																																																
		statemp		acb.state-send			idle				0																																																																																									
		statemp		acb.state			idle				0																																																																																									
	endif																																																																																																			
																																																																																																				
[state]	acb-cutReleaseInStop	停机中,切泄放												#																																																																																	
	call	acbc-doCutRelease																																																																																																		
	statemp		acb.state-tmo			acb-openReleaseOpenErro				3000																																																																																										
	statemp		acb.state-send			acbc-doCutRelease				1000																																																																																										
	statemp		acb.state			acb-waitReleaseOpenInStop				0																																																																																										
[state]	acb-waitReleaseOpenInStop	停机中,切泄放成功												#																																																																																	
	if	(	(	mpofs	acb.backOut		mp	center.curPile		)	&	mp	acb.leakLoop		)	=	0		#	泄放开入为0																																																																																
		&	(	canid	&	0xFF0000		)	=	0xD10000									#	收到D1																																																																																
		call	acbc-closeLinkSwitch																																																																																																	
		statemp		acb.state-tmo			acb-openLinkSwitchFailFatalError					5000																																																																																								
		statemp		acb.state-send			acbc-closeLinkSwitch					0																																																																																								
		statemp		acb.state			acb-waitLinkSwitchOFFInStop					0																																																																																								
	endif																																																																																																			
[state]	acb-waitLinkSwitchOFFInStop	等待联络开关分												#																																																																																	
	#log	"等待联络开关分"
	#call	acbc-linkSwitchState																																																																																																		
	#if	var	rtn	=	0																																																																																															
		call	acbc-doAccPowerOff														#	切辅助电源
		call	acbc-doCutSwitchV														#	切换为12V
		statemp		acb.state-tmo			acb-changeToAccPowerUCheckOFF	3000		#	跳至切辅助电源电压检测节点																																																																																
		statemp		acb.state-send			acbc-doAccPowerOff	1000					#	设置重复执行定时器																																																																																
		statemp		acb.state			acb-waitAccPowerOff	0							#	等待分联络开关																																																																																
	#endif																																																																																																			
[state]	acb-openReleaseOpenErro	停机中,切泄放超时												#																																																																																	
	call	acbc-closeLinkSwitch																																																																																																		
	statemp		acb.state-tmo			acb-openLinkSwitchFailFatalError					5000																																																																																									
	statemp		acb.state-send			acbc-closeLinkSwitch					0																																																																																									
	statemp		acb.state			acb-waitLinkSwitchOFFInStop					0																																																																																									
[state]	acb-waitAccPowerOff	等待关辅助电源												#																																																																																	
	#if	func	acbc-isAccPowerOn			0	=	0									#	没有辅助电源																																																																																
		call		acbc-unlockGunFromCarWithLock										#	从车上解锁枪																																																																																
		statemp		acb.state-tmo			acb-stopCharingInUnlockStatus	10000		#改为即使枪未解锁也可以正常停止充电						#	原为:acb-unlockFromCarFailFatalError  从车上解锁枪失败,致命错误																																																																																
		statemp		acb.state-send			acbc-unlockGunFromCarWithLock	1000		#	设置重复执行定时器																																																																																
		statemp		acb.state			acb-waitUnlockGunFromCar	0					#	K7.将枪从桩上解锁																																																																																
	#endif																																																																																																			
[state]	acb-changeToAccPowerUCheckOFF	如果辅助电源切不掉,直接跳转至切辅助电源电压检测节点												#																																																																																	
	call	acbc-doAccPowerUCheckOFF																#	分"辅助电源电压检测切换"																																																																																
	statemp	acb.state-tmo	acb-openAccPowerUCheckFailFatalError	5000							#	分辅助电源电压检测测点失败,致命错误																																																																																
	statemp	acb.state-send	acbc-doAccPowerUCheckOFF				1000							#	设置重复执行定时器																																																																																
	statemp	acb.state	acb-waitAccPowerUCheckOFFInStop				0								#																																																																																	
[state]	acb-waitAccPowerUCheckOFFInStop	停机中,等待"辅助电源电压检测切换"退出												#																																																																																	
#tag	command																																																																																																			
	log	"停机中,等待"辅助电源电压检测切换"退出"
	if	(	mpofs	acb.frontIn	mp	center.curPile	&	mp	acb.accCheck	)	=	0				#	如果"辅助电源电压检测切换动作开入"为0																																																																																
		#log	"-"	gun	":stop 7: acc power check has been changed to OFF OK OK OK OK OK OK!!!"																																																																																															
		mp	acb.doUnlockCarFlag				0																																																																																													
		call		acbc-unlockGunFromCarWithLock													#	从车上解锁枪																																																																																
		statemp		acb.state-tmo	acb-stopCharingInUnlockStatus					10000			#改为即使枪未解锁也可以正常停止充电						#	原为:acb-unlockFromCarFailFatalError  从车上解锁枪失败,致命错误																																																																																
		statemp		acb.state-send	acbc-unlockGunFromCarWithLock					1000			#	设置重复执行定时器																																																																																
		statemp		acb.state		acb-waitUnlockGunFromCar						0				#	K7.将枪从桩上解锁																																																																																
	endif																																																																																																			
																																																																																																				
[state]	acb-stopCharingInUnlockStatus	在未解锁枪头时停止充电									#																																																																																	
	#log	"在未解锁枪头时停止充电"
	statemp		acb.state-tmo		idle					0									#																																																																																	
	statemp		acb.state-send		idle					0									#	设置重复执行定时器																																																																																
	statemp		acb.state			acb-finalStopCharging	0									#	调用停止充电的最后流程																																																																																
[state]	acb-waitUnlockGunFromCar	将枪从车上解锁							#																																																																																	
#	log	"将枪从车上解锁"
	call	acbc-isUnlockGunFromCar																#	将桩从车上解锁																																																																																
	if	var	rtn	=	1																																																																																															
		statemp		acb.state-tmo			idle				0								#																																																																																	
		statemp		acb.state-send			idle				0								#	设置重复执行定时器																																																																																
		statemp		acb.state			acb-finalStopCharging	0								#	调用停止充电的最后流程																																																																																
	endif																																																																																																			
[state]	acb-finalStopCharging	停机中的最后流程								#																																																																																	
	log	"停机中的最后流程"
#	mp	chgr.assit			0																																																																																															
	call	acbc-calculateChargerTime															#计算充电时间																																																																																													
	call	acbc-calculateTimeKwh																#计算充电电量及金额#统计本次充电的充电电量																																																																																
	if	mp	acb.dbgStatus		=	0															#非调试状态																																																																																													
		lock	acb.tcpCheckLock																																																																																																	
		if	mp	acb.tcpCheckCount			=	0																																																																																												
			mp	acb.tcpCheckCount			1																																																																																													
		#保存最终充电记录		后续增加 By zhaobo																																																																																										
			call	bgm-sendCheckout															#发送结账记录																																																																																												
		endif																																																																																																		
		#计算app时的余额																																																																																																		
		mp	card.balance	(	mp	center.cardRemain	-	mp	acb.moneyCount	)																																																																																					
		unlock	acb.tcpCheckLock																																																																																																	
	endif																																																																																																			
																																																																																																				
	if		mp	center.chgStatus			<	const	st-checkout																																																																																											
		mp	center.chgStatus			const	st-checkout										#	将状态切换为"待结账"状态,																																																																																
	endif																																																																																																			
#	statemp		acb.state-tmo			idle				0																																																																																										
	statemp		acb.state-tmo			acb-unchangeToInitFatalError	15000					#	平台一直不确认结算信息 持续发送30S后复位																																																																																		
	statemp		acb.state-send			idle				0									#	设置重复执行定时器																																																																																
	statemp		acb.state			acb-waitToCheckoutedState				0					#	等待状态变为结账完成状态																																																																																
	call		acbc-saveFailLog				#错误时保存错误日志																																																																																													
[state]	acb-waitToCheckoutedState	等待状态变为结账完成状态				#																																																																																	
	log	"等待状态变为结账完成状态"
	#if	1	#ZB测试mp	acb.dbgStatus		=	1																																																																																														
	#	mp	center.chgStatus				const	st-checkouted																																																																																												
	#endif																																																																																																			
	if	mp	center.chgStatus			=	const	st-checkouted								#	状态变为结账中																																																																																
		statemp		acb.state-tmo			acb-unchangeToInitFatalError	15000																																																																																								
		statemp		acb.state-send			idle					0							#	设置重复执行定时器																																																																																
		statemp		acb.state			acb-waitAllToInit					0					#	等待相关设备恢复成初始状态																																																																																
	endif																																																																																																			
[state]	acb-waitAllToInit	等待其他设置回复初始状态						#																																																																																	
	log	"等待其他设置回复初始状态"
	if	(	mp	chgr.state		=	state	chgr-standby		)								#	充电模块状态变为初始状态																																																																																	
		call	acbc-standby-init	
		call	bms-init	
		#	结束后转至待机流程																																																																																
		mp	center.chgStatus			const	st-standby										#	将状态置为standby																																																																																
	endif																																																																																																			
[state]	acb-openDCSwitchFailFatalError	分直流输出开关失败的致命错误节点	#																																																																																	
	log	"分直流输出开关失败的致命错误节点"
	mp		center.fatal			3															#	致命错误3:分直流输出开关失败																																																																																
	if	mp	acb.chargeC		<	100																																																																																														
		call	acbc-putRealse																																																																																																	
	else																																																																																																			
		statemp		acb.state-tmo			idle				0																																																																																									
		statemp		acb.state-send			idle				0								#	启动失败,将状态直接转到停机中																																																																																
		statemp		acb.state			idle				0									#																																																																																
		call		acb-fatalError																#																																																																																
	endif																						#																																																																													
[state]	acb-openLinkSwitchFailFatalError	分联络开关失败的致命错误节点						#																																																																																	
	log	"分联络开关失败的致命错误节点"
	mp		center.fatal			4															#	致命错误4:分联络开关失败																																																																																
	call	acbc-doAccPowerOff																	#	切辅助电源																																																																																
	statemp		acb.state-tmo			acb-changeToAccPowerUCheckOFF					3000	#	跳至切辅助电源电压检测节点																																																																																
	statemp		acb.state-send			acbc-doAccPowerOff					1000				#	设置重复执行定时器																																																																																
	statemp		acb.state			acb-fatalError					0						#	等待分联络开关																																																																																
[state]	acb-openAccPowerUCheckFailFatalError	分辅助电源电压检测开出失败的致命错误节点		#																																																																																	
	log	"分辅助电源电压检测开出失败的致命错误节点"
	mp		center.fatal			5															#	致命错误5:分辅助电源电压检测开出失败																																																																																
	statemp		acb.state-tmo			idle				0									#																																																																																	
	statemp		acb.state-send			idle				0									#																																																																																	
	statemp		acb.state			acb-fatalError				0								#	启动失败,将状态直接转到停机中																																																																																
[state]	acb-unlockFromCarFailFatalError	从车上解锁枪头失败的致命错误节点	#																																																																																	
	log	"从车上解锁枪头失败的致命错误节点"
	mp		center.fatal			6															#	致命错误6:从车上解锁枪头失败的致命错误节点																																																																																
	statemp		acb.state-tmo			idle				0									#																																																																																	
	statemp		acb.state-send			idle				0									#																																																																																	
	statemp		acb.state			acb-fatalError				0								#	启动失败,将状态直接转到停机中																																																																																
[state]	acb-unchangeToInitFatalError	无法恢复成初始状态致命错误			#																																																																																	
	log	"无法恢复成初始状态致命错误"
	mp		center.fatal			7															#	致命错误7:无法从恢复成初始状态致命错误																																																																																
	statemp		acb.state-tmo			idle				0									#																																																																																	
	statemp		acb.state-send			idle				0									#																																																																																	
	statemp		acb.state			acb-fatalError				0								#	启动失败,将状态直接转到停机中																																																																																
